"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["plugins_legacy-plugin-chart-calendar_src_ReactCalendar_jsx"],{

/***/ "./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js":
/*!**********************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js ***!
  \**********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default = function (values, valueof) {\n  let min;\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  }\n  return [min, max];\n};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9leHRlbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2V4dGVudC5qcz82NWYzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBsZXQgbWF4O1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js":
/*!*********************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js ***!
  \*********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default = function (start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n    n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n    range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9yYW5nZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3JhbmdlLmpzP2I3N2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/src/Calendar.js":
/*!**************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/src/Calendar.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ \"./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ \"./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/translation/TranslatorSingleton.ts\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\");\n/* harmony import */ var _vendor_cal_heatmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/cal-heatmap */ \"./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\nconst propTypes = {\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().shape({\n    // Object hashed by metric name,\n    // then hashed by timestamp (in seconds, not milliseconds) as float\n    // the innermost value is count\n    // e.g. { count_distinct_something: { 1535034236.0: 3 } }\n    data: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object),\n    domain: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n    range: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n    // timestamp in milliseconds\n    start: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n    subdomain: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)\n  }),\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  // eslint-disable-next-line react/sort-prop-types\n  cellPadding: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  // eslint-disable-next-line react/sort-prop-types\n  cellRadius: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  // eslint-disable-next-line react/sort-prop-types\n  cellSize: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  linearColorScheme: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  showLegend: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  showMetricName: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  showValues: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  steps: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  timeFormatter: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n  valueFormatter: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n  verboseMap: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object),\n  theme: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n};\n\nfunction Calendar(element, props) {\n  const {\n    data,\n    height,\n    cellPadding = 3,\n    cellRadius = 0,\n    cellSize = 10,\n    domainGranularity,\n    linearColorScheme,\n    showLegend,\n    showMetricName,\n    showValues,\n    steps,\n    subdomainGranularity,\n    timeFormatter,\n    valueFormatter,\n    verboseMap,\n    theme\n  } = props;\n\n  const container = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element).\n  classed('superset-legacy-chart-calendar', true).\n  style('height', height);\n  container.selectAll('*').remove();\n  const div = container.append('div');\n\n  const subDomainTextFormat = showValues ?\n  (date, value) => valueFormatter(value) :\n  null;\n\n  const metricsData = data.data;\n\n  const METRIC_TEXT = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_3__.t)('Metric');\n\n  Object.keys(metricsData).forEach((metric) => {\n    const calContainer = div.append('div');\n    if (showMetricName) {\n      calContainer.text(`${METRIC_TEXT}: ${verboseMap[metric] || metric}`);\n    }\n    const timestamps = metricsData[metric];\n    const extents = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Object.keys(timestamps), (key) => timestamps[key]);\n    const step = (extents[1] - extents[0]) / (steps - 1);\n    const colorScale = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_5__[\"default\"])().\n    get(linearColorScheme).\n    createLinearScale(extents);\n\n    const legend = (0,d3_array__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(steps).map((i) => extents[0] + step * i);\n    const legendColors = legend.map((x) => colorScale(x));\n\n    const cal = new _vendor_cal_heatmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    cal.init({\n      start: data.start,\n      data: timestamps,\n      itemSelector: calContainer.node(),\n      legendVerticalPosition: 'top',\n      cellSize,\n      cellPadding,\n      cellRadius,\n      legendCellSize: cellSize,\n      legendCellPadding: 2,\n      legendCellRadius: cellRadius,\n      tooltip: true,\n      domain: domainGranularity,\n      subDomain: subdomainGranularity,\n      range: data.range,\n      browsing: true,\n      legend,\n      legendColors: {\n        colorScale,\n        min: legendColors[0],\n        max: legendColors[legendColors.length - 1],\n        empty: theme.colors.grayscale.light5\n      },\n      displayLegend: showLegend,\n      itemName: '',\n      valueFormatter,\n      timeFormatter,\n      subDomainTextFormat\n    });\n  });\n}\n\nCalendar.displayName = 'Calendar';\nCalendar.propTypes = propTypes;const _default =\n\nCalendar;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/Calendar.js\");reactHotLoader.register(Calendar, \"Calendar\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/Calendar.js\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/Calendar.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvc3JjL0NhbGVuZGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9zcmMvQ2FsZW5kYXIuanM/NGM2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZXh0ZW50IGFzIGQzRXh0ZW50LCByYW5nZSBhcyBkM1JhbmdlIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgc2VsZWN0IGFzIGQzU2VsZWN0IH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSwgdCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCBDYWxIZWF0TWFwIGZyb20gJy4vdmVuZG9yL2NhbC1oZWF0bWFwJztcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICBkYXRhOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIC8vIE9iamVjdCBoYXNoZWQgYnkgbWV0cmljIG5hbWUsXG4gICAgLy8gdGhlbiBoYXNoZWQgYnkgdGltZXN0YW1wIChpbiBzZWNvbmRzLCBub3QgbWlsbGlzZWNvbmRzKSBhcyBmbG9hdFxuICAgIC8vIHRoZSBpbm5lcm1vc3QgdmFsdWUgaXMgY291bnRcbiAgICAvLyBlLmcuIHsgY291bnRfZGlzdGluY3Rfc29tZXRoaW5nOiB7IDE1MzUwMzQyMzYuMDogMyB9IH1cbiAgICBkYXRhOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGRvbWFpbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICByYW5nZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAvLyB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gICAgc3RhcnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgc3ViZG9tYWluOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB9KSxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvc29ydC1wcm9wLXR5cGVzXG4gIGNlbGxQYWRkaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvc29ydC1wcm9wLXR5cGVzXG4gIGNlbGxSYWRpdXM6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9zb3J0LXByb3AtdHlwZXNcbiAgY2VsbFNpemU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxpbmVhckNvbG9yU2NoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzaG93TGVnZW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvd01ldHJpY05hbWU6IFByb3BUeXBlcy5ib29sLFxuICBzaG93VmFsdWVzOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RlcHM6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpbWVGb3JtYXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICB2YWx1ZUZvcm1hdHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHZlcmJvc2VNYXA6IFByb3BUeXBlcy5vYmplY3QsXG4gIHRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LFxufTtcblxuZnVuY3Rpb24gQ2FsZW5kYXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgaGVpZ2h0LFxuICAgIGNlbGxQYWRkaW5nID0gMyxcbiAgICBjZWxsUmFkaXVzID0gMCxcbiAgICBjZWxsU2l6ZSA9IDEwLFxuICAgIGRvbWFpbkdyYW51bGFyaXR5LFxuICAgIGxpbmVhckNvbG9yU2NoZW1lLFxuICAgIHNob3dMZWdlbmQsXG4gICAgc2hvd01ldHJpY05hbWUsXG4gICAgc2hvd1ZhbHVlcyxcbiAgICBzdGVwcyxcbiAgICBzdWJkb21haW5HcmFudWxhcml0eSxcbiAgICB0aW1lRm9ybWF0dGVyLFxuICAgIHZhbHVlRm9ybWF0dGVyLFxuICAgIHZlcmJvc2VNYXAsXG4gICAgdGhlbWUsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBjb250YWluZXIgPSBkM1NlbGVjdChlbGVtZW50KVxuICAgIC5jbGFzc2VkKCdzdXBlcnNldC1sZWdhY3ktY2hhcnQtY2FsZW5kYXInLCB0cnVlKVxuICAgIC5zdHlsZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICBjb25zdCBkaXYgPSBjb250YWluZXIuYXBwZW5kKCdkaXYnKTtcblxuICBjb25zdCBzdWJEb21haW5UZXh0Rm9ybWF0ID0gc2hvd1ZhbHVlc1xuICAgID8gKGRhdGUsIHZhbHVlKSA9PiB2YWx1ZUZvcm1hdHRlcih2YWx1ZSlcbiAgICA6IG51bGw7XG5cbiAgY29uc3QgbWV0cmljc0RhdGEgPSBkYXRhLmRhdGE7XG5cbiAgY29uc3QgTUVUUklDX1RFWFQgPSB0KCdNZXRyaWMnKTtcblxuICBPYmplY3Qua2V5cyhtZXRyaWNzRGF0YSkuZm9yRWFjaChtZXRyaWMgPT4ge1xuICAgIGNvbnN0IGNhbENvbnRhaW5lciA9IGRpdi5hcHBlbmQoJ2RpdicpO1xuICAgIGlmIChzaG93TWV0cmljTmFtZSkge1xuICAgICAgY2FsQ29udGFpbmVyLnRleHQoYCR7TUVUUklDX1RFWFR9OiAke3ZlcmJvc2VNYXBbbWV0cmljXSB8fCBtZXRyaWN9YCk7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBtZXRyaWNzRGF0YVttZXRyaWNdO1xuICAgIGNvbnN0IGV4dGVudHMgPSBkM0V4dGVudChPYmplY3Qua2V5cyh0aW1lc3RhbXBzKSwga2V5ID0+IHRpbWVzdGFtcHNba2V5XSk7XG4gICAgY29uc3Qgc3RlcCA9IChleHRlbnRzWzFdIC0gZXh0ZW50c1swXSkgLyAoc3RlcHMgLSAxKTtcbiAgICBjb25zdCBjb2xvclNjYWxlID0gZ2V0U2VxdWVudGlhbFNjaGVtZVJlZ2lzdHJ5KClcbiAgICAgIC5nZXQobGluZWFyQ29sb3JTY2hlbWUpXG4gICAgICAuY3JlYXRlTGluZWFyU2NhbGUoZXh0ZW50cyk7XG5cbiAgICBjb25zdCBsZWdlbmQgPSBkM1JhbmdlKHN0ZXBzKS5tYXAoaSA9PiBleHRlbnRzWzBdICsgc3RlcCAqIGkpO1xuICAgIGNvbnN0IGxlZ2VuZENvbG9ycyA9IGxlZ2VuZC5tYXAoeCA9PiBjb2xvclNjYWxlKHgpKTtcblxuICAgIGNvbnN0IGNhbCA9IG5ldyBDYWxIZWF0TWFwKCk7XG4gICAgY2FsLmluaXQoe1xuICAgICAgc3RhcnQ6IGRhdGEuc3RhcnQsXG4gICAgICBkYXRhOiB0aW1lc3RhbXBzLFxuICAgICAgaXRlbVNlbGVjdG9yOiBjYWxDb250YWluZXIubm9kZSgpLFxuICAgICAgbGVnZW5kVmVydGljYWxQb3NpdGlvbjogJ3RvcCcsXG4gICAgICBjZWxsU2l6ZSxcbiAgICAgIGNlbGxQYWRkaW5nLFxuICAgICAgY2VsbFJhZGl1cyxcbiAgICAgIGxlZ2VuZENlbGxTaXplOiBjZWxsU2l6ZSxcbiAgICAgIGxlZ2VuZENlbGxQYWRkaW5nOiAyLFxuICAgICAgbGVnZW5kQ2VsbFJhZGl1czogY2VsbFJhZGl1cyxcbiAgICAgIHRvb2x0aXA6IHRydWUsXG4gICAgICBkb21haW46IGRvbWFpbkdyYW51bGFyaXR5LFxuICAgICAgc3ViRG9tYWluOiBzdWJkb21haW5HcmFudWxhcml0eSxcbiAgICAgIHJhbmdlOiBkYXRhLnJhbmdlLFxuICAgICAgYnJvd3Npbmc6IHRydWUsXG4gICAgICBsZWdlbmQsXG4gICAgICBsZWdlbmRDb2xvcnM6IHtcbiAgICAgICAgY29sb3JTY2FsZSxcbiAgICAgICAgbWluOiBsZWdlbmRDb2xvcnNbMF0sXG4gICAgICAgIG1heDogbGVnZW5kQ29sb3JzW2xlZ2VuZENvbG9ycy5sZW5ndGggLSAxXSxcbiAgICAgICAgZW1wdHk6IHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1LFxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlMZWdlbmQ6IHNob3dMZWdlbmQsXG4gICAgICBpdGVtTmFtZTogJycsXG4gICAgICB2YWx1ZUZvcm1hdHRlcixcbiAgICAgIHRpbWVGb3JtYXR0ZXIsXG4gICAgICBzdWJEb21haW5UZXh0Rm9ybWF0LFxuICAgIH0pO1xuICB9KTtcbn1cblxuQ2FsZW5kYXIuZGlzcGxheU5hbWUgPSAnQ2FsZW5kYXInO1xuQ2FsZW5kYXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBDYWxlbmRhcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/src/Calendar.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx":
/*!********************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_corejs3_helpers_extends__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime-corejs3/helpers/extends */ \"./node_modules/@babel/runtime-corejs3/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/chart/components/reactify.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* harmony import */ var _Calendar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Calendar */ \"./plugins/legacy-plugin-chart-calendar/src/Calendar.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\nconst ReactComponent = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_Calendar__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\nconst Calendar = (_ref) => {let { className, ...otherProps } = _ref;\n  const theme = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_3__.useTheme)();\n  return (\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { className: className },\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(_emotion_react__WEBPACK_IMPORTED_MODULE_4__.Global, {\n      styles: (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.css)`\n          .d3-tip {\n            line-height: 1;\n            padding: ${theme.gridUnit * 3}px;\n            background: ${theme.colors.grayscale.dark2};\n            color: ${theme.colors.grayscale.light5};\n            border-radius: 4px;\n            pointer-events: none;\n            z-index: 1000;\n            font-size: ${theme.typography.sizes.s}px;\n          }\n          /* Creates a small triangle extender for the tooltip */\n          .d3-tip:after {\n            box-sizing: border-box;\n            display: inline;\n            font-size: ${theme.typography.sizes.xs};\n            width: 100%;\n            line-height: 1;\n            color: ${theme.colors.grayscale.dark2};\n            position: absolute;\n            pointer-events: none;\n          }\n          /* Northward tooltips */\n          .d3-tip.n:after {\n            content: '\\\\25BC';\n            margin: -${theme.gridUnit}px 0 0 0;\n            top: 100%;\n            left: 0;\n            text-align: center;\n          }\n          /* Eastward tooltips */\n          .d3-tip.e:after {\n            content: '\\\\25C0';\n            margin: -${theme.gridUnit}px 0 0 0;\n            top: 50%;\n            left: -${theme.gridUnit * 2}px;\n          }\n          /* Southward tooltips */\n          .d3-tip.s:after {\n            content: '\\\\25B2';\n            margin: 0;\n            top: -${theme.gridUnit * 2}px;\n            left: 0;\n            text-align: center;\n          }\n          /* Westward tooltips */\n          .d3-tip.w:after {\n            content: '\\\\25B6';\n            margin: -${theme.gridUnit}px 0 0 0px;\n            top: 50%;\n            left: 100%;\n          }\n        ` }\n    ),\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(ReactComponent, (0,_babel_runtime_corejs3_helpers_extends__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({}, otherProps, { theme: theme }))\n    ));\n\n};__signature__(Calendar, \"useTheme{theme}\", () => [_superset_ui_core__WEBPACK_IMPORTED_MODULE_3__.useTheme]);\n\nCalendar.defaultProps = {\n  otherProps: {}\n};\n\nCalendar.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_6___default().string).isRequired,\n  otherProps: prop_types__WEBPACK_IMPORTED_MODULE_6___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_6___default().any))\n};const _default =\n\n(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_3__.styled)(Calendar)`\n  ${(_ref2) => {let { theme } = _ref2;return `\n    .superset-legacy-chart-calendar {\n      padding: ${theme.gridUnit * 3}px;\n      position: static !important;\n      overflow: auto !important;\n    }\n\n    .superset-legacy-chart-calendar .ch-tooltip {\n      margin-left: ${theme.gridUnit * 5}px;\n      margin-top: ${theme.gridUnit}px;\n    }\n\n    .superset-legacy-chart-calendar .d3-tip {\n      line-height: 1;\n      padding: ${theme.gridUnit * 3}px;\n      background: ${theme.colors.grayscale.dark2};\n      color: ${theme.colors.grayscale.light5};\n      border-radius: ${theme.borderRadius}px;\n      pointer-events: none;\n      z-index: 1000;\n    }\n\n    .cal-heatmap-container {\n      display: block;\n    }\n\n    .cal-heatmap-container .graph-label {\n      fill: ${theme.colors.grayscale.base};\n      font-size: ${theme.typography.sizes.xs}px;\n    }\n\n    .cal-heatmap-container .graph,\n    .cal-heatmap-container .graph-legend rect {\n      shape-rendering: crispedges;\n    }\n\n    .cal-heatmap-container .graph-rect {\n      fill: ${theme.colors.grayscale.light2};\n    }\n\n    .cal-heatmap-container .graph-subdomain-group rect:hover {\n      stroke: ${theme.colors.grayscale.dark2};\n      stroke-width: 1px;\n    }\n\n    .cal-heatmap-container .subdomain-text {\n      font-size: ${theme.typography.sizes.xs}px;\n      pointer-events: none;\n    }\n\n    .cal-heatmap-container .hover_cursor:hover {\n      cursor: pointer;\n    }\n\n    .cal-heatmap-container .qi {\n      background-color: ${theme.colors.grayscale.base};\n      fill: ${theme.colors.grayscale.base};\n    }\n\n    .cal-heatmap-container .q1 {\n      background-color: ${theme.colors.alert.light2};\n      fill: ${theme.colors.alert.light2};\n    }\n\n    .cal-heatmap-container .q2 {\n      background-color: ${theme.colors.alert.light1};\n      fill: ${theme.colors.alert.light1};\n    }\n\n    .cal-heatmap-container .q3 {\n      background-color: ${theme.colors.success.light1};\n      fill: ${theme.colors.success.light1};\n    }\n\n    .cal-heatmap-container .q4 {\n      background-color: ${theme.colors.success.base};\n      fill: ${theme.colors.success.base};\n    }\n\n    .cal-heatmap-container .q5 {\n      background-color: ${theme.colors.success.dark1};\n      fill: ${theme.colors.success.dark1};\n    }\n\n    .cal-heatmap-container rect.highlight {\n      stroke: ${theme.colors.grayscale.dark1};\n      stroke-width: 1;\n    }\n\n    .cal-heatmap-container text.highlight {\n      fill: ${theme.colors.grayscale.dark1};\n    }\n\n    .cal-heatmap-container rect.highlight-now {\n      stroke: ${theme.colors.error.base};\n    }\n\n    .cal-heatmap-container text.highlight-now {\n      fill: ${theme.colors.error.base};\n      font-weight: ${theme.typography.weights.bold};\n    }\n\n    .cal-heatmap-container .domain-background {\n      fill: none;\n      shape-rendering: crispedges;\n    }\n\n    .ch-tooltip {\n      padding: ${theme.gridUnit * 2}px;\n      background: ${theme.colors.grayscale.dark1};\n      color: ${theme.colors.grayscale.light1};\n      font-size: ${theme.typography.sizes.s}px;\n      line-height: 1.4;\n      width: 140px;\n      position: absolute;\n      z-index: 99999;\n      text-align: center;\n      border-radius: ${theme.borderRadius}px;\n      box-shadow: 2px 2px 2px ${theme.colors.grayscale.dark2};\n      display: none;\n      box-sizing: border-box;\n    }\n\n    .ch-tooltip::after {\n      position: absolute;\n      width: 0;\n      height: 0;\n      border-color: transparent;\n      border-style: solid;\n      content: '';\n      padding: 0;\n      display: block;\n      bottom: -${theme.gridUnit}px;\n      left: 50%;\n      margin-left: -${theme.gridUnit}px;\n      border-width: ${theme.gridUnit}px ${theme.gridUnit}px 0;\n      border-top-color: ${theme.colors.grayscale.dark1};\n    }\n  `;}}\n`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ReactComponent, \"ReactComponent\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx\");reactHotLoader.register(Calendar, \"Calendar\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvc3JjL1JlYWN0Q2FsZW5kYXIuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9zcmMvUmVhY3RDYWxlbmRhci5qc3g/YzgxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHJlYWN0aWZ5LCBzdHlsZWQsIGNzcywgdXNlVGhlbWUgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBHbG9iYWwgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQ2FsZW5kYXInO1xuXG5jb25zdCBSZWFjdENvbXBvbmVudCA9IHJlYWN0aWZ5KENvbXBvbmVudCk7XG5cbmNvbnN0IENhbGVuZGFyID0gKHsgY2xhc3NOYW1lLCAuLi5vdGhlclByb3BzIH0pID0+IHtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgICAgPEdsb2JhbFxuICAgICAgICBzdHlsZXM9e2Nzc2BcbiAgICAgICAgICAuZDMtdGlwIHtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgICAgICAgICAgcGFkZGluZzogJHt0aGVtZS5ncmlkVW5pdCAqIDN9cHg7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazJ9O1xuICAgICAgICAgICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDV9O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgICAgICB6LWluZGV4OiAxMDAwO1xuICAgICAgICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogQ3JlYXRlcyBhIHNtYWxsIHRyaWFuZ2xlIGV4dGVuZGVyIGZvciB0aGUgdG9vbHRpcCAqL1xuICAgICAgICAgIC5kMy10aXA6YWZ0ZXIge1xuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZTtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnhzfTtcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDE7XG4gICAgICAgICAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyfTtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBOb3J0aHdhcmQgdG9vbHRpcHMgKi9cbiAgICAgICAgICAuZDMtdGlwLm46YWZ0ZXIge1xuICAgICAgICAgICAgY29udGVudDogJ1xcXFwyNUJDJztcbiAgICAgICAgICAgIG1hcmdpbjogLSR7dGhlbWUuZ3JpZFVuaXR9cHggMCAwIDA7XG4gICAgICAgICAgICB0b3A6IDEwMCU7XG4gICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBFYXN0d2FyZCB0b29sdGlwcyAqL1xuICAgICAgICAgIC5kMy10aXAuZTphZnRlciB7XG4gICAgICAgICAgICBjb250ZW50OiAnXFxcXDI1QzAnO1xuICAgICAgICAgICAgbWFyZ2luOiAtJHt0aGVtZS5ncmlkVW5pdH1weCAwIDAgMDtcbiAgICAgICAgICAgIHRvcDogNTAlO1xuICAgICAgICAgICAgbGVmdDogLSR7dGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBTb3V0aHdhcmQgdG9vbHRpcHMgKi9cbiAgICAgICAgICAuZDMtdGlwLnM6YWZ0ZXIge1xuICAgICAgICAgICAgY29udGVudDogJ1xcXFwyNUIyJztcbiAgICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICAgIHRvcDogLSR7dGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuICAgICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogV2VzdHdhcmQgdG9vbHRpcHMgKi9cbiAgICAgICAgICAuZDMtdGlwLnc6YWZ0ZXIge1xuICAgICAgICAgICAgY29udGVudDogJ1xcXFwyNUI2JztcbiAgICAgICAgICAgIG1hcmdpbjogLSR7dGhlbWUuZ3JpZFVuaXR9cHggMCAwIDBweDtcbiAgICAgICAgICAgIHRvcDogNTAlO1xuICAgICAgICAgICAgbGVmdDogMTAwJTtcbiAgICAgICAgICB9XG4gICAgICAgIGB9XG4gICAgICAvPlxuICAgICAgPFJlYWN0Q29tcG9uZW50IHsuLi5vdGhlclByb3BzfSB0aGVtZT17dGhlbWV9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5DYWxlbmRhci5kZWZhdWx0UHJvcHMgPSB7XG4gIG90aGVyUHJvcHM6IHt9LFxufTtcblxuQ2FsZW5kYXIucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgb3RoZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5hbnkpLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgc3R5bGVkKENhbGVuZGFyKWBcbiAgJHsoeyB0aGVtZSB9KSA9PiBgXG4gICAgLnN1cGVyc2V0LWxlZ2FjeS1jaGFydC1jYWxlbmRhciB7XG4gICAgICBwYWRkaW5nOiAke3RoZW1lLmdyaWRVbml0ICogM31weDtcbiAgICAgIHBvc2l0aW9uOiBzdGF0aWMgIWltcG9ydGFudDtcbiAgICAgIG92ZXJmbG93OiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLnN1cGVyc2V0LWxlZ2FjeS1jaGFydC1jYWxlbmRhciAuY2gtdG9vbHRpcCB7XG4gICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5ncmlkVW5pdCAqIDV9cHg7XG4gICAgICBtYXJnaW4tdG9wOiAke3RoZW1lLmdyaWRVbml0fXB4O1xuICAgIH1cblxuICAgIC5zdXBlcnNldC1sZWdhY3ktY2hhcnQtY2FsZW5kYXIgLmQzLXRpcCB7XG4gICAgICBsaW5lLWhlaWdodDogMTtcbiAgICAgIHBhZGRpbmc6ICR7dGhlbWUuZ3JpZFVuaXQgKiAzfXB4O1xuICAgICAgYmFja2dyb3VuZDogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyfTtcbiAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1fTtcbiAgICAgIGJvcmRlci1yYWRpdXM6ICR7dGhlbWUuYm9yZGVyUmFkaXVzfXB4O1xuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB6LWluZGV4OiAxMDAwO1xuICAgIH1cblxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIge1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxuXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuZ3JhcGgtbGFiZWwge1xuICAgICAgZmlsbDogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmJhc2V9O1xuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMueHN9cHg7XG4gICAgfVxuXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuZ3JhcGgsXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuZ3JhcGgtbGVnZW5kIHJlY3Qge1xuICAgICAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcGVkZ2VzO1xuICAgIH1cblxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgLmdyYXBoLXJlY3Qge1xuICAgICAgZmlsbDogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0Mn07XG4gICAgfVxuXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuZ3JhcGgtc3ViZG9tYWluLWdyb3VwIHJlY3Q6aG92ZXIge1xuICAgICAgc3Ryb2tlOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazJ9O1xuICAgICAgc3Ryb2tlLXdpZHRoOiAxcHg7XG4gICAgfVxuXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuc3ViZG9tYWluLXRleHQge1xuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMueHN9cHg7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5ob3Zlcl9jdXJzb3I6aG92ZXIge1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cblxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgLnFpIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5iYXNlfTtcbiAgICAgIGZpbGw6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5iYXNlfTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5xMSB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5hbGVydC5saWdodDJ9O1xuICAgICAgZmlsbDogJHt0aGVtZS5jb2xvcnMuYWxlcnQubGlnaHQyfTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5xMiB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5hbGVydC5saWdodDF9O1xuICAgICAgZmlsbDogJHt0aGVtZS5jb2xvcnMuYWxlcnQubGlnaHQxfTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5xMyB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5zdWNjZXNzLmxpZ2h0MX07XG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5zdWNjZXNzLmxpZ2h0MX07XG4gICAgfVxuXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAucTQge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuc3VjY2Vzcy5iYXNlfTtcbiAgICAgIGZpbGw6ICR7dGhlbWUuY29sb3JzLnN1Y2Nlc3MuYmFzZX07XG4gICAgfVxuXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAucTUge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuc3VjY2Vzcy5kYXJrMX07XG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5zdWNjZXNzLmRhcmsxfTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIHJlY3QuaGlnaGxpZ2h0IHtcbiAgICAgIHN0cm9rZTogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsxfTtcbiAgICAgIHN0cm9rZS13aWR0aDogMTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIHRleHQuaGlnaGxpZ2h0IHtcbiAgICAgIGZpbGw6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMX07XG4gICAgfVxuXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciByZWN0LmhpZ2hsaWdodC1ub3cge1xuICAgICAgc3Ryb2tlOiAke3RoZW1lLmNvbG9ycy5lcnJvci5iYXNlfTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIHRleHQuaGlnaGxpZ2h0LW5vdyB7XG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5lcnJvci5iYXNlfTtcbiAgICAgIGZvbnQtd2VpZ2h0OiAke3RoZW1lLnR5cG9ncmFwaHkud2VpZ2h0cy5ib2xkfTtcbiAgICB9XG5cbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5kb21haW4tYmFja2dyb3VuZCB7XG4gICAgICBmaWxsOiBub25lO1xuICAgICAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcGVkZ2VzO1xuICAgIH1cblxuICAgIC5jaC10b29sdGlwIHtcbiAgICAgIHBhZGRpbmc6ICR7dGhlbWUuZ3JpZFVuaXQgKiAyfXB4O1xuICAgICAgYmFja2dyb3VuZDogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsxfTtcbiAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQxfTtcbiAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XG4gICAgICBsaW5lLWhlaWdodDogMS40O1xuICAgICAgd2lkdGg6IDE0MHB4O1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgei1pbmRleDogOTk5OTk7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBib3JkZXItcmFkaXVzOiAke3RoZW1lLmJvcmRlclJhZGl1c31weDtcbiAgICAgIGJveC1zaGFkb3c6IDJweCAycHggMnB4ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMn07XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG5cbiAgICAuY2gtdG9vbHRpcDo6YWZ0ZXIge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgd2lkdGg6IDA7XG4gICAgICBoZWlnaHQ6IDA7XG4gICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgcGFkZGluZzogMDtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgYm90dG9tOiAtJHt0aGVtZS5ncmlkVW5pdH1weDtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIG1hcmdpbi1sZWZ0OiAtJHt0aGVtZS5ncmlkVW5pdH1weDtcbiAgICAgIGJvcmRlci13aWR0aDogJHt0aGVtZS5ncmlkVW5pdH1weCAke3RoZW1lLmdyaWRVbml0fXB4IDA7XG4gICAgICBib3JkZXItdG9wLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazF9O1xuICAgIH1cbiAgYH1cbmA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js":
/*!************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var d3_tip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-tip */ \"./node_modules/d3-tip/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/translation/TranslatorSingleton.ts\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/utils.ts\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; // [LICENSE TBD]\n/* Copied and altered from http://cal-heatmap.com/ , alterations around:\n * - tuning tooltips\n * - supporting multi-colors scales\n * - legend format\n * - UTC handling\n */\n\n/* eslint-disable */\n\n\n\n\nvar d3 =  true ? __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\") : 0;\n\nvar d3 =  true ? __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\") : 0;\n\nvar CalHeatMap = function () {\n  'use strict';\n\n  var self = this;\n  self.tip = (0,d3_tip__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().\n  attr('class', 'd3-tip').\n  direction('n').\n  offset([-5, 0]).\n  html(\n    (d) => `\n      ${self.options.timeFormatter(d.t)}: <strong>${self.options.valueFormatter(\n      d.v\n    )}</strong>\n    `\n  );\n  self.legendTip = (0,d3_tip__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().\n  attr('class', 'd3-tip').\n  direction('n').\n  offset([-5, 0]).\n  html((d) => self.options.valueFormatter(d));\n\n  this.allowedDataType = ['json', 'csv', 'tsv', 'txt'];\n\n  // Default settings\n  this.options = {\n    // selector string of the container to append the graph to\n    // Accept any string value accepted by document.querySelector or CSS3\n    // or an Element object\n    itemSelector: '#cal-heatmap',\n\n    // Whether to paint the calendar on init()\n    // Used by testsuite to reduce testing time\n    paintOnLoad: true,\n\n    // ================================================\n    // DOMAIN\n    // ================================================\n\n    // Number of domain to display on the graph\n    range: 12,\n\n    // Size of each cell, in pixel\n    cellSize: 10,\n\n    // Padding between each cell, in pixel\n    cellPadding: 2,\n\n    // For rounded subdomain rectangles, in pixels\n    cellRadius: 0,\n\n    domainGutter: 2,\n\n    domainMargin: [0, 0, 0, 0],\n\n    valueFormatter: (d) => d,\n\n    timeFormatter: (d) => d,\n\n    domain: 'hour',\n\n    subDomain: 'min',\n\n    // Number of columns to split the subDomains to\n    // If not null, will takes precedence over rowLimit\n    colLimit: null,\n\n    // Number of rows to split the subDomains to\n    // Will be ignored if colLimit is not null\n    rowLimit: null,\n\n    // First day of the week is Monday\n    // 0 to start the week on Sunday\n    weekStartOnMonday: true,\n\n    // Start date of the graph\n    // @default now\n    start: new Date(),\n\n    minDate: null,\n\n    maxDate: null,\n\n    // ================================================\n    // DATA\n    // ================================================\n\n    // Data source\n    // URL, where to fetch the original datas\n    data: '',\n\n    // Data type\n    // Default: json\n    dataType: this.allowedDataType[0],\n\n    // Payload sent when using POST http method\n    // Leave to null (default) for GET request\n    // Expect a string, formatted like \"a=b;c=d\"\n    dataPostPayload: null,\n\n    // Additional headers sent when requesting data\n    // Expect an object formatted like:\n    // { 'X-CSRF-TOKEN': 'token' }\n    dataRequestHeaders: null,\n\n    // Whether to consider missing date:value from the datasource\n    // as equal to 0, or just leave them as missing\n    considerMissingDataAsZero: false,\n\n    // Load remote data on calendar creation\n    // When false, the calendar will be left empty\n    loadOnInit: true,\n\n    // Calendar orientation\n    // false: display domains side by side\n    // true : display domains one under the other\n    verticalOrientation: false,\n\n    // Domain dynamic width/height\n    // The width on a domain depends on the number of\n    domainDynamicDimension: true,\n\n    // Domain Label properties\n    label: {\n      // valid: top, right, bottom, left\n      position: 'bottom',\n\n      // Valid: left, center, right\n      // Also valid are the direct svg values: start, middle, end\n      align: 'center',\n\n      // By default, there is no margin/padding around the label\n      offset: {\n        x: 0,\n        y: 0\n      },\n\n      rotate: null,\n\n      // Used only on vertical orientation\n      width: 100,\n\n      // Used only on horizontal orientation\n      height: null\n    },\n\n    // ================================================\n    // LEGEND\n    // ================================================\n\n    // Threshold for the legend\n    legend: [10, 20, 30, 40],\n\n    // Whether to display the legend\n    displayLegend: true,\n\n    legendCellSize: 10,\n\n    legendCellPadding: 2,\n\n    legendMargin: [0, 0, 0, 0],\n\n    // Legend vertical position\n    // top: place legend above calendar\n    // bottom: place legend below the calendar\n    legendVerticalPosition: 'bottom',\n\n    // Legend horizontal position\n    // accepted values: left, center, right\n    legendHorizontalPosition: 'left',\n\n    // Legend rotation\n    // accepted values: horizontal, vertical\n    legendOrientation: 'horizontal',\n\n    // Objects holding all the heatmap different colors\n    // null to disable, and use the default css styles\n    //\n    // Examples:\n    // legendColors: {\n    //    min: \"green\",\n    //    max: \"red\",\n    //    empty: \"#ffffff\",\n    //    base: \"grey\",\n    //    overflow: \"red\",\n    //    colorScaler: null,\n    // }\n    legendColors: null,\n\n    // ================================================\n    // HIGHLIGHT\n    // ================================================\n\n    // List of dates to highlight\n    // Valid values:\n    // - []: don't highlight anything\n    // - \"now\": highlight the current date\n    // - an array of Date objects: highlight the specified dates\n    highlight: [],\n\n    // ================================================\n    // TEXT FORMATTING / i18n\n    // ================================================\n\n    // Name of the items to represent in the calendar\n    itemName: ['item', 'items'],\n\n    // Formatting of the domain label\n    // @default: null, will use the formatting according to domain type\n    // Accept a string used as specifier by d3.time.format()\n    // or a function\n    //\n    // Refer to https://github.com/mbostock/d3/wiki/Time-Formatting\n    // for accepted date formatting used by d3.time.format()\n    domainLabelFormat: null,\n\n    // Formatting of the title displayed when hovering a subDomain cell\n    subDomainTitleFormat: {\n      empty: '{date}',\n      filled: '{count} {name} {connector} {date}'\n    },\n\n    // Formatting of the {date} used in subDomainTitleFormat\n    // @default: null, will use the formatting according to subDomain type\n    // Accept a string used as specifier by d3.time.format()\n    // or a function\n    //\n    // Refer to https://github.com/mbostock/d3/wiki/Time-Formatting\n    // for accepted date formatting used by d3.time.format()\n    subDomainDateFormat: null,\n\n    // Formatting of the text inside each subDomain cell\n    // @default: null, no text\n    // Accept a string used as specifier by d3.time.format()\n    // or a function\n    //\n    // Refer to https://github.com/mbostock/d3/wiki/Time-Formatting\n    // for accepted date formatting used by d3.time.format()\n    subDomainTextFormat: null,\n\n    // Formatting of the title displayed when hovering a legend cell\n    legendTitleFormat: {\n      lower: (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__.t)('less than {min} {name}'),\n      inner: (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__.t)('between {down} and {up} {name}'),\n      upper: (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__.t)('more than {max} {name}')\n    },\n\n    // Animation duration, in ms\n    animationDuration: 500,\n\n    nextSelector: false,\n\n    previousSelector: false,\n\n    itemNamespace: 'cal-heatmap',\n\n    tooltip: false,\n\n    // ================================================\n    // EVENTS CALLBACK\n    // ================================================\n\n    // Callback when clicking on a time block\n    onClick: null,\n\n    // Callback after painting the empty calendar\n    // Can be used to trigger an API call, once the calendar is ready to be filled\n    afterLoad: null,\n\n    // Callback after loading the next domain in the calendar\n    afterLoadNextDomain: null,\n\n    // Callback after loading the previous domain in the calendar\n    afterLoadPreviousDomain: null,\n\n    // Callback after finishing all actions on the calendar\n    onComplete: null,\n\n    // Callback after fetching the datas, but before applying them to the calendar\n    // Used mainly to convert the datas if they're not formatted like expected\n    // Takes the fetched \"data\" object as argument, must return a json object\n    // formatted like {timestamp:count, timestamp2:count2},\n    afterLoadData: function (timestamps) {\n      // See https://github.com/wa0x6e/cal-heatmap/issues/126#issuecomment-373301803\n      const stdTimezoneOffset = (date) => {\n        const jan = new Date(date.getFullYear(), 0, 1);\n        const jul = new Date(date.getFullYear(), 6, 1);\n        return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n      };\n      const offset = stdTimezoneOffset(new Date()) * 60;\n      let results = {};\n      for (let timestamp in timestamps) {\n        const value = timestamps[timestamp];\n        timestamp = parseInt(timestamp, 10);\n        results[timestamp + offset] = value;\n      }\n      return results;\n    },\n\n    // Callback triggered after calling and completing update().\n    afterUpdate: null,\n\n    // Callback triggered after calling next().\n    // The `status` argument is equal to true if there is no\n    // more next domain to load\n    //\n    // This callback is also executed once, after calling previous(),\n    // only when the max domain is reached\n    onMaxDomainReached: null,\n\n    // Callback triggered after calling previous().\n    // The `status` argument is equal to true if there is no\n    // more previous domain to load\n    //\n    // This callback is also executed once, after calling next(),\n    // only when the min domain is reached\n    onMinDomainReached: null\n  };\n\n  this._domainType = {\n    min: {\n      name: 'minute',\n      level: 10,\n      maxItemNumber: 60,\n      defaultRowNumber: 10,\n      defaultColumnNumber: 6,\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          return Math.floor(d.getMinutes() / self._domainType.min.row(d));\n        },\n        y: function (d) {\n          return d.getMinutes() % self._domainType.min.row(d);\n        }\n      },\n      format: {\n        date: '%H:%M, %A %B %-e, %Y',\n        legend: '',\n        connector: 'at'\n      },\n      extractUnit: function (d) {\n        return new Date(\n          d.getFullYear(),\n          d.getMonth(),\n          d.getDate(),\n          d.getHours(),\n          d.getMinutes()\n        ).getTime();\n      }\n    },\n    hour: {\n      name: 'hour',\n      level: 20,\n      maxItemNumber: function (d) {\n        switch (self.options.domain) {\n          case 'day':\n            return 24;\n          case 'week':\n            return 24 * 7;\n          case 'month':\n            return (\n              24 * (\n              self.options.domainDynamicDimension ?\n              self.getDayCountInMonth(d) :\n              31));\n\n        }\n      },\n      defaultRowNumber: 6,\n      defaultColumnNumber: function (d) {\n        switch (self.options.domain) {\n          case 'day':\n            return 4;\n          case 'week':\n            return 28;\n          case 'month':\n            return self.options.domainDynamicDimension ?\n            self.getDayCountInMonth(d) :\n            31;\n        }\n      },\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          if (self.options.domain === 'month') {\n            if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n              return Math.floor(\n                (d.getHours() + (d.getDate() - 1) * 24) /\n                self._domainType.hour.row(d)\n              );\n            }\n            return (\n              Math.floor(d.getHours() / self._domainType.hour.row(d)) +\n              (d.getDate() - 1) * 4);\n\n          } else if (self.options.domain === 'week') {\n            if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n              return Math.floor(\n                (d.getHours() + self.getWeekDay(d) * 24) /\n                self._domainType.hour.row(d)\n              );\n            }\n            return (\n              Math.floor(d.getHours() / self._domainType.hour.row(d)) +\n              self.getWeekDay(d) * 4);\n\n          }\n          return Math.floor(d.getHours() / self._domainType.hour.row(d));\n        },\n        y: function (d) {\n          var p = d.getHours();\n          if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n            switch (self.options.domain) {\n              case 'month':\n                p += (d.getDate() - 1) * 24;\n                break;\n              case 'week':\n                p += self.getWeekDay(d) * 24;\n                break;\n            }\n          }\n          return Math.floor(p % self._domainType.hour.row(d));\n        }\n      },\n      format: {\n        date: '%Hh, %A %B %-e, %Y',\n        legend: '%H:00',\n        connector: 'at'\n      },\n      extractUnit: function (d) {\n        return new Date(\n          d.getFullYear(),\n          d.getMonth(),\n          d.getDate(),\n          d.getHours()\n        ).getTime();\n      }\n    },\n    day: {\n      name: 'day',\n      level: 30,\n      maxItemNumber: function (d) {\n        switch (self.options.domain) {\n          case 'week':\n            return 7;\n          case 'month':\n            return self.options.domainDynamicDimension ?\n            self.getDayCountInMonth(d) :\n            31;\n          case 'year':\n            return self.options.domainDynamicDimension ?\n            self.getDayCountInYear(d) :\n            366;\n        }\n      },\n      defaultColumnNumber: function (d) {\n        d = new Date(d);\n        switch (self.options.domain) {\n          case 'week':\n            return 1;\n          case 'month':\n            return self.options.domainDynamicDimension &&\n            !self.options.verticalOrientation ?\n            self.getWeekNumber(\n              new Date(d.getFullYear(), d.getMonth() + 1, 0)\n            ) -\n            self.getWeekNumber(d) +\n            1 :\n            6;\n          case 'year':\n            return self.options.domainDynamicDimension ?\n            self.getWeekNumber(new Date(d.getFullYear(), 11, 31)) -\n            self.getWeekNumber(new Date(d.getFullYear(), 0)) +\n            1 :\n            54;\n        }\n      },\n      defaultRowNumber: 7,\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          switch (self.options.domain) {\n            case 'week':\n              return Math.floor(\n                self.getWeekDay(d) / self._domainType.day.row(d)\n              );\n            case 'month':\n              if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n                return Math.floor(\n                  (d.getDate() - 1) / self._domainType.day.row(d)\n                );\n              }\n              return (\n                self.getWeekNumber(d) -\n                self.getWeekNumber(new Date(d.getFullYear(), d.getMonth())));\n\n            case 'year':\n              if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n                return Math.floor(\n                  (self.getDayOfYear(d) - 1) / self._domainType.day.row(d)\n                );\n              }\n              return self.getWeekNumber(d);\n          }\n        },\n        y: function (d) {\n          var p = self.getWeekDay(d);\n          if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n            switch (self.options.domain) {\n              case 'year':\n                p = self.getDayOfYear(d) - 1;\n                break;\n              case 'week':\n                p = self.getWeekDay(d);\n                break;\n              case 'month':\n                p = d.getDate() - 1;\n                break;\n            }\n          }\n          return Math.floor(p % self._domainType.day.row(d));\n        }\n      },\n      format: {\n        date: '%A %B %-e, %Y',\n        legend: '%e %b',\n        connector: 'on'\n      },\n      extractUnit: function (d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();\n      }\n    },\n    week: {\n      name: 'week',\n      level: 40,\n      maxItemNumber: 54,\n      defaultColumnNumber: function (d) {\n        d = new Date(d);\n        switch (self.options.domain) {\n          case 'year':\n            return self._domainType.week.maxItemNumber;\n          case 'month':\n            return self.options.domainDynamicDimension ?\n            self.getWeekNumber(\n              new Date(d.getFullYear(), d.getMonth() + 1, 0)\n            ) - self.getWeekNumber(d) :\n            5;\n        }\n      },\n      defaultRowNumber: 1,\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          switch (self.options.domain) {\n            case 'year':\n              return Math.floor(\n                self.getWeekNumber(d) / self._domainType.week.row(d)\n              );\n            case 'month':\n              return Math.floor(\n                self.getMonthWeekNumber(d) / self._domainType.week.row(d)\n              );\n          }\n        },\n        y: function (d) {\n          return self.getWeekNumber(d) % self._domainType.week.row(d);\n        }\n      },\n      format: {\n        date: '%B Week #%W',\n        legend: '%B Week #%W',\n        connector: 'in'\n      },\n      extractUnit: function (d) {\n        var dt = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n        // According to ISO-8601, week number computation are based on week starting on Monday\n        var weekDay = dt.getDay() - (self.options.weekStartOnMonday ? 1 : 0);\n        if (weekDay < 0) {\n          weekDay = 6;\n        }\n        dt.setDate(dt.getDate() - weekDay);\n        return dt.getTime();\n      }\n    },\n    month: {\n      name: 'month',\n      level: 50,\n      maxItemNumber: 12,\n      defaultColumnNumber: 12,\n      defaultRowNumber: 1,\n      row: function () {\n        return self.getSubDomainRowNumber();\n      },\n      column: function () {\n        return self.getSubDomainColumnNumber();\n      },\n      position: {\n        x: function (d) {\n          return Math.floor(d.getMonth() / self._domainType.month.row(d));\n        },\n        y: function (d) {\n          return d.getMonth() % self._domainType.month.row(d);\n        }\n      },\n      format: {\n        date: '%B %Y',\n        legend: '%B',\n        connector: 'in'\n      },\n      extractUnit: function (d) {\n        return new Date(d.getFullYear(), d.getMonth()).getTime();\n      }\n    },\n    year: {\n      name: 'year',\n      level: 60,\n      row: function () {\n        return self.options.rowLimit || 1;\n      },\n      column: function () {\n        return self.options.colLimit || 1;\n      },\n      position: {\n        x: function () {\n          return 1;\n        },\n        y: function () {\n          return 1;\n        }\n      },\n      format: {\n        date: '%Y',\n        legend: '%Y',\n        connector: 'in'\n      },\n      extractUnit: function (d) {\n        return new Date(d.getFullYear()).getTime();\n      }\n    }\n  };\n\n  for (var type in this._domainType) {\n    if (this._domainType.hasOwnProperty(type)) {\n      var d = this._domainType[type];\n      this._domainType['x_' + type] = {\n        name: 'x_' + type,\n        level: d.type,\n        maxItemNumber: d.maxItemNumber,\n        defaultRowNumber: d.defaultRowNumber,\n        defaultColumnNumber: d.defaultColumnNumber,\n        row: d.column,\n        column: d.row,\n        position: {\n          x: d.position.y,\n          y: d.position.x\n        },\n        format: d.format,\n        extractUnit: d.extractUnit\n      };\n    }\n  }\n\n  // Record the address of the last inserted domain when browsing\n  this.lastInsertedSvg = null;\n\n  this._completed = false;\n\n  // Record all the valid domains\n  // Each domain value is a timestamp in milliseconds\n  this._domains = d3.map();\n\n  this.graphDim = {\n    width: 0,\n    height: 0\n  };\n\n  this.legendDim = {\n    width: 0,\n    height: 0\n  };\n\n  this.NAVIGATE_LEFT = 1;\n  this.NAVIGATE_RIGHT = 2;\n\n  // Various update mode when using the update() API\n  this.RESET_ALL_ON_UPDATE = 0;\n  this.RESET_SINGLE_ON_UPDATE = 1;\n  this.APPEND_ON_UPDATE = 2;\n\n  this.DEFAULT_LEGEND_MARGIN = 10;\n\n  this.root = null;\n  this.tooltip = null;\n\n  this._maxDomainReached = false;\n  this._minDomainReached = false;\n\n  this.domainPosition = new DomainPosition();\n  this.Legend = null;\n  this.legendScale = null;\n\n  // List of domains that are skipped because of DST\n  // All times belonging to these domains should be re-assigned to the previous domain\n  this.DSTDomain = [];\n\n  /**\n   * Display the graph for the first time\n   * @return bool True if the calendar is created\n   */\n  this._init = function () {\n    self.\n    getDomain(self.options.start).\n    map(function (d) {\n      return d.getTime();\n    }).\n    map(function (d) {\n      self._domains.set(\n        d,\n        self.getSubDomain(d).map(function (d) {\n          return {\n            t: self._domainType[self.options.subDomain].extractUnit(d),\n            v: null\n          };\n        })\n      );\n    });\n\n    self.root = d3.\n    select(self.options.itemSelector).\n    append('svg').\n    attr('class', 'cal-heatmap-container');\n\n    self.root.attr('x', 0).attr('y', 0).append('svg').attr('class', 'graph');\n\n    self.Legend = new Legend(self);\n\n    if (self.options.paintOnLoad) {\n      _initCalendar();\n    }\n    self.root.call(self.tip);\n    self.root.call(self.legendTip);\n\n    return true;\n  };\n\n  function _initCalendar() {\n    self.verticalDomainLabel =\n    self.options.label.position === 'top' ||\n    self.options.label.position === 'bottom';\n\n    self.domainVerticalLabelHeight =\n    self.options.label.height === null ?\n    Math.max(25, self.options.cellSize * 2) :\n    self.options.label.height;\n    self.domainHorizontalLabelWidth = 0;\n\n    if (\n    self.options.domainLabelFormat === '' &&\n    self.options.label.height === null)\n    {\n      self.domainVerticalLabelHeight = 0;\n    }\n\n    if (!self.verticalDomainLabel) {\n      self.domainVerticalLabelHeight = 0;\n      self.domainHorizontalLabelWidth = self.options.label.width;\n    }\n\n    self.paint();\n\n    // =========================================================================//\n    // ATTACHING DOMAIN NAVIGATION EVENT                    //\n    // =========================================================================//\n    if (self.options.nextSelector !== false) {\n      d3.select(self.options.nextSelector).on(\n        'click.' + self.options.itemNamespace,\n        function () {\n          d3.event.preventDefault();\n          return self.loadNextDomain(1);\n        }\n      );\n    }\n\n    if (self.options.previousSelector !== false) {\n      d3.select(self.options.previousSelector).on(\n        'click.' + self.options.itemNamespace,\n        function () {\n          d3.event.preventDefault();\n          return self.loadPreviousDomain(1);\n        }\n      );\n    }\n\n    self.Legend.redraw(\n      self.graphDim.width -\n      self.options.domainGutter -\n      self.options.cellPadding\n    );\n    self.afterLoad();\n\n    var domains = self.getDomainKeys();\n\n    // Fill the graph with some datas\n    if (self.options.loadOnInit) {\n      self.getDatas(\n        self.options.data,\n        new Date(domains[0]),\n        self.getSubDomain(domains[domains.length - 1]).pop(),\n        function () {\n          self.fill();\n          self.onComplete();\n        }\n      );\n    } else {\n      self.onComplete();\n    }\n\n    self.checkIfMinDomainIsReached(domains[0]);\n    self.checkIfMaxDomainIsReached(self.getNextDomain().getTime());\n  }\n\n  // Return the width of the domain block, without the domain gutter\n  // @param int d Domain start timestamp\n  function w(d, outer) {\n    var width =\n    self.options.cellSize *\n    self._domainType[self.options.subDomain].column(d) +\n    self.options.cellPadding *\n    self._domainType[self.options.subDomain].column(d);\n    if (arguments.length === 2 && outer === true) {\n      return width +=\n      self.domainHorizontalLabelWidth +\n      self.options.domainGutter +\n      self.options.domainMargin[1] +\n      self.options.domainMargin[3];\n    }\n    return width;\n  }\n\n  // Return the height of the domain block, without the domain gutter\n  function h(d, outer) {\n    var height =\n    self.options.cellSize * self._domainType[self.options.subDomain].row(d) +\n    self.options.cellPadding *\n    self._domainType[self.options.subDomain].row(d);\n    if (arguments.length === 2 && outer === true) {\n      height +=\n      self.options.domainGutter +\n      self.domainVerticalLabelHeight +\n      self.options.domainMargin[0] +\n      self.options.domainMargin[2];\n    }\n    return height;\n  }\n\n  /**\n   *\n   *\n   * @param int navigationDir\n   */\n  this.paint = function (navigationDir) {\n    var options = self.options;\n\n    if (arguments.length === 0) {\n      navigationDir = false;\n    }\n\n    // Painting all the domains\n    var domainSvg = self.root.\n    select('.graph').\n    selectAll('.graph-domain').\n    data(\n      function () {\n        var data = self.getDomainKeys();\n        return navigationDir === self.NAVIGATE_LEFT ? data.reverse() : data;\n      },\n      function (d) {\n        return d;\n      }\n    );\n    var enteringDomainDim = 0;\n    var exitingDomainDim = 0;\n\n    // =========================================================================//\n    // PAINTING DOMAIN                              //\n    // =========================================================================//\n\n    var svg = domainSvg.\n    enter().\n    append('svg').\n    attr('width', function (d) {\n      return w(d, true);\n    }).\n    attr('height', function (d) {\n      return h(d, true);\n    }).\n    attr('x', function (d) {\n      if (options.verticalOrientation) {\n        self.graphDim.width = Math.max(self.graphDim.width, w(d, true));\n        return 0;\n      } else {\n        return getDomainPosition(d, self.graphDim, 'width', w(d, true));\n      }\n    }).\n    attr('y', function (d) {\n      if (options.verticalOrientation) {\n        return getDomainPosition(d, self.graphDim, 'height', h(d, true));\n      } else {\n        self.graphDim.height = Math.max(self.graphDim.height, h(d, true));\n        return 0;\n      }\n    }).\n    attr('class', function (d) {\n      var classname = 'graph-domain';\n      var date = new Date(d);\n      switch (options.domain) {\n        case 'hour':\n          classname += ' h_' + date.getHours();\n        /* falls through */\n        case 'day':\n          classname += ' d_' + date.getDate() + ' dy_' + date.getDay();\n        /* falls through */\n        case 'week':\n          classname += ' w_' + self.getWeekNumber(date);\n        /* falls through */\n        case 'month':\n          classname += ' m_' + (date.getMonth() + 1);\n        /* falls through */\n        case 'year':\n          classname += ' y_' + date.getFullYear();\n      }\n      return classname;\n    });\n    self.lastInsertedSvg = svg;\n\n    function getDomainPosition(domainIndex, graphDim, axis, domainDim) {\n      var tmp = 0;\n      switch (navigationDir) {\n        case false:\n          tmp = graphDim[axis];\n\n          graphDim[axis] += domainDim;\n          self.domainPosition.setPosition(domainIndex, tmp);\n          return tmp;\n\n        case self.NAVIGATE_RIGHT:\n          self.domainPosition.setPosition(domainIndex, graphDim[axis]);\n\n          enteringDomainDim = domainDim;\n          exitingDomainDim = self.domainPosition.getPositionFromIndex(1);\n\n          self.domainPosition.shiftRightBy(exitingDomainDim);\n          return graphDim[axis];\n\n        case self.NAVIGATE_LEFT:\n          tmp = -domainDim;\n\n          enteringDomainDim = -tmp;\n          exitingDomainDim = graphDim[axis] - self.domainPosition.getLast();\n\n          self.domainPosition.setPosition(domainIndex, tmp);\n          self.domainPosition.shiftLeftBy(enteringDomainDim);\n          return tmp;\n      }\n    }\n\n    svg.\n    append('rect').\n    attr('width', function (d) {\n      return w(d, true) - options.domainGutter - options.cellPadding;\n    }).\n    attr('height', function (d) {\n      return h(d, true) - options.domainGutter - options.cellPadding;\n    }).\n    attr('class', 'domain-background');\n\n    // =========================================================================//\n    // PAINTING SUBDOMAINS                            //\n    // =========================================================================//\n    var subDomainSvgGroup = svg.\n    append('svg').\n    attr('x', function () {\n      if (options.label.position === 'left') {\n        return self.domainHorizontalLabelWidth + options.domainMargin[3];\n      } else {\n        return options.domainMargin[3];\n      }\n    }).\n    attr('y', function () {\n      if (options.label.position === 'top') {\n        return self.domainVerticalLabelHeight + options.domainMargin[0];\n      } else {\n        return options.domainMargin[0];\n      }\n    }).\n    attr('class', 'graph-subdomain-group');\n    var rect = subDomainSvgGroup.\n    selectAll('g').\n    data(function (d) {\n      return self._domains.get(d);\n    }).\n    enter().\n    append('g');\n    rect.\n    append('rect').\n    attr('class', function (d) {\n      return (\n        'graph-rect' +\n        self.getHighlightClassName(d.t) + (\n        options.onClick !== null ? ' hover_cursor' : ''));\n\n    }).\n    attr('width', options.cellSize).\n    attr('height', options.cellSize).\n    attr('x', function (d) {\n      return self.positionSubDomainX(d.t);\n    }).\n    attr('y', function (d) {\n      return self.positionSubDomainY(d.t);\n    }).\n    on('click', function (d) {\n      if (options.onClick !== null) {\n        return self.onClick(new Date(d.t), d.v);\n      }\n    }).\n    call(function (selection) {\n      if (options.cellRadius > 0) {\n        selection.\n        attr('rx', options.cellRadius).\n        attr('ry', options.cellRadius);\n      }\n\n      if (\n      self.legendScale !== null &&\n      options.legendColors !== null &&\n      options.legendColors.hasOwnProperty('base'))\n      {\n        selection.attr('fill', options.legendColors.base);\n      }\n\n      if (options.tooltip) {\n        selection.\n        on('mouseover', function (d) {\n          self.tip.show(d, this);\n        }).\n        on('mouseout', function () {\n          self.tip.hide(d);\n        });\n      }\n    });\n\n    // Appending a title to each subdomain\n    if (!options.tooltip) {\n      rect.append('title').text(function (d) {\n        return self.formatDate(new Date(d.t), options.subDomainDateFormat);\n      });\n    }\n\n    // =========================================================================//\n    // PAINTING LABEL                              //\n    // =========================================================================//\n    if (options.domainLabelFormat !== '') {\n      svg.\n      append('text').\n      attr('class', 'graph-label').\n      attr('y', function (d) {\n        var y = options.domainMargin[0];\n        switch (options.label.position) {\n          case 'top':\n            y += self.domainVerticalLabelHeight / 2;\n            break;\n          case 'bottom':\n            y += h(d) + self.domainVerticalLabelHeight / 2;\n        }\n\n        return (\n          y +\n          options.label.offset.y * (\n          options.label.rotate === 'right' &&\n          options.label.position === 'right' ||\n          options.label.rotate === 'left' &&\n          options.label.position === 'left' ?\n          -1 :\n          1));\n\n      }).\n      attr('x', function (d) {\n        var x = options.domainMargin[3];\n        switch (options.label.position) {\n          case 'right':\n            x += w(d);\n            break;\n          case 'bottom':\n          case 'top':\n            x += w(d) / 2;\n        }\n\n        if (options.label.align === 'right') {\n          return (\n            x +\n            self.domainHorizontalLabelWidth -\n            options.label.offset.x * (\n            options.label.rotate === 'right' ? -1 : 1));\n\n        }\n        return x + options.label.offset.x;\n      }).\n      attr('text-anchor', function () {\n        switch (options.label.align) {\n          case 'start':\n          case 'left':\n            return 'start';\n          case 'end':\n          case 'right':\n            return 'end';\n          default:\n            return 'middle';\n        }\n      }).\n      attr('dominant-baseline', function () {\n        return self.verticalDomainLabel ? 'middle' : 'top';\n      }).\n      text(function (d) {\n        return self.formatDate(new Date(d), options.domainLabelFormat);\n      }).\n      call(domainRotate);\n    }\n\n    function domainRotate(selection) {\n      switch (options.label.rotate) {\n        case 'right':\n          selection.attr('transform', function (d) {\n            var s = 'rotate(90), ';\n            switch (options.label.position) {\n              case 'right':\n                s += 'translate(-' + w(d) + ' , -' + w(d) + ')';\n                break;\n              case 'left':\n                s += 'translate(0, -' + self.domainHorizontalLabelWidth + ')';\n                break;\n            }\n\n            return s;\n          });\n          break;\n        case 'left':\n          selection.attr('transform', function (d) {\n            var s = 'rotate(270), ';\n            switch (options.label.position) {\n              case 'right':\n                s +=\n                'translate(-' + (\n                w(d) + self.domainHorizontalLabelWidth) +\n                ' , ' +\n                w(d) +\n                ')';\n                break;\n              case 'left':\n                s +=\n                'translate(-' +\n                self.domainHorizontalLabelWidth +\n                ' , ' +\n                self.domainHorizontalLabelWidth +\n                ')';\n                break;\n            }\n\n            return s;\n          });\n          break;\n      }\n    }\n\n    // =========================================================================//\n    // PAINTING DOMAIN SUBDOMAIN CONTENT                    //\n    // =========================================================================//\n    if (options.subDomainTextFormat !== null) {\n      rect.\n      append('text').\n      attr('class', function (d) {\n        return 'subdomain-text' + self.getHighlightClassName(d.t);\n      }).\n      attr('x', function (d) {\n        return self.positionSubDomainX(d.t) + options.cellSize / 2;\n      }).\n      attr('y', function (d) {\n        return self.positionSubDomainY(d.t) + options.cellSize / 2;\n      }).\n      attr('text-anchor', 'middle').\n      attr('dominant-baseline', 'central').\n      text(function (d) {\n        return self.formatDate(new Date(d.t), options.subDomainTextFormat);\n      });\n    }\n\n    // =========================================================================//\n    // ANIMATION                                //\n    // =========================================================================//\n\n    if (navigationDir !== false) {\n      domainSvg.\n      transition().\n      duration(options.animationDuration).\n      attr('x', function (d) {\n        return options.verticalOrientation ?\n        0 :\n        self.domainPosition.getPosition(d);\n      }).\n      attr('y', function (d) {\n        return options.verticalOrientation ?\n        self.domainPosition.getPosition(d) :\n        0;\n      });\n    }\n\n    var tempWidth = self.graphDim.width;\n    var tempHeight = self.graphDim.height;\n\n    if (options.verticalOrientation) {\n      self.graphDim.height += enteringDomainDim - exitingDomainDim;\n    } else {\n      self.graphDim.width += enteringDomainDim - exitingDomainDim;\n    }\n\n    // At the time of exit, domainsWidth and domainsHeight already automatically shifted\n    domainSvg.\n    exit().\n    transition().\n    duration(options.animationDuration).\n    attr('x', function (d) {\n      if (options.verticalOrientation) {\n        return 0;\n      } else {\n        switch (navigationDir) {\n          case self.NAVIGATE_LEFT:\n            return Math.min(self.graphDim.width, tempWidth);\n          case self.NAVIGATE_RIGHT:\n            return -w(d, true);\n        }\n      }\n    }).\n    attr('y', function (d) {\n      if (options.verticalOrientation) {\n        switch (navigationDir) {\n          case self.NAVIGATE_LEFT:\n            return Math.min(self.graphDim.height, tempHeight);\n          case self.NAVIGATE_RIGHT:\n            return -h(d, true);\n        }\n      } else {\n        return 0;\n      }\n    }).\n    remove();\n\n    // Resize the root container\n    self.resize();\n  };\n};\n\nCalHeatMap.prototype = {\n  /**\n   * Validate and merge user settings with default settings\n   *\n   * @param  {object} settings User settings\n   * @return {bool} False if settings contains error\n   */\n  /* jshint maxstatements:false */\n  init: function (settings) {\n    'use strict';\n\n    var parent = this;\n\n    var options = parent.options = mergeRecursive(parent.options, settings);\n\n    // Fatal errors\n    // Stop script execution on error\n    validateDomainType();\n    validateSelector(options.itemSelector, false, 'itemSelector');\n\n    if (parent.allowedDataType.indexOf(options.dataType) === -1) {\n      throw new Error(\n        \"The data type '\" + options.dataType + \"' is not valid data type\"\n      );\n    }\n\n    if (d3.select(options.itemSelector)[0][0] === null) {\n      throw new Error(\n        \"The node '\" +\n        options.itemSelector +\n        \"' specified in itemSelector does not exists\"\n      );\n    }\n\n    try {\n      validateSelector(options.nextSelector, true, 'nextSelector');\n      validateSelector(options.previousSelector, true, 'previousSelector');\n    } catch (error) {\n      console.log(error.message);\n      return false;\n    }\n\n    // If other settings contains error, will fallback to default\n\n    if (!settings.hasOwnProperty('subDomain')) {\n      this.options.subDomain = getOptimalSubDomain(settings.domain);\n    }\n\n    if (\n    typeof options.itemNamespace !== 'string' ||\n    options.itemNamespace === '')\n    {\n      console.log(\n        'itemNamespace can not be empty, falling back to cal-heatmap'\n      );\n      options.itemNamespace = 'cal-heatmap';\n    }\n\n    // Don't touch these settings\n    var s = [\n    'data',\n    'onComplete',\n    'onClick',\n    'afterLoad',\n    'afterLoadData',\n    'afterLoadPreviousDomain',\n    'afterLoadNextDomain',\n    'afterUpdate'];\n\n\n    for (var k in s) {\n      if (settings.hasOwnProperty(s[k])) {\n        options[s[k]] = settings[s[k]];\n      }\n    }\n\n    options.subDomainDateFormat =\n    typeof options.subDomainDateFormat === 'string' ||\n    typeof options.subDomainDateFormat === 'function' ?\n    options.subDomainDateFormat :\n    this._domainType[options.subDomain].format.date;\n    options.domainLabelFormat =\n    typeof options.domainLabelFormat === 'string' ||\n    typeof options.domainLabelFormat === 'function' ?\n    options.domainLabelFormat :\n    this._domainType[options.domain].format.legend;\n    options.subDomainTextFormat =\n    typeof options.subDomainTextFormat === 'string' &&\n    options.subDomainTextFormat !== '' ||\n    typeof options.subDomainTextFormat === 'function' ?\n    options.subDomainTextFormat :\n    null;\n    options.domainMargin = expandMarginSetting(options.domainMargin);\n    options.legendMargin = expandMarginSetting(options.legendMargin);\n    options.highlight = parent.expandDateSetting(options.highlight);\n    options.itemName = expandItemName(options.itemName);\n    options.colLimit = parseColLimit(options.colLimit);\n    options.rowLimit = parseRowLimit(options.rowLimit);\n    if (!settings.hasOwnProperty('legendMargin')) {\n      autoAddLegendMargin();\n    }\n    autoAlignLabel();\n\n    /**\n     * Validate that a queryString is valid\n     *\n     * @param  {Element|string|bool} selector   The queryString to test\n     * @param  {bool}  canBeFalse  Whether false is an accepted and valid value\n     * @param  {string} name    Name of the tested selector\n     * @throws {Error}        If the selector is not valid\n     * @return {bool}        True if the selector is a valid queryString\n     */\n    function validateSelector(selector, canBeFalse, name) {\n      if (\n      (canBeFalse && selector === false ||\n      selector instanceof Element ||\n      typeof selector === 'string') &&\n      selector !== '')\n      {\n        return true;\n      }\n      throw new Error('The ' + name + ' is not valid');\n    }\n\n    /**\n     * Return the optimal subDomain for the specified domain\n     *\n     * @param  {string} domain a domain name\n     * @return {string}        the subDomain name\n     */\n    function getOptimalSubDomain(domain) {\n      switch (domain) {\n        case 'year':\n          return 'month';\n        case 'month':\n          return 'day';\n        case 'week':\n          return 'day';\n        case 'day':\n          return 'hour';\n        default:\n          return 'min';\n      }\n    }\n\n    /**\n     * Ensure that the domain and subdomain are valid\n     *\n     * @throw {Error} when domain or subdomain are not valid\n     * @return {bool} True if domain and subdomain are valid and compatible\n     */\n    function validateDomainType() {\n      if (\n      !parent._domainType.hasOwnProperty(options.domain) ||\n      options.domain === 'min' ||\n      options.domain.substring(0, 2) === 'x_')\n      {\n        throw new Error(\"The domain '\" + options.domain + \"' is not valid\");\n      }\n\n      if (\n      !parent._domainType.hasOwnProperty(options.subDomain) ||\n      options.subDomain === 'year')\n      {\n        throw new Error(\n          \"The subDomain '\" + options.subDomain + \"' is not valid\"\n        );\n      }\n\n      if (\n      parent._domainType[options.domain].level <=\n      parent._domainType[options.subDomain].level)\n      {\n        throw new Error(\n          \"'\" +\n          options.subDomain +\n          \"' is not a valid subDomain to '\" +\n          options.domain +\n          \"'\"\n        );\n      }\n\n      return true;\n    }\n\n    /**\n     * Fine-tune the label alignement depending on its position\n     *\n     * @return void\n     */\n    function autoAlignLabel() {\n      // Auto-align label, depending on it's position\n      if (\n      !settings.hasOwnProperty('label') ||\n      settings.hasOwnProperty('label') &&\n      !settings.label.hasOwnProperty('align'))\n      {\n        switch (options.label.position) {\n          case 'left':\n            options.label.align = 'right';\n            break;\n          case 'right':\n            options.label.align = 'left';\n            break;\n          default:\n            options.label.align = 'center';\n        }\n\n        if (options.label.rotate === 'left') {\n          options.label.align = 'right';\n        } else if (options.label.rotate === 'right') {\n          options.label.align = 'left';\n        }\n      }\n\n      if (\n      !settings.hasOwnProperty('label') ||\n      settings.hasOwnProperty('label') &&\n      !settings.label.hasOwnProperty('offset'))\n      {\n        if (\n        options.label.position === 'left' ||\n        options.label.position === 'right')\n        {\n          options.label.offset = {\n            x: 10,\n            y: 15\n          };\n        }\n      }\n    }\n\n    /**\n     * If not specified, add some margin around the legend depending on its position\n     *\n     * @return void\n     */\n    function autoAddLegendMargin() {\n      switch (options.legendVerticalPosition) {\n        case 'top':\n          options.legendMargin[2] = parent.DEFAULT_LEGEND_MARGIN;\n          break;\n        case 'bottom':\n          options.legendMargin[0] = parent.DEFAULT_LEGEND_MARGIN;\n          break;\n        case 'middle':\n        case 'center':\n          options.legendMargin[\n          options.legendHorizontalPosition === 'right' ? 3 : 1] =\n          parent.DEFAULT_LEGEND_MARGIN;\n      }\n    }\n\n    /**\n     * Expand a number of an array of numbers to an usable 4 values array\n     *\n     * @param  {integer|array} value\n     * @return {array}        array\n     */\n    function expandMarginSetting(value) {\n      if (typeof value === 'number') {\n        value = [value];\n      }\n\n      if (!Array.isArray(value)) {\n        console.log('Margin only takes an integer or an array of integers');\n        value = [0];\n      }\n\n      switch (value.length) {\n        case 1:\n          return [value[0], value[0], value[0], value[0]];\n        case 2:\n          return [value[0], value[1], value[0], value[1]];\n        case 3:\n          return [value[0], value[1], value[2], value[1]];\n        case 4:\n          return value;\n        default:\n          return value.slice(0, 4);\n      }\n    }\n\n    /**\n     * Convert a string to an array like [singular-form, plural-form]\n     *\n     * @param  {string|array} value Date to convert\n     * @return {array}       An array like [singular-form, plural-form]\n     */\n    function expandItemName(value) {\n      if (typeof value === 'string') {\n        return [value, value + (value !== '' ? 's' : '')];\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 1) {\n          return [value[0], value[0] + 's'];\n        } else if (value.length > 2) {\n          return value.slice(0, 2);\n        }\n\n        return value;\n      }\n\n      return ['item', 'items'];\n    }\n\n    function parseColLimit(value) {\n      return value > 0 ? value : null;\n    }\n\n    function parseRowLimit(value) {\n      if (value > 0 && options.colLimit > 0) {\n        console.log(\n          'colLimit and rowLimit are mutually exclusive, rowLimit will be ignored'\n        );\n        return null;\n      }\n      return value > 0 ? value : null;\n    }\n\n    return this._init();\n  },\n\n  /**\n   * Convert a keyword or an array of keyword/date to an array of date objects\n   *\n   * @param  {string|array|Date} value Data to convert\n   * @return {array}       An array of Dates\n   */\n  expandDateSetting: function (value) {\n    'use strict';\n\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n\n    return value.\n    map(function (data) {\n      if (data === 'now') {\n        return new Date();\n      }\n      if (data instanceof Date) {\n        return data;\n      }\n      return false;\n    }).\n    filter(function (d) {\n      return d !== false;\n    });\n  },\n\n  /**\n   * Fill the calendar by coloring the cells\n   *\n   * @param array svg An array of html node to apply the transformation to (optional)\n   *                  It's used to limit the painting to only a subset of the calendar\n   * @return void\n   */\n  fill: function (svg) {\n    'use strict';\n\n    var parent = this;\n    var options = parent.options;\n\n    if (arguments.length === 0) {\n      svg = parent.root.selectAll('.graph-domain');\n    }\n\n    var rect = svg.\n    selectAll('svg').\n    selectAll('g').\n    data(function (d) {\n      return parent._domains.get(d);\n    });\n    /**\n     * Colorize the cell via a style attribute if enabled\n     */\n    function addStyle(element) {\n      if (parent.legendScale === null) {\n        return false;\n      }\n\n      element.attr('fill', function (d) {\n        if (\n        d.v === null &&\n        options.hasOwnProperty('considerMissingDataAsZero') &&\n        !options.considerMissingDataAsZero)\n        {\n          if (options.legendColors.hasOwnProperty('base')) {\n            return options.legendColors.base;\n          }\n        }\n\n        if (\n        options.legendColors !== null &&\n        options.legendColors.hasOwnProperty('empty') && (\n        d.v === 0 ||\n        d.v === null &&\n        options.hasOwnProperty('considerMissingDataAsZero') &&\n        options.considerMissingDataAsZero))\n        {\n          return options.legendColors.empty;\n        }\n\n        if (\n        d.v < 0 &&\n        options.legend[0] > 0 &&\n        options.legendColors !== null &&\n        options.legendColors.hasOwnProperty('overflow'))\n        {\n          return options.legendColors.overflow;\n        }\n\n        return parent.legendScale(\n          Math.min(d.v, options.legend[options.legend.length - 1])\n        );\n      });\n    }\n\n    rect.\n    transition().\n    duration(options.animationDuration).\n    select('rect').\n    attr('class', function (d) {\n      var htmlClass = parent.getHighlightClassName(d.t).trim().split(' ');\n      var pastDate = parent.dateIsLessThan(d.t, new Date());\n      var sameDate = parent.dateIsEqual(d.t, new Date());\n\n      if (\n      parent.legendScale === null ||\n      d.v === null &&\n      options.hasOwnProperty('considerMissingDataAsZero') &&\n      !options.considerMissingDataAsZero &&\n      !options.legendColors.hasOwnProperty('base'))\n      {\n        htmlClass.push('graph-rect');\n      }\n\n      if (sameDate) {\n        htmlClass.push('now');\n      } else if (!pastDate) {\n        htmlClass.push('future');\n      }\n\n      if (d.v !== null) {\n        htmlClass.push(\n          parent.Legend.getClass(d.v, parent.legendScale === null)\n        );\n      } else if (options.considerMissingDataAsZero && pastDate) {\n        htmlClass.push(\n          parent.Legend.getClass(0, parent.legendScale === null)\n        );\n      }\n\n      if (options.onClick !== null) {\n        htmlClass.push('hover_cursor');\n      }\n\n      return htmlClass.join(' ');\n    }).\n    call(addStyle);\n\n    rect.\n    transition().\n    duration(options.animationDuration).\n    select('title').\n    text(function (d) {\n      return parent.getSubDomainTitle(d);\n    });\n\n    function formatSubDomainText(element) {\n      if (typeof options.subDomainTextFormat === 'function') {\n        element.text(function (d) {\n          return options.subDomainTextFormat(d.t, d.v);\n        });\n      }\n    }\n\n    /**\n     * Change the subDomainText class if necessary\n     * Also change the text, e.g when text is representing the value\n     * instead of the date\n     */\n    rect.\n    transition().\n    duration(options.animationDuration).\n    select('text').\n    attr('class', function (d) {\n      return 'subdomain-text' + parent.getHighlightClassName(d.t);\n    }).\n    call(formatSubDomainText).\n    attr('fill', (d) => {\n      if (!d.v) return '#000';\n      const rgb = parent.legendScale(\n        Math.min(d.v, options.legend[options.legend.length - 1])\n      );\n      return (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__.getContrastingColor)(rgb, 135);\n    });\n  },\n\n  /**\n   * Sprintf like function.\n   * Replaces placeholders {0} in string with values from provided object.\n   *\n   * @param string formatted String containing placeholders.\n   * @param object args Object with properties to replace placeholders in string.\n   *\n   * @return String\n   */\n  formatStringWithObject: function (formatted, args) {\n    'use strict';\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        var regexp = new RegExp('\\\\{' + prop + '\\\\}', 'gi');\n        formatted = formatted.replace(regexp, args[prop]);\n      }\n    }\n    return formatted;\n  },\n\n  // =========================================================================//\n  // EVENTS CALLBACK                              //\n  // =========================================================================//\n\n  /**\n   * Helper method for triggering event callback\n   *\n   * @param  string  eventName       Name of the event to trigger\n   * @param  array  successArgs     List of argument to pass to the callback\n   * @param  boolean  skip      Whether to skip the event triggering\n   * @return mixed  True when the triggering was skipped, false on error, else the callback function\n   */\n  triggerEvent: function (eventName, successArgs, skip) {\n    'use strict';\n\n    if (arguments.length === 3 && skip || this.options[eventName] === null) {\n      return true;\n    }\n\n    if (typeof this.options[eventName] === 'function') {\n      if (typeof successArgs === 'function') {\n        successArgs = successArgs();\n      }\n      return this.options[eventName].apply(this, successArgs);\n    } else {\n      console.log('Provided callback for ' + eventName + ' is not a function.');\n      return false;\n    }\n  },\n\n  /**\n   * Event triggered on a mouse click on a subDomain cell\n   *\n   * @param  Date    d    Date of the subdomain block\n   * @param  int    itemNb  Number of items in that date\n   */\n  onClick: function (d, itemNb) {\n    'use strict';\n\n    return this.triggerEvent('onClick', [d, itemNb]);\n  },\n\n  /**\n   * Event triggered after drawing the calendar, byt before filling it with data\n   */\n  afterLoad: function () {\n    'use strict';\n\n    return this.triggerEvent('afterLoad');\n  },\n\n  /**\n   * Event triggered after completing drawing and filling the calendar\n   */\n  onComplete: function () {\n    'use strict';\n\n    var response = this.triggerEvent('onComplete', [], this._completed);\n    this._completed = true;\n    return response;\n  },\n\n  /**\n   * Event triggered after shifting the calendar one domain back\n   *\n   * @param  Date    start  Domain start date\n   * @param  Date    end    Domain end date\n   */\n  afterLoadPreviousDomain: function (start) {\n    'use strict';\n\n    var parent = this;\n    return this.triggerEvent('afterLoadPreviousDomain', function () {\n      var subDomain = parent.getSubDomain(start);\n      return [subDomain.shift(), subDomain.pop()];\n    });\n  },\n\n  /**\n   * Event triggered after shifting the calendar one domain above\n   *\n   * @param  Date    start  Domain start date\n   * @param  Date    end    Domain end date\n   */\n  afterLoadNextDomain: function (start) {\n    'use strict';\n\n    var parent = this;\n    return this.triggerEvent('afterLoadNextDomain', function () {\n      var subDomain = parent.getSubDomain(start);\n      return [subDomain.shift(), subDomain.pop()];\n    });\n  },\n\n  /**\n   * Event triggered after loading the leftmost domain allowed by minDate\n   *\n   * @param  boolean  reached True if the leftmost domain was reached\n   */\n  onMinDomainReached: function (reached) {\n    'use strict';\n\n    this._minDomainReached = reached;\n    return this.triggerEvent('onMinDomainReached', [reached]);\n  },\n\n  /**\n   * Event triggered after loading the rightmost domain allowed by maxDate\n   *\n   * @param  boolean  reached True if the rightmost domain was reached\n   */\n  onMaxDomainReached: function (reached) {\n    'use strict';\n\n    this._maxDomainReached = reached;\n    return this.triggerEvent('onMaxDomainReached', [reached]);\n  },\n\n  checkIfMinDomainIsReached: function (date, upperBound) {\n    'use strict';\n\n    if (this.minDomainIsReached(date)) {\n      this.onMinDomainReached(true);\n    }\n\n    if (arguments.length === 2) {\n      if (this._maxDomainReached && !this.maxDomainIsReached(upperBound)) {\n        this.onMaxDomainReached(false);\n      }\n    }\n  },\n\n  checkIfMaxDomainIsReached: function (date, lowerBound) {\n    'use strict';\n\n    if (this.maxDomainIsReached(date)) {\n      this.onMaxDomainReached(true);\n    }\n\n    if (arguments.length === 2) {\n      if (this._minDomainReached && !this.minDomainIsReached(lowerBound)) {\n        this.onMinDomainReached(false);\n      }\n    }\n  },\n\n  afterUpdate: function () {\n    'use strict';\n\n    return this.triggerEvent('afterUpdate');\n  },\n\n  // =========================================================================//\n  // FORMATTER                                //\n  // =========================================================================//\n\n  formatNumber: d3.format(',g'),\n\n  formatDate: function (d, format) {\n    'use strict';\n\n    if (arguments.length < 2) {\n      format = 'title';\n    }\n\n    if (typeof format === 'function') {\n      return format(d);\n    } else {\n      var f = d3.time.format(format);\n      return f(d);\n    }\n  },\n\n  getSubDomainTitle: function (d) {\n    'use strict';\n\n    if (d.v === null && !this.options.considerMissingDataAsZero) {\n      return this.formatStringWithObject(\n        this.options.subDomainTitleFormat.empty,\n        {\n          date: this.formatDate(\n            new Date(d.t),\n            this.options.subDomainDateFormat\n          )\n        }\n      );\n    } else {\n      var value = d.v;\n      // Consider null as 0\n      if (value === null && this.options.considerMissingDataAsZero) {\n        value = 0;\n      }\n\n      return this.formatStringWithObject(\n        this.options.subDomainTitleFormat.filled,\n        {\n          count: this.formatNumber(value),\n          name: this.options.itemName[value !== 1 ? 1 : 0],\n          connector: this._domainType[this.options.subDomain].format.connector,\n          date: this.formatDate(\n            new Date(d.t),\n            this.options.subDomainDateFormat\n          )\n        }\n      );\n    }\n  },\n\n  // =========================================================================//\n  // DOMAIN NAVIGATION                            //\n  // =========================================================================//\n\n  /**\n   * Shift the calendar one domain forward\n   *\n   * The new domain is loaded only if it's not beyond maxDate\n   *\n   * @param int n Number of domains to load\n   * @return bool True if the next domain was loaded, else false\n   */\n  loadNextDomain: function (n) {\n    'use strict';\n\n    if (this._maxDomainReached || n === 0) {\n      return false;\n    }\n\n    var bound = this.loadNewDomains(\n      this.NAVIGATE_RIGHT,\n      this.getDomain(this.getNextDomain(), n)\n    );\n\n    this.afterLoadNextDomain(bound.end);\n    this.checkIfMaxDomainIsReached(this.getNextDomain().getTime(), bound.start);\n\n    return true;\n  },\n\n  /**\n   * Shift the calendar one domain backward\n   *\n   * The previous domain is loaded only if it's not beyond the minDate\n   *\n   * @param int n Number of domains to load\n   * @return bool True if the previous domain was loaded, else false\n   */\n  loadPreviousDomain: function (n) {\n    'use strict';\n\n    if (this._minDomainReached || n === 0) {\n      return false;\n    }\n\n    var bound = this.loadNewDomains(\n      this.NAVIGATE_LEFT,\n      this.getDomain(this.getDomainKeys()[0], -n).reverse()\n    );\n\n    this.afterLoadPreviousDomain(bound.start);\n    this.checkIfMinDomainIsReached(bound.start, bound.end);\n\n    return true;\n  },\n\n  loadNewDomains: function (direction, newDomains) {\n    'use strict';\n\n    var parent = this;\n    var backward = direction === this.NAVIGATE_LEFT;\n    var i = -1;\n    var total = newDomains.length;\n    var domains = this.getDomainKeys();\n\n    function buildSubDomain(d) {\n      return {\n        t: parent._domainType[parent.options.subDomain].extractUnit(d),\n        v: null\n      };\n    }\n\n    // Remove out of bound domains from list of new domains to prepend\n    while (++i < total) {\n      if (backward && this.minDomainIsReached(newDomains[i])) {\n        newDomains = newDomains.slice(0, i + 1);\n        break;\n      }\n      if (!backward && this.maxDomainIsReached(newDomains[i])) {\n        newDomains = newDomains.slice(0, i);\n        break;\n      }\n    }\n\n    newDomains = newDomains.slice(-this.options.range);\n\n    for (i = 0, total = newDomains.length; i < total; i += 1) {\n      this._domains.set(\n        newDomains[i].getTime(),\n        this.getSubDomain(newDomains[i]).map(buildSubDomain)\n      );\n\n      this._domains.remove(backward ? domains.pop() : domains.shift());\n    }\n\n    domains = this.getDomainKeys();\n\n    if (backward) {\n      newDomains = newDomains.reverse();\n    }\n\n    this.paint(direction);\n\n    this.getDatas(\n      this.options.data,\n      newDomains[0],\n      this.getSubDomain(newDomains[newDomains.length - 1]).pop(),\n      function () {\n        parent.fill(parent.lastInsertedSvg);\n      }\n    );\n\n    return {\n      start: newDomains[backward ? 0 : 1],\n      end: domains[domains.length - 1]\n    };\n  },\n\n  /**\n   * Return whether a date is inside the scope determined by maxDate\n   *\n   * @param int datetimestamp The timestamp in ms to test\n   * @return bool True if the specified date correspond to the calendar upper bound\n   */\n  maxDomainIsReached: function (datetimestamp) {\n    'use strict';\n\n    return (\n      this.options.maxDate !== null &&\n      this.options.maxDate.getTime() < datetimestamp);\n\n  },\n\n  /**\n   * Return whether a date is inside the scope determined by minDate\n   *\n   * @param int datetimestamp The timestamp in ms to test\n   * @return bool True if the specified date correspond to the calendar lower bound\n   */\n  minDomainIsReached: function (datetimestamp) {\n    'use strict';\n\n    return (\n      this.options.minDate !== null &&\n      this.options.minDate.getTime() >= datetimestamp);\n\n  },\n\n  /**\n   * Return the list of the calendar's domain timestamp\n   *\n   * @return Array a sorted array of timestamp\n   */\n  getDomainKeys: function () {\n    'use strict';\n\n    return this._domains.\n    keys().\n    map(function (d) {\n      return parseInt(d, 10);\n    }).\n    sort(function (a, b) {\n      return a - b;\n    });\n  },\n\n  // =========================================================================//\n  // POSITIONNING                                //\n  // =========================================================================//\n\n  positionSubDomainX: function (d) {\n    'use strict';\n\n    var index = this._domainType[this.options.subDomain].position.x(\n      new Date(d)\n    );\n    return index * this.options.cellSize + index * this.options.cellPadding;\n  },\n\n  positionSubDomainY: function (d) {\n    'use strict';\n\n    var index = this._domainType[this.options.subDomain].position.y(\n      new Date(d)\n    );\n    return index * this.options.cellSize + index * this.options.cellPadding;\n  },\n\n  getSubDomainColumnNumber: function (d) {\n    'use strict';\n\n    if (this.options.rowLimit > 0) {\n      var i = this._domainType[this.options.subDomain].maxItemNumber;\n      if (typeof i === 'function') {\n        i = i(d);\n      }\n      return Math.ceil(i / this.options.rowLimit);\n    }\n\n    var j = this._domainType[this.options.subDomain].defaultColumnNumber;\n    if (typeof j === 'function') {\n      j = j(d);\n    }\n    return this.options.colLimit || j;\n  },\n\n  getSubDomainRowNumber: function (d) {\n    'use strict';\n\n    if (this.options.colLimit > 0) {\n      var i = this._domainType[this.options.subDomain].maxItemNumber;\n      if (typeof i === 'function') {\n        i = i(d);\n      }\n      return Math.ceil(i / this.options.colLimit);\n    }\n\n    var j = this._domainType[this.options.subDomain].defaultRowNumber;\n    if (typeof j === 'function') {\n      j = j(d);\n    }\n    return this.options.rowLimit || j;\n  },\n\n  /**\n   * Return a classname if the specified date should be highlighted\n   *\n   * @param  timestamp date Date of the current subDomain\n   * @return String the highlight class\n   */\n  getHighlightClassName: function (d) {\n    'use strict';\n\n    d = new Date(d);\n\n    if (this.options.highlight.length > 0) {\n      for (var i in this.options.highlight) {\n        if (this.dateIsEqual(this.options.highlight[i], d)) {\n          return this.isNow(this.options.highlight[i]) ?\n          ' highlight-now' :\n          ' highlight';\n        }\n      }\n    }\n    return '';\n  },\n\n  /**\n   * Return whether the specified date is now,\n   * according to the type of subdomain\n   *\n   * @param  Date d The date to compare\n   * @return bool True if the date correspond to a subdomain cell\n   */\n  isNow: function (d) {\n    'use strict';\n\n    return this.dateIsEqual(d, new Date());\n  },\n\n  /**\n   * Return whether 2 dates are equals\n   * This function is subdomain-aware,\n   * and dates comparison are dependent of the subdomain\n   *\n   * @param  Date dateA First date to compare\n   * @param  Date dateB Secon date to compare\n   * @return bool true if the 2 dates are equals\n   */\n  /* jshint maxcomplexity: false */\n  dateIsEqual: function (dateA, dateB) {\n    'use strict';\n\n    if (!(dateA instanceof Date)) {\n      dateA = new Date(dateA);\n    }\n\n    if (!(dateB instanceof Date)) {\n      dateB = new Date(dateB);\n    }\n\n    switch (this.options.subDomain) {\n      case 'x_min':\n      case 'min':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth() &&\n          dateA.getDate() === dateB.getDate() &&\n          dateA.getHours() === dateB.getHours() &&\n          dateA.getMinutes() === dateB.getMinutes());\n\n      case 'x_hour':\n      case 'hour':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth() &&\n          dateA.getDate() === dateB.getDate() &&\n          dateA.getHours() === dateB.getHours());\n\n      case 'x_day':\n      case 'day':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth() &&\n          dateA.getDate() === dateB.getDate());\n\n      case 'x_week':\n      case 'week':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          this.getWeekNumber(dateA) === this.getWeekNumber(dateB));\n\n      case 'x_month':\n      case 'month':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth());\n\n      default:\n        return false;\n    }\n  },\n\n  /**\n   * Returns wether or not dateA is less than or equal to dateB. This function is subdomain aware.\n   * Performs automatic conversion of values.\n   * @param dateA may be a number or a Date\n   * @param dateB may be a number or a Date\n   * @returns {boolean}\n   */\n  dateIsLessThan: function (dateA, dateB) {\n    'use strict';\n\n    if (!(dateA instanceof Date)) {\n      dateA = new Date(dateA);\n    }\n\n    if (!(dateB instanceof Date)) {\n      dateB = new Date(dateB);\n    }\n\n    function normalizedMillis(date, subdomain) {\n      switch (subdomain) {\n        case 'x_min':\n        case 'min':\n          return new Date(\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes()\n          ).getTime();\n        case 'x_hour':\n        case 'hour':\n          return new Date(\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours()\n          ).getTime();\n        case 'x_day':\n        case 'day':\n          return new Date(\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate()\n          ).getTime();\n        case 'x_week':\n        case 'week':\n        case 'x_month':\n        case 'month':\n          return new Date(date.getFullYear(), date.getMonth()).getTime();\n        default:\n          return date.getTime();\n      }\n    }\n\n    return (\n      normalizedMillis(dateA, this.options.subDomain) <\n      normalizedMillis(dateB, this.options.subDomain));\n\n  },\n\n  // =========================================================================//\n  // DATE COMPUTATION                              //\n  // =========================================================================//\n\n  /**\n   * Return the day of the year for the date\n   * @param  Date\n   * @return  int Day of the year [1,366]\n   */\n  getDayOfYear: d3.time.format('%j'),\n\n  /**\n   * Return the week number of the year\n   * Monday as the first day of the week\n   * @return int  Week number [0-53]\n   */\n  getWeekNumber: function (d) {\n    'use strict';\n\n    var f =\n    this.options.weekStartOnMonday === true ?\n    d3.time.format('%W') :\n    d3.time.format('%U');\n    return f(d);\n  },\n\n  /**\n   * Return the week number, relative to its month\n   *\n   * @param  int|Date d Date or timestamp in milliseconds\n   * @return int Week number, relative to the month [0-5]\n   */\n  getMonthWeekNumber: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n\n    var monthFirstWeekNumber = this.getWeekNumber(\n      new Date(d.getFullYear(), d.getMonth())\n    );\n    return this.getWeekNumber(d) - monthFirstWeekNumber - 1;\n  },\n\n  /**\n   * Return the number of weeks in the dates' year\n   *\n   * @param  int|Date d Date or timestamp in milliseconds\n   * @return int Number of weeks in the date's year\n   */\n  getWeekNumberInYear: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n  },\n\n  /**\n   * Return the number of days in the date's month\n   *\n   * @param  int|Date d Date or timestamp in milliseconds\n   * @return int Number of days in the date's month\n   */\n  getDayCountInMonth: function (d) {\n    'use strict';\n\n    return this.getEndOfMonth(d).getDate();\n  },\n\n  /**\n   * Return the number of days in the date's year\n   *\n   * @param  int|Date d Date or timestamp in milliseconds\n   * @return int Number of days in the date's year\n   */\n  getDayCountInYear: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n    return new Date(d.getFullYear(), 1, 29).getMonth() === 1 ? 366 : 365;\n  },\n\n  /**\n   * Get the weekday from a date\n   *\n   * Return the week day number (0-6) of a date,\n   * depending on whether the week start on monday or sunday\n   *\n   * @param  Date d\n   * @return int The week day number (0-6)\n   */\n  getWeekDay: function (d) {\n    'use strict';\n\n    if (this.options.weekStartOnMonday === false) {\n      return d.getDay();\n    }\n    return d.getDay() === 0 ? 6 : d.getDay() - 1;\n  },\n\n  /**\n   * Get the last day of the month\n   * @param  Date|int  d  Date or timestamp in milliseconds\n   * @return Date      Last day of the month\n   */\n  getEndOfMonth: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n    return new Date(d.getFullYear(), d.getMonth() + 1, 0);\n  },\n\n  /**\n   *\n   * @param  Date date\n   * @param  int count\n   * @param  string step\n   * @return Date\n   */\n  jumpDate: function (date, count, step) {\n    'use strict';\n\n    var d = new Date(date);\n    switch (step) {\n      case 'hour':\n        d.setHours(d.getHours() + count);\n        break;\n      case 'day':\n        d.setHours(d.getHours() + count * 24);\n        break;\n      case 'week':\n        d.setHours(d.getHours() + count * 24 * 7);\n        break;\n      case 'month':\n        d.setMonth(d.getMonth() + count);\n        break;\n      case 'year':\n        d.setFullYear(d.getFullYear() + count);\n    }\n\n    return new Date(d);\n  },\n\n  // =========================================================================//\n  // DOMAIN COMPUTATION                            //\n  // =========================================================================//\n\n  /**\n   * Return all the minutes between 2 dates\n   *\n   * @param  Date  d  date  A date\n   * @param  int|date  range  Number of minutes in the range, or a stop date\n   * @return array  An array of minutes\n   */\n  getMinuteDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(\n      d.getFullYear(),\n      d.getMonth(),\n      d.getDate(),\n      d.getHours()\n    );\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(\n        range.getFullYear(),\n        range.getMonth(),\n        range.getDate(),\n        range.getHours()\n      );\n    } else {\n      stop = new Date(+start + range * 1000 * 60);\n    }\n    return d3.time.minutes(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\n   * Return all the hours between 2 dates\n   *\n   * @param  Date  d  A date\n   * @param  int|date  range  Number of hours in the range, or a stop date\n   * @return array  An array of hours\n   */\n  getHourDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(\n      d.getFullYear(),\n      d.getMonth(),\n      d.getDate(),\n      d.getHours()\n    );\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(\n        range.getFullYear(),\n        range.getMonth(),\n        range.getDate(),\n        range.getHours()\n      );\n    } else {\n      stop = new Date(start);\n      stop.setHours(stop.getHours() + range);\n    }\n\n    var domains = d3.time.hours(Math.min(start, stop), Math.max(start, stop));\n\n    // Passing from DST to standard time\n    // If there are 25 hours, let's compress the duplicate hours\n    var i = 0;\n    var total = domains.length;\n    for (i = 0; i < total; i += 1) {\n      if (i > 0 && domains[i].getHours() === domains[i - 1].getHours()) {\n        this.DSTDomain.push(domains[i].getTime());\n        domains.splice(i, 1);\n        break;\n      }\n    }\n\n    // d3.time.hours is returning more hours than needed when changing\n    // from DST to standard time, because there is really 2 hours between\n    // 1am and 2am!\n    if (typeof range === 'number' && domains.length > Math.abs(range)) {\n      domains.splice(domains.length - 1, 1);\n    }\n\n    return domains;\n  },\n\n  /**\n   * Return all the days between 2 dates\n   *\n   * @param  Date    d    A date\n   * @param  int|date  range  Number of days in the range, or a stop date\n   * @return array  An array of weeks\n   */\n  getDayDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(range.getFullYear(), range.getMonth(), range.getDate());\n    } else {\n      stop = new Date(start);\n      stop = new Date(stop.setDate(stop.getDate() + parseInt(range, 10)));\n    }\n\n    return d3.time.days(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\n   * Return all the weeks between 2 dates\n   *\n   * @param  Date  d  A date\n   * @param  int|date  range  Number of minutes in the range, or a stop date\n   * @return array  An array of weeks\n   */\n  getWeekDomain: function (d, range) {\n    'use strict';\n\n    var weekStart;\n\n    if (this.options.weekStartOnMonday === false) {\n      weekStart = new Date(\n        d.getFullYear(),\n        d.getMonth(),\n        d.getDate() - d.getDay()\n      );\n    } else {\n      if (d.getDay() === 1) {\n        weekStart = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      } else if (d.getDay() === 0) {\n        weekStart = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n        weekStart.setDate(weekStart.getDate() - 6);\n      } else {\n        weekStart = new Date(\n          d.getFullYear(),\n          d.getMonth(),\n          d.getDate() - d.getDay() + 1\n        );\n      }\n    }\n\n    var endDate = new Date(weekStart);\n\n    var stop = range;\n    if (typeof range !== 'object') {\n      stop = new Date(endDate.setDate(endDate.getDate() + range * 7));\n    }\n\n    return this.options.weekStartOnMonday === true ?\n    d3.time.mondays(Math.min(weekStart, stop), Math.max(weekStart, stop)) :\n    d3.time.sundays(Math.min(weekStart, stop), Math.max(weekStart, stop));\n  },\n\n  /**\n   * Return all the months between 2 dates\n   *\n   * @param  Date    d    A date\n   * @param  int|date  range  Number of months in the range, or a stop date\n   * @return array  An array of months\n   */\n  getMonthDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(d.getFullYear(), d.getMonth());\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(range.getFullYear(), range.getMonth());\n    } else {\n      stop = new Date(start);\n      stop = stop.setMonth(stop.getMonth() + range);\n    }\n\n    return d3.time.months(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\n   * Return all the years between 2 dates\n   *\n   * @param  Date  d  date  A date\n   * @param  int|date  range  Number of minutes in the range, or a stop date\n   * @return array  An array of hours\n   */\n  getYearDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(d.getFullYear(), 0);\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(range.getFullYear(), 0);\n    } else {\n      stop = new Date(d.getFullYear() + range, 0);\n    }\n\n    return d3.time.years(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\n   * Get an array of domain start dates\n   *\n   * @param  int|Date date A random date included in the wanted domain\n   * @param  int|Date range Number of dates to get, or a stop date\n   * @return Array of dates\n   */\n  getDomain: function (date, range) {\n    'use strict';\n\n    if (typeof date === 'number') {\n      date = new Date(date);\n    }\n\n    if (arguments.length < 2) {\n      range = this.options.range;\n    }\n\n    switch (this.options.domain) {\n      case 'hour':\n        var domains = this.getHourDomain(date, range);\n\n        // Case where an hour is missing, when passing from standard time to DST\n        // Missing hour is perfectly acceptabl in subDomain, but not in domains\n        if (typeof range === 'number' && domains.length < range) {\n          if (range > 0) {\n            domains.push(this.getHourDomain(domains[domains.length - 1], 2)[1]);\n          } else {\n            domains.shift(this.getHourDomain(domains[0], -2)[0]);\n          }\n        }\n        return domains;\n      case 'day':\n        return this.getDayDomain(date, range);\n      case 'week':\n        return this.getWeekDomain(date, range);\n      case 'month':\n        return this.getMonthDomain(date, range);\n      case 'year':\n        return this.getYearDomain(date, range);\n    }\n  },\n\n  /* jshint maxcomplexity: false */\n  getSubDomain: function (date) {\n    'use strict';\n\n    if (typeof date === 'number') {\n      date = new Date(date);\n    }\n\n    var parent = this;\n\n    /**\n     * @return int\n     */\n    var computeDaySubDomainSize = function (date, domain) {\n      switch (domain) {\n        case 'year':\n          return parent.getDayCountInYear(date);\n        case 'month':\n          return parent.getDayCountInMonth(date);\n        case 'week':\n          return 7;\n      }\n    };\n\n    /**\n     * @return int\n     */\n    var computeMinSubDomainSize = function (date, domain) {\n      switch (domain) {\n        case 'hour':\n          return 60;\n        case 'day':\n          return 60 * 24;\n        case 'week':\n          return 60 * 24 * 7;\n      }\n    };\n\n    /**\n     * @return int\n     */\n    var computeHourSubDomainSize = function (date, domain) {\n      switch (domain) {\n        case 'day':\n          return 24;\n        case 'week':\n          return 168;\n        case 'month':\n          return parent.getDayCountInMonth(date) * 24;\n      }\n    };\n\n    /**\n     * @return int\n     */\n    var computeWeekSubDomainSize = function (date, domain) {\n      if (domain === 'month') {\n        var endOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);\n        var endWeekNb = parent.getWeekNumber(endOfMonth);\n        var startWeekNb = parent.getWeekNumber(\n          new Date(date.getFullYear(), date.getMonth())\n        );\n\n        if (startWeekNb > endWeekNb) {\n          startWeekNb = 0;\n          endWeekNb += 1;\n        }\n\n        return endWeekNb - startWeekNb + 1;\n      } else if (domain === 'year') {\n        return parent.getWeekNumber(new Date(date.getFullYear(), 11, 31));\n      }\n    };\n\n    switch (this.options.subDomain) {\n      case 'x_min':\n      case 'min':\n        return this.getMinuteDomain(\n          date,\n          computeMinSubDomainSize(date, this.options.domain)\n        );\n      case 'x_hour':\n      case 'hour':\n        return this.getHourDomain(\n          date,\n          computeHourSubDomainSize(date, this.options.domain)\n        );\n      case 'x_day':\n      case 'day':\n        return this.getDayDomain(\n          date,\n          computeDaySubDomainSize(date, this.options.domain)\n        );\n      case 'x_week':\n      case 'week':\n        return this.getWeekDomain(\n          date,\n          computeWeekSubDomainSize(date, this.options.domain)\n        );\n      case 'x_month':\n      case 'month':\n        return this.getMonthDomain(date, 12);\n    }\n  },\n\n  /**\n   * Get the n-th next domain after the calendar newest (rightmost) domain\n   * @param  int n\n   * @return Date The start date of the wanted domain\n   */\n  getNextDomain: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.getDomain(\n      this.jumpDate(this.getDomainKeys().pop(), n, this.options.domain),\n      1\n    )[0];\n  },\n\n  /**\n   * Get the n-th domain before the calendar oldest (leftmost) domain\n   * @param  int n\n   * @return Date The start date of the wanted domain\n   */\n  getPreviousDomain: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.getDomain(\n      this.jumpDate(this.getDomainKeys().shift(), -n, this.options.domain),\n      1\n    )[0];\n  },\n\n  // =========================================================================//\n  // DATAS                                  //\n  // =========================================================================//\n\n  /**\n   * Fetch and interpret data from the datasource\n   *\n   * @param string|object source\n   * @param Date startDate\n   * @param Date endDate\n   * @param function callback\n   * @param function|boolean afterLoad function used to convert the data into a json object. Use true to use the afterLoad callback\n   * @param updateMode\n   *\n   * @return mixed\n   * - True if there are no data to load\n   * - False if data are loaded asynchronously\n   */\n  getDatas: function (\n  source,\n  startDate,\n  endDate,\n  callback,\n  afterLoad,\n  updateMode)\n  {\n    'use strict';\n\n    var self = this;\n    if (arguments.length < 5) {\n      afterLoad = true;\n    }\n    if (arguments.length < 6) {\n      updateMode = this.APPEND_ON_UPDATE;\n    }\n    var _callback = function (error, data) {\n      if (afterLoad !== false) {\n        if (typeof afterLoad === 'function') {\n          data = afterLoad(data);\n        } else if (typeof self.options.afterLoadData === 'function') {\n          data = self.options.afterLoadData(data);\n        } else {\n          console.log('Provided callback for afterLoadData is not a function.');\n        }\n      } else if (\n      self.options.dataType === 'csv' ||\n      self.options.dataType === 'tsv')\n      {\n        data = this.interpretCSV(data);\n      }\n      self.parseDatas(data, updateMode, startDate, endDate);\n      if (typeof callback === 'function') {\n        callback();\n      }\n    };\n\n    switch (typeof source) {\n      case 'string':\n        if (source === '') {\n          _callback(null, {});\n          return true;\n        } else {\n          var url = this.parseURI(source, startDate, endDate);\n          var requestType = 'GET';\n          if (self.options.dataPostPayload !== null) {\n            requestType = 'POST';\n          }\n          var payload = null;\n          if (self.options.dataPostPayload !== null) {\n            payload = this.parseURI(\n              self.options.dataPostPayload,\n              startDate,\n              endDate\n            );\n          }\n\n          var xhr = null;\n          switch (this.options.dataType) {\n            case 'json':\n              xhr = d3.json(url);\n              break;\n            case 'csv':\n              xhr = d3.csv(url);\n              break;\n            case 'tsv':\n              xhr = d3.tsv(url);\n              break;\n            case 'txt':\n              xhr = d3.text(url, 'text/plain');\n              break;\n          }\n\n          // jshint maxdepth:5\n          if (self.options.dataRequestHeaders !== null) {\n            for (var header in self.options.dataRequestHeaders) {\n              if (self.options.dataRequestHeaders.hasOwnProperty(header)) {\n                xhr.header(header, self.options.dataRequestHeaders[header]);\n              }\n            }\n          }\n\n          xhr.send(requestType, payload, _callback);\n        }\n        return false;\n      case 'object':\n        if (source === Object(source)) {\n          _callback(null, source);\n          return false;\n        }\n      /* falls through */\n      default:\n        _callback(null, {});\n        return true;\n    }\n  },\n\n  /**\n   * Populate the calendar internal data\n   *\n   * @param object data\n   * @param constant updateMode\n   * @param Date startDate\n   * @param Date endDate\n   *\n   * @return void\n   */\n  parseDatas: function (data, updateMode, startDate, endDate) {\n    'use strict';\n\n    if (updateMode === this.RESET_ALL_ON_UPDATE) {\n      this._domains.forEach(function (key, value) {\n        value.forEach(function (element, index, array) {\n          array[index].v = null;\n        });\n      });\n    }\n\n    var temp = {};\n\n    var extractTime = function (d) {\n      return d.t;\n    };\n\n    /*jshint forin:false */\n    for (var d in data) {\n      var date = new Date(d * 1000);\n      var domainUnit = this.getDomain(date)[0].getTime();\n      // The current data belongs to a domain that was compressed\n      // Compress the data for the two duplicate hours into the same hour\n      if (this.DSTDomain.indexOf(domainUnit) >= 0) {\n        // Re-assign all data to the first or the second duplicate hours\n        // depending on which is visible\n        if (this._domains.has(domainUnit - 3600 * 1000)) {\n          domainUnit -= 3600 * 1000;\n        }\n      }\n\n      // Skip if data is not relevant to current domain\n      if (\n      isNaN(d) ||\n      !data.hasOwnProperty(d) ||\n      !this._domains.has(domainUnit) ||\n      !(domainUnit >= +startDate && domainUnit < +endDate))\n      {\n        continue;\n      }\n\n      var subDomainsData = this._domains.get(domainUnit);\n\n      if (!temp.hasOwnProperty(domainUnit)) {\n        temp[domainUnit] = subDomainsData.map(extractTime);\n      }\n\n      var index = temp[domainUnit].indexOf(\n        this._domainType[this.options.subDomain].extractUnit(date)\n      );\n\n      if (updateMode === this.RESET_SINGLE_ON_UPDATE) {\n        subDomainsData[index].v = data[d];\n      } else {\n        if (!isNaN(subDomainsData[index].v)) {\n          subDomainsData[index].v += data[d];\n        } else {\n          subDomainsData[index].v = data[d];\n        }\n      }\n    }\n  },\n\n  parseURI: function (str, startDate, endDate) {\n    'use strict';\n\n    // Use a timestamp in seconds\n    str = str.replace(/\\{\\{t:start\\}\\}/g, startDate.getTime() / 1000);\n    str = str.replace(/\\{\\{t:end\\}\\}/g, endDate.getTime() / 1000);\n\n    // Use a string date, following the ISO-8601\n    str = str.replace(/\\{\\{d:start\\}\\}/g, startDate.toISOString());\n    str = str.replace(/\\{\\{d:end\\}\\}/g, endDate.toISOString());\n\n    return str;\n  },\n\n  interpretCSV: function (data) {\n    'use strict';\n\n    var d = {};\n    var keys = Object.keys(data[0]);\n    var i, total;\n    for (i = 0, total = data.length; i < total; i += 1) {\n      d[data[i][keys[0]]] = +data[i][keys[1]];\n    }\n    return d;\n  },\n\n  /**\n   * Handle the calendar layout and dimension\n   *\n   * Expand and shrink the container depending on its children dimension\n   * Also rearrange the children position depending on their dimension,\n   * and the legend position\n   *\n   * @return void\n   */\n  resize: function () {\n    'use strict';\n\n    var parent = this;\n    var options = parent.options;\n    var legendWidth = options.displayLegend ?\n    parent.Legend.getDim('width') +\n    options.legendMargin[1] +\n    options.legendMargin[3] :\n    0;\n    var legendHeight = options.displayLegend ?\n    parent.Legend.getDim('height') +\n    options.legendMargin[0] +\n    options.legendMargin[2] :\n    0;\n\n    var graphWidth =\n    parent.graphDim.width - options.domainGutter - options.cellPadding;\n    var graphHeight =\n    parent.graphDim.height - options.domainGutter - options.cellPadding;\n\n    this.root.\n    transition().\n    duration(options.animationDuration).\n    attr('width', function () {\n      if (\n      options.legendVerticalPosition === 'middle' ||\n      options.legendVerticalPosition === 'center')\n      {\n        return graphWidth + legendWidth;\n      }\n      return Math.max(graphWidth, legendWidth);\n    }).\n    attr('height', function () {\n      if (\n      options.legendVerticalPosition === 'middle' ||\n      options.legendVerticalPosition === 'center')\n      {\n        return Math.max(graphHeight, legendHeight);\n      }\n      return graphHeight + legendHeight;\n    });\n\n    this.root.\n    select('.graph').\n    transition().\n    duration(options.animationDuration).\n    attr('y', function () {\n      if (options.legendVerticalPosition === 'top') {\n        return legendHeight;\n      }\n      return 0;\n    }).\n    attr('x', function () {\n      if (\n      (options.legendVerticalPosition === 'middle' ||\n      options.legendVerticalPosition === 'center') &&\n      options.legendHorizontalPosition === 'left')\n      {\n        return legendWidth;\n      }\n      return 0;\n    });\n  },\n\n  // =========================================================================//\n  // PUBLIC API                                //\n  // =========================================================================//\n\n  /**\n   * Shift the calendar forward\n   */\n  next: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.loadNextDomain(n);\n  },\n\n  /**\n   * Shift the calendar backward\n   */\n  previous: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.loadPreviousDomain(n);\n  },\n\n  /**\n   * Jump directly to a specific date\n   *\n   * JumpTo will scroll the calendar until the wanted domain with the specified\n   * date is visible. Unless you set reset to true, the wanted domain\n   * will not necessarily be the first (leftmost) domain of the calendar.\n   *\n   * @param Date date Jump to the domain containing that date\n   * @param bool reset Whether the wanted domain should be the first domain of the calendar\n   * @param bool True of the calendar was scrolled\n   */\n  jumpTo: function (date, reset) {\n    'use strict';\n\n    if (arguments.length < 2) {\n      reset = false;\n    }\n    var domains = this.getDomainKeys();\n    var firstDomain = domains[0];\n    var lastDomain = domains[domains.length - 1];\n\n    if (date < firstDomain) {\n      return this.loadPreviousDomain(this.getDomain(firstDomain, date).length);\n    } else {\n      if (reset) {\n        return this.loadNextDomain(this.getDomain(firstDomain, date).length);\n      }\n\n      if (date > lastDomain) {\n        return this.loadNextDomain(this.getDomain(lastDomain, date).length);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Navigate back to the start date\n   *\n   * @since  3.3.8\n   * @return void\n   */\n  rewind: function () {\n    'use strict';\n\n    this.jumpTo(this.options.start, true);\n  },\n\n  /**\n   * Update the calendar with new data\n   *\n   * @param  object|string    dataSource    The calendar's datasource, same type as this.options.data\n   * @param  boolean|function    afterLoad    Whether to execute afterLoad() on the data. Pass directly a function\n   * if you don't want to use the afterLoad() callback\n   */\n  update: function (dataSource, afterLoad, updateMode) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      dataSource = this.options.data;\n    }\n    if (arguments.length < 2) {\n      afterLoad = true;\n    }\n    if (arguments.length < 3) {\n      updateMode = this.RESET_ALL_ON_UPDATE;\n    }\n\n    var domains = this.getDomainKeys();\n    var self = this;\n    this.getDatas(\n      dataSource,\n      new Date(domains[0]),\n      this.getSubDomain(domains[domains.length - 1]).pop(),\n      function () {\n        self.fill();\n        self.afterUpdate();\n      },\n      afterLoad,\n      updateMode\n    );\n  },\n\n  /**\n   * Set the legend\n   *\n   * @param array legend an array of integer, representing the different threshold value\n   * @param array colorRange an array of 2 hex colors, for the minimum and maximum colors\n   */\n  setLegend: function () {\n    'use strict';\n\n    var oldLegend = this.options.legend.slice(0);\n    if (arguments.length >= 1 && Array.isArray(arguments[0])) {\n      this.options.legend = arguments[0];\n    }\n    if (arguments.length >= 2) {\n      if (Array.isArray(arguments[1]) && arguments[1].length >= 2) {\n        this.options.legendColors = [arguments[1][0], arguments[1][1]];\n      } else {\n        this.options.legendColors = arguments[1];\n      }\n    }\n\n    if (\n    arguments.length > 0 && !arrayEquals(oldLegend, this.options.legend) ||\n    arguments.length >= 2)\n    {\n      this.Legend.buildColors();\n      this.fill();\n    }\n\n    this.Legend.redraw(\n      this.graphDim.width -\n      this.options.domainGutter -\n      this.options.cellPadding\n    );\n  },\n\n  /**\n   * Remove the legend\n   *\n   * @return bool False if there is no legend to remove\n   */\n  removeLegend: function () {\n    'use strict';\n\n    if (!this.options.displayLegend) {\n      return false;\n    }\n    this.options.displayLegend = false;\n    this.Legend.remove();\n    return true;\n  },\n\n  /**\n   * Display the legend\n   *\n   * @return bool False if the legend was already displayed\n   */\n  showLegend: function () {\n    'use strict';\n\n    if (this.options.displayLegend) {\n      return false;\n    }\n    this.options.displayLegend = true;\n    this.Legend.redraw(\n      this.graphDim.width -\n      this.options.domainGutter -\n      this.options.cellPadding\n    );\n    return true;\n  },\n\n  /**\n   * Highlight dates\n   *\n   * Add a highlight class to a set of dates\n   *\n   * @since  3.3.5\n   * @param  array Array of dates to highlight\n   * @return bool True if dates were highlighted\n   */\n  highlight: function (args) {\n    'use strict';\n\n    if ((this.options.highlight = this.expandDateSetting(args)).length > 0) {\n      this.fill();\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * Destroy the calendar\n   *\n   * Usage: cal = cal.destroy();\n   *\n   * @since  3.3.6\n   * @param function A callback function to trigger after destroying the calendar\n   * @return null\n   */\n  destroy: function (callback) {\n    'use strict';\n\n    this.root.\n    transition().\n    duration(this.options.animationDuration).\n    attr('width', 0).\n    attr('height', 0).\n    remove().\n    each('end', function () {\n      if (typeof callback === 'function') {\n        callback();\n      } else if (typeof callback !== 'undefined') {\n        console.log('Provided callback for destroy() is not a function.');\n      }\n    });\n\n    return null;\n  },\n\n  getSVG: function () {\n    'use strict';\n\n    var styles = {\n      '.cal-heatmap-container': {},\n      '.graph': {},\n      '.graph-rect': {},\n      'rect.highlight': {},\n      'rect.now': {},\n      'rect.highlight-now': {},\n      'text.highlight': {},\n      'text.now': {},\n      'text.highlight-now': {},\n      '.domain-background': {},\n      '.graph-label': {},\n      '.subdomain-text': {},\n      '.q0': {},\n      '.qi': {}\n    };\n\n    for (\n    var j = 1, total = this.options.legend.length + 1;\n    j <= total;\n    j += 1)\n    {\n      styles['.q' + j] = {};\n    }\n\n    var root = this.root;\n\n    var whitelistStyles = [\n    // SVG specific properties\n    'stroke',\n    'stroke-width',\n    'stroke-opacity',\n    'stroke-dasharray',\n    'stroke-dashoffset',\n    'stroke-linecap',\n    'stroke-miterlimit',\n    'fill',\n    'fill-opacity',\n    'fill-rule',\n    'marker',\n    'marker-start',\n    'marker-mid',\n    'marker-end',\n    'alignement-baseline',\n    'baseline-shift',\n    'dominant-baseline',\n    'glyph-orientation-horizontal',\n    'glyph-orientation-vertical',\n    'kerning',\n    'text-anchor',\n    'shape-rendering',\n\n    // Text Specific properties\n    'text-transform',\n    'font-family',\n    'font',\n    'font-size',\n    'font-weight'];\n\n\n    var filterStyles = function (attribute, property, value) {\n      if (whitelistStyles.indexOf(property) !== -1) {\n        styles[attribute][property] = value;\n      }\n    };\n\n    var getElement = function (e) {\n      return root.select(e)[0][0];\n    };\n\n    /* jshint forin:false */\n    for (var element in styles) {\n      if (!styles.hasOwnProperty(element)) {\n        continue;\n      }\n\n      var dom = getElement(element);\n\n      if (dom === null) {\n        continue;\n      }\n\n      // The DOM Level 2 CSS way\n      /* jshint maxdepth: false */\n      if ('getComputedStyle' in window) {\n        var cs = getComputedStyle(dom, null);\n        if (cs.length !== 0) {\n          for (var i = 0; i < cs.length; i += 1) {\n            filterStyles(element, cs.item(i), cs.getPropertyValue(cs.item(i)));\n          }\n\n          // Opera workaround. Opera doesn\"t support `item`/`length`\n          // on CSSStyleDeclaration.\n        } else {\n          for (var k in cs) {\n            if (cs.hasOwnProperty(k)) {\n              filterStyles(element, k, cs[k]);\n            }\n          }\n        }\n\n        // The IE way\n      } else if ('currentStyle' in dom) {\n        var css = dom.currentStyle;\n        for (var p in css) {\n          filterStyles(element, p, css[p]);\n        }\n      }\n    }\n\n    var string =\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" ' +\n    'xmlns:xlink=\"http://www.w3.org/1999/xlink\"><style type=\"text/css\"><![CDATA[ ';\n\n    for (var style in styles) {\n      string += style + ' {\\n';\n      for (var l in styles[style]) {\n        string += '\\t' + l + ':' + styles[style][l] + ';\\n';\n      }\n      string += '}\\n';\n    }\n\n    string += ']]></style>';\n    string += new XMLSerializer().serializeToString(this.root[0][0]);\n    string += '</svg>';\n\n    return string;\n  }\n};\n\n// =========================================================================//\n// DOMAIN POSITION COMPUTATION                        //\n// =========================================================================//\n\n/**\n * Compute the position of a domain, relative to the calendar\n */\nvar DomainPosition = function () {\n  'use strict';\n\n  this.positions = d3.map();\n};\n\nDomainPosition.prototype.getPosition = function (d) {\n  'use strict';\n\n  return this.positions.get(d);\n};\n\nDomainPosition.prototype.getPositionFromIndex = function (i) {\n  'use strict';\n\n  var domains = this.getKeys();\n  return this.positions.get(domains[i]);\n};\n\nDomainPosition.prototype.getLast = function () {\n  'use strict';\n\n  var domains = this.getKeys();\n  return this.positions.get(domains[domains.length - 1]);\n};\n\nDomainPosition.prototype.setPosition = function (d, dim) {\n  'use strict';\n\n  this.positions.set(d, dim);\n};\n\nDomainPosition.prototype.shiftRightBy = function (exitingDomainDim) {\n  'use strict';\n\n  this.positions.forEach(function (key, value) {\n    this.set(key, value - exitingDomainDim);\n  });\n\n  var domains = this.getKeys();\n  this.positions.remove(domains[0]);\n};\n\nDomainPosition.prototype.shiftLeftBy = function (enteringDomainDim) {\n  'use strict';\n\n  this.positions.forEach(function (key, value) {\n    this.set(key, value + enteringDomainDim);\n  });\n\n  var domains = this.getKeys();\n  this.positions.remove(domains[domains.length - 1]);\n};\n\nDomainPosition.prototype.getKeys = function () {\n  'use strict';\n\n  return this.positions.keys().sort(function (a, b) {\n    return parseInt(a, 10) - parseInt(b, 10);\n  });\n};\n\n// =========================================================================//\n// LEGEND                                  //\n// =========================================================================//\n\nvar Legend = function (calendar) {\n  'use strict';\n\n  this.calendar = calendar;\n  this.computeDim();\n\n  if (calendar.options.legendColors !== null) {\n    this.buildColors();\n  }\n};\n\nLegend.prototype.computeDim = function () {\n  'use strict';\n\n  var options = this.calendar.options; // Shorter accessor for variable name mangling when minifying\n  this.dim = {\n    width:\n    options.legendCellSize * (options.legend.length + 1) +\n    options.legendCellPadding * options.legend.length,\n    height: options.legendCellSize\n  };\n};\n\nLegend.prototype.remove = function () {\n  'use strict';\n\n  this.calendar.root.select('.graph-legend').remove();\n  this.calendar.resize();\n};\n\nLegend.prototype.redraw = function (width) {\n  'use strict';\n\n  if (!this.calendar.options.displayLegend) {\n    return false;\n  }\n\n  var parent = this;\n  var calendar = this.calendar;\n  var legend = calendar.root;\n  var legendItem;\n  var options = calendar.options; // Shorter accessor for variable name mangling when minifying\n\n  this.computeDim();\n\n  var _legend = options.legend.slice(0);\n  _legend.push(_legend[_legend.length - 1] + 1);\n\n  var legendElement = calendar.root.select('.graph-legend');\n  if (legendElement[0][0] !== null) {\n    legend = legendElement;\n    legendItem = legend.select('g').selectAll('rect').data(_legend);\n  } else {\n    // Creating the new legend DOM if it doesn't already exist\n    legend =\n    options.legendVerticalPosition === 'top' ?\n    legend.insert('svg', '.graph') :\n    legend.append('svg');\n\n    legend.attr('x', getLegendXPosition()).attr('y', getLegendYPosition());\n\n    legendItem = legend.\n    attr('class', 'graph-legend').\n    attr('height', parent.getDim('height')).\n    attr('width', parent.getDim('width')).\n    append('g').\n    selectAll().\n    data(_legend);\n  }\n\n  legendItem.\n  enter().\n  append('rect').\n  call(legendCellLayout).\n  attr('class', function (d) {\n    return calendar.Legend.getClass(d, calendar.legendScale === null);\n  }).\n  attr('fill-opacity', 0).\n  call(function (selection) {\n    if (\n    calendar.legendScale !== null &&\n    options.legendColors !== null &&\n    options.legendColors.hasOwnProperty('base'))\n    {\n      selection.attr('fill', options.legendColors.base);\n    }\n  }).\n  append('title');\n\n  legendItem.\n  exit().\n  transition().\n  duration(options.animationDuration).\n  attr('fill-opacity', 0).\n  remove();\n\n  legendItem.\n  transition().\n  delay(function (d, i) {\n    return options.animationDuration * i / 10;\n  }).\n  call(legendCellLayout).\n  attr('fill-opacity', 1).\n  call(function (element) {\n    element.attr('fill', function (d, i) {\n      if (calendar.legendScale === null) {\n        return '';\n      }\n\n      if (i === 0) {\n        return calendar.legendScale(d - 1);\n      }\n      return calendar.legendScale(options.legend[i - 1]);\n    });\n\n    element.attr('class', function (d) {\n      return calendar.Legend.getClass(d, calendar.legendScale === null);\n    });\n  });\n\n  function legendCellLayout(selection) {\n    selection.\n    attr('width', options.legendCellSize).\n    attr('height', options.legendCellSize).\n    attr('rx', options.legendCellRadius).\n    attr('ry', options.legendCellRadius).\n    attr('x', function (d, i) {\n      return i * (options.legendCellSize + options.legendCellPadding);\n    });\n  }\n\n  legendItem.select('title').text(function (d, i) {\n    if (i === 0) {\n      return calendar.formatStringWithObject(options.legendTitleFormat.lower, {\n        min: options.legend[i],\n        name: options.itemName[1]\n      });\n    } else if (i === _legend.length - 1) {\n      return calendar.formatStringWithObject(options.legendTitleFormat.upper, {\n        max: options.legend[i - 1],\n        name: options.itemName[1]\n      });\n    } else {\n      return calendar.formatStringWithObject(options.legendTitleFormat.inner, {\n        down: options.legend[i - 1],\n        up: options.legend[i],\n        name: options.itemName[1]\n      });\n    }\n  });\n  legendItem.\n  on('mouseover', function (d) {\n    calendar.legendTip.show(d, this);\n  }).\n  on('mouseout', function () {\n    calendar.legendTip.hide();\n  });\n\n  legend.\n  transition().\n  duration(options.animationDuration).\n  attr('x', getLegendXPosition()).\n  attr('y', getLegendYPosition()).\n  attr('width', parent.getDim('width')).\n  attr('height', parent.getDim('height'));\n\n  legend.\n  select('g').\n  transition().\n  duration(options.animationDuration).\n  attr('transform', function () {\n    if (options.legendOrientation === 'vertical') {\n      return (\n        'rotate(90 ' +\n        options.legendCellSize / 2 +\n        ' ' +\n        options.legendCellSize / 2 +\n        ')');\n\n    }\n    return '';\n  });\n\n  function getLegendXPosition() {\n    switch (options.legendHorizontalPosition) {\n      case 'right':\n        if (\n        options.legendVerticalPosition === 'center' ||\n        options.legendVerticalPosition === 'middle')\n        {\n          return width + options.legendMargin[3];\n        }\n        return width - parent.getDim('width') - options.legendMargin[1];\n      case 'middle':\n      case 'center':\n        return Math.round(width / 2 - parent.getDim('width') / 2);\n      default:\n        return options.legendMargin[3];\n    }\n  }\n\n  function getLegendYPosition() {\n    if (options.legendVerticalPosition === 'bottom') {\n      return (\n        calendar.graphDim.height +\n        options.legendMargin[0] -\n        options.domainGutter -\n        options.cellPadding);\n\n    }\n    return options.legendMargin[0];\n  }\n\n  calendar.resize();\n};\n\n/**\n * Return the dimension of the legend\n *\n * Takes into account rotation\n *\n * @param  string axis Width or height\n * @return int height or width in pixels\n */\nLegend.prototype.getDim = function (axis) {\n  'use strict';\n\n  var isHorizontal = this.calendar.options.legendOrientation === 'horizontal';\n\n  switch (axis) {\n    case 'width':\n      return this.dim[isHorizontal ? 'width' : 'height'];\n    case 'height':\n      return this.dim[isHorizontal ? 'height' : 'width'];\n  }\n};\n\nLegend.prototype.buildColors = function () {\n  'use strict';\n\n  var options = this.calendar.options; // Shorter accessor for variable name mangling when minifying\n\n  if (options.legendColors === null) {\n    this.calendar.legendScale = null;\n    return false;\n  }\n\n  var _colorRange = [];\n\n  if (Array.isArray(options.legendColors)) {\n    _colorRange = options.legendColors;\n  } else if (\n  options.legendColors.hasOwnProperty('min') &&\n  options.legendColors.hasOwnProperty('max'))\n  {\n    _colorRange = [options.legendColors.min, options.legendColors.max];\n  } else {\n    options.legendColors = null;\n    return false;\n  }\n\n  var _legend = options.legend.slice(0);\n\n  if (_legend[0] > 0) {\n    _legend.unshift(0);\n  } else if (_legend[0] <= 0) {\n    // Let's guess the leftmost value, it we have to add one\n    _legend.unshift(\n      _legend[0] - (_legend[_legend.length - 1] - _legend[0]) / _legend.length\n    );\n  }\n  var colorScale;\n  if (options.legendColors.hasOwnProperty('colorScale')) {\n    colorScale = options.legendColors.colorScale;\n  } else {\n    colorScale = d3.scale.\n    linear().\n    range(_colorRange).\n    interpolate(d3.interpolateHcl).\n    domain([d3.min(_legend), d3.max(_legend)]);\n  }\n\n  var legendColors = _legend.map(function (element) {\n    return colorScale(element);\n  });\n  this.calendar.legendScale = d3.scale.\n  threshold().\n  domain(options.legend).\n  range(legendColors);\n\n  return true;\n};\n\n/**\n * Return the classname on the legend for the specified value\n *\n * @param integer n Value associated to a date\n * @param bool withCssClass Whether to display the css class used to style the cell.\n *                          Disabling will allow styling directly via html fill attribute\n *\n * @return string Classname according to the legend\n */\nLegend.prototype.getClass = function (n, withCssClass) {\n  'use strict';\n\n  if (n === null || isNaN(n)) {\n    return '';\n  }\n\n  var index = [this.calendar.options.legend.length + 1];\n\n  for (\n  var i = 0, total = this.calendar.options.legend.length - 1;\n  i <= total;\n  i += 1)\n  {\n    if (this.calendar.options.legend[0] > 0 && n < 0) {\n      index = ['1', 'i'];\n      break;\n    }\n\n    if (n <= this.calendar.options.legend[i]) {\n      index = [i + 1];\n      break;\n    }\n  }\n\n  if (n === 0) {\n    index.push(0);\n  }\n\n  index.unshift('');\n  return (index.join(' r') + (withCssClass ? index.join(' q') : '')).trim();\n};\n\n/**\n * #source http://stackoverflow.com/a/383245/805649\n */\nfunction mergeRecursive(obj1, obj2) {\n  'use strict';\n\n  /*jshint forin:false */\n  for (var p in obj2) {\n    try {\n      // Property in destination object set; update its value.\n      if (obj2[p].constructor === Object) {\n        obj1[p] = mergeRecursive(obj1[p], obj2[p]);\n      } else {\n        obj1[p] = obj2[p];\n      }\n    } catch (e) {\n      // Property in destination object not set; create it and set its value.\n      obj1[p] = obj2[p];\n    }\n  }\n\n  return obj1;\n}\n\n/**\n * Check if 2 arrays are equals\n *\n * @link http://stackoverflow.com/a/14853974/805649\n * @param  array array the array to compare to\n * @return bool true of the 2 arrays are equals\n */\nfunction arrayEquals(arrayA, arrayB) {\n  'use strict';\n\n  // if the other array is a falsy value, return\n  if (!arrayB || !arrayA) {\n    return false;\n  }\n\n  // compare lengths - can save a lot of time\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n\n  for (var i = 0; i < arrayA.length; i += 1) {\n    // Check if we have nested arrays\n    if (arrayA[i] instanceof Array && arrayB[i] instanceof Array) {\n      // recurse into the nested arrays\n      if (!arrayEquals(arrayA[i], arrayB[i])) {\n        return false;\n      }\n    } else if (arrayA[i] !== arrayB[i]) {\n      // Warning - two different object instances will never be equal: {x:20} != {x:20}\n      return false;\n    }\n  }\n  return true;\n}const _default =\n\nCalHeatMap;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(d3, \"d3\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");reactHotLoader.register(CalHeatMap, \"CalHeatMap\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");reactHotLoader.register(DomainPosition, \"DomainPosition\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");reactHotLoader.register(Legend, \"Legend\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");reactHotLoader.register(mergeRecursive, \"mergeRecursive\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");reactHotLoader.register(arrayEquals, \"arrayEquals\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvc3JjL3ZlbmRvci9jYWwtaGVhdG1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWNhbGVuZGFyL3NyYy92ZW5kb3IvY2FsLWhlYXRtYXAuanM/ZWU1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBbTElDRU5TRSBUQkRdXG4vKiBDb3BpZWQgYW5kIGFsdGVyZWQgZnJvbSBodHRwOi8vY2FsLWhlYXRtYXAuY29tLyAsIGFsdGVyYXRpb25zIGFyb3VuZDpcbiAqIC0gdHVuaW5nIHRvb2x0aXBzXG4gKiAtIHN1cHBvcnRpbmcgbXVsdGktY29sb3JzIHNjYWxlc1xuICogLSBsZWdlbmQgZm9ybWF0XG4gKiAtIFVUQyBoYW5kbGluZ1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCBkM3RpcCBmcm9tICdkMy10aXAnO1xuaW1wb3J0IHsgZ2V0Q29udHJhc3RpbmdDb2xvciwgdCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcblxudmFyIGQzID0gdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyByZXF1aXJlKCdkMycpIDogd2luZG93LmQzO1xuXG52YXIgZDMgPSB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IHJlcXVpcmUoJ2QzJykgOiB3aW5kb3cuZDM7XG5cbnZhciBDYWxIZWF0TWFwID0gZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnRpcCA9IGQzdGlwKClcbiAgICAuYXR0cignY2xhc3MnLCAnZDMtdGlwJylcbiAgICAuZGlyZWN0aW9uKCduJylcbiAgICAub2Zmc2V0KFstNSwgMF0pXG4gICAgLmh0bWwoXG4gICAgICBkID0+IGBcbiAgICAgICR7c2VsZi5vcHRpb25zLnRpbWVGb3JtYXR0ZXIoZC50KX06IDxzdHJvbmc+JHtzZWxmLm9wdGlvbnMudmFsdWVGb3JtYXR0ZXIoXG4gICAgICAgIGQudixcbiAgICAgICl9PC9zdHJvbmc+XG4gICAgYCxcbiAgICApO1xuICBzZWxmLmxlZ2VuZFRpcCA9IGQzdGlwKClcbiAgICAuYXR0cignY2xhc3MnLCAnZDMtdGlwJylcbiAgICAuZGlyZWN0aW9uKCduJylcbiAgICAub2Zmc2V0KFstNSwgMF0pXG4gICAgLmh0bWwoZCA9PiBzZWxmLm9wdGlvbnMudmFsdWVGb3JtYXR0ZXIoZCkpO1xuXG4gIHRoaXMuYWxsb3dlZERhdGFUeXBlID0gWydqc29uJywgJ2NzdicsICd0c3YnLCAndHh0J107XG5cbiAgLy8gRGVmYXVsdCBzZXR0aW5nc1xuICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgLy8gc2VsZWN0b3Igc3RyaW5nIG9mIHRoZSBjb250YWluZXIgdG8gYXBwZW5kIHRoZSBncmFwaCB0b1xuICAgIC8vIEFjY2VwdCBhbnkgc3RyaW5nIHZhbHVlIGFjY2VwdGVkIGJ5IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Igb3IgQ1NTM1xuICAgIC8vIG9yIGFuIEVsZW1lbnQgb2JqZWN0XG4gICAgaXRlbVNlbGVjdG9yOiAnI2NhbC1oZWF0bWFwJyxcblxuICAgIC8vIFdoZXRoZXIgdG8gcGFpbnQgdGhlIGNhbGVuZGFyIG9uIGluaXQoKVxuICAgIC8vIFVzZWQgYnkgdGVzdHN1aXRlIHRvIHJlZHVjZSB0ZXN0aW5nIHRpbWVcbiAgICBwYWludE9uTG9hZDogdHJ1ZSxcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIERPTUFJTlxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gTnVtYmVyIG9mIGRvbWFpbiB0byBkaXNwbGF5IG9uIHRoZSBncmFwaFxuICAgIHJhbmdlOiAxMixcblxuICAgIC8vIFNpemUgb2YgZWFjaCBjZWxsLCBpbiBwaXhlbFxuICAgIGNlbGxTaXplOiAxMCxcblxuICAgIC8vIFBhZGRpbmcgYmV0d2VlbiBlYWNoIGNlbGwsIGluIHBpeGVsXG4gICAgY2VsbFBhZGRpbmc6IDIsXG5cbiAgICAvLyBGb3Igcm91bmRlZCBzdWJkb21haW4gcmVjdGFuZ2xlcywgaW4gcGl4ZWxzXG4gICAgY2VsbFJhZGl1czogMCxcblxuICAgIGRvbWFpbkd1dHRlcjogMixcblxuICAgIGRvbWFpbk1hcmdpbjogWzAsIDAsIDAsIDBdLFxuXG4gICAgdmFsdWVGb3JtYXR0ZXI6IGQgPT4gZCxcblxuICAgIHRpbWVGb3JtYXR0ZXI6IGQgPT4gZCxcblxuICAgIGRvbWFpbjogJ2hvdXInLFxuXG4gICAgc3ViRG9tYWluOiAnbWluJyxcblxuICAgIC8vIE51bWJlciBvZiBjb2x1bW5zIHRvIHNwbGl0IHRoZSBzdWJEb21haW5zIHRvXG4gICAgLy8gSWYgbm90IG51bGwsIHdpbGwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHJvd0xpbWl0XG4gICAgY29sTGltaXQ6IG51bGwsXG5cbiAgICAvLyBOdW1iZXIgb2Ygcm93cyB0byBzcGxpdCB0aGUgc3ViRG9tYWlucyB0b1xuICAgIC8vIFdpbGwgYmUgaWdub3JlZCBpZiBjb2xMaW1pdCBpcyBub3QgbnVsbFxuICAgIHJvd0xpbWl0OiBudWxsLFxuXG4gICAgLy8gRmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGlzIE1vbmRheVxuICAgIC8vIDAgdG8gc3RhcnQgdGhlIHdlZWsgb24gU3VuZGF5XG4gICAgd2Vla1N0YXJ0T25Nb25kYXk6IHRydWUsXG5cbiAgICAvLyBTdGFydCBkYXRlIG9mIHRoZSBncmFwaFxuICAgIC8vIEBkZWZhdWx0IG5vd1xuICAgIHN0YXJ0OiBuZXcgRGF0ZSgpLFxuXG4gICAgbWluRGF0ZTogbnVsbCxcblxuICAgIG1heERhdGU6IG51bGwsXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBEQVRBXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBEYXRhIHNvdXJjZVxuICAgIC8vIFVSTCwgd2hlcmUgdG8gZmV0Y2ggdGhlIG9yaWdpbmFsIGRhdGFzXG4gICAgZGF0YTogJycsXG5cbiAgICAvLyBEYXRhIHR5cGVcbiAgICAvLyBEZWZhdWx0OiBqc29uXG4gICAgZGF0YVR5cGU6IHRoaXMuYWxsb3dlZERhdGFUeXBlWzBdLFxuXG4gICAgLy8gUGF5bG9hZCBzZW50IHdoZW4gdXNpbmcgUE9TVCBodHRwIG1ldGhvZFxuICAgIC8vIExlYXZlIHRvIG51bGwgKGRlZmF1bHQpIGZvciBHRVQgcmVxdWVzdFxuICAgIC8vIEV4cGVjdCBhIHN0cmluZywgZm9ybWF0dGVkIGxpa2UgXCJhPWI7Yz1kXCJcbiAgICBkYXRhUG9zdFBheWxvYWQ6IG51bGwsXG5cbiAgICAvLyBBZGRpdGlvbmFsIGhlYWRlcnMgc2VudCB3aGVuIHJlcXVlc3RpbmcgZGF0YVxuICAgIC8vIEV4cGVjdCBhbiBvYmplY3QgZm9ybWF0dGVkIGxpa2U6XG4gICAgLy8geyAnWC1DU1JGLVRPS0VOJzogJ3Rva2VuJyB9XG4gICAgZGF0YVJlcXVlc3RIZWFkZXJzOiBudWxsLFxuXG4gICAgLy8gV2hldGhlciB0byBjb25zaWRlciBtaXNzaW5nIGRhdGU6dmFsdWUgZnJvbSB0aGUgZGF0YXNvdXJjZVxuICAgIC8vIGFzIGVxdWFsIHRvIDAsIG9yIGp1c3QgbGVhdmUgdGhlbSBhcyBtaXNzaW5nXG4gICAgY29uc2lkZXJNaXNzaW5nRGF0YUFzWmVybzogZmFsc2UsXG5cbiAgICAvLyBMb2FkIHJlbW90ZSBkYXRhIG9uIGNhbGVuZGFyIGNyZWF0aW9uXG4gICAgLy8gV2hlbiBmYWxzZSwgdGhlIGNhbGVuZGFyIHdpbGwgYmUgbGVmdCBlbXB0eVxuICAgIGxvYWRPbkluaXQ6IHRydWUsXG5cbiAgICAvLyBDYWxlbmRhciBvcmllbnRhdGlvblxuICAgIC8vIGZhbHNlOiBkaXNwbGF5IGRvbWFpbnMgc2lkZSBieSBzaWRlXG4gICAgLy8gdHJ1ZSA6IGRpc3BsYXkgZG9tYWlucyBvbmUgdW5kZXIgdGhlIG90aGVyXG4gICAgdmVydGljYWxPcmllbnRhdGlvbjogZmFsc2UsXG5cbiAgICAvLyBEb21haW4gZHluYW1pYyB3aWR0aC9oZWlnaHRcbiAgICAvLyBUaGUgd2lkdGggb24gYSBkb21haW4gZGVwZW5kcyBvbiB0aGUgbnVtYmVyIG9mXG4gICAgZG9tYWluRHluYW1pY0RpbWVuc2lvbjogdHJ1ZSxcblxuICAgIC8vIERvbWFpbiBMYWJlbCBwcm9wZXJ0aWVzXG4gICAgbGFiZWw6IHtcbiAgICAgIC8vIHZhbGlkOiB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcbiAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcblxuICAgICAgLy8gVmFsaWQ6IGxlZnQsIGNlbnRlciwgcmlnaHRcbiAgICAgIC8vIEFsc28gdmFsaWQgYXJlIHRoZSBkaXJlY3Qgc3ZnIHZhbHVlczogc3RhcnQsIG1pZGRsZSwgZW5kXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG5cbiAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIG1hcmdpbi9wYWRkaW5nIGFyb3VuZCB0aGUgbGFiZWxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgfSxcblxuICAgICAgcm90YXRlOiBudWxsLFxuXG4gICAgICAvLyBVc2VkIG9ubHkgb24gdmVydGljYWwgb3JpZW50YXRpb25cbiAgICAgIHdpZHRoOiAxMDAsXG5cbiAgICAgIC8vIFVzZWQgb25seSBvbiBob3Jpem9udGFsIG9yaWVudGF0aW9uXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgfSxcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIExFR0VORFxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gVGhyZXNob2xkIGZvciB0aGUgbGVnZW5kXG4gICAgbGVnZW5kOiBbMTAsIDIwLCAzMCwgNDBdLFxuXG4gICAgLy8gV2hldGhlciB0byBkaXNwbGF5IHRoZSBsZWdlbmRcbiAgICBkaXNwbGF5TGVnZW5kOiB0cnVlLFxuXG4gICAgbGVnZW5kQ2VsbFNpemU6IDEwLFxuXG4gICAgbGVnZW5kQ2VsbFBhZGRpbmc6IDIsXG5cbiAgICBsZWdlbmRNYXJnaW46IFswLCAwLCAwLCAwXSxcblxuICAgIC8vIExlZ2VuZCB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgIC8vIHRvcDogcGxhY2UgbGVnZW5kIGFib3ZlIGNhbGVuZGFyXG4gICAgLy8gYm90dG9tOiBwbGFjZSBsZWdlbmQgYmVsb3cgdGhlIGNhbGVuZGFyXG4gICAgbGVnZW5kVmVydGljYWxQb3NpdGlvbjogJ2JvdHRvbScsXG5cbiAgICAvLyBMZWdlbmQgaG9yaXpvbnRhbCBwb3NpdGlvblxuICAgIC8vIGFjY2VwdGVkIHZhbHVlczogbGVmdCwgY2VudGVyLCByaWdodFxuICAgIGxlZ2VuZEhvcml6b250YWxQb3NpdGlvbjogJ2xlZnQnLFxuXG4gICAgLy8gTGVnZW5kIHJvdGF0aW9uXG4gICAgLy8gYWNjZXB0ZWQgdmFsdWVzOiBob3Jpem9udGFsLCB2ZXJ0aWNhbFxuICAgIGxlZ2VuZE9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcsXG5cbiAgICAvLyBPYmplY3RzIGhvbGRpbmcgYWxsIHRoZSBoZWF0bWFwIGRpZmZlcmVudCBjb2xvcnNcbiAgICAvLyBudWxsIHRvIGRpc2FibGUsIGFuZCB1c2UgdGhlIGRlZmF1bHQgY3NzIHN0eWxlc1xuICAgIC8vXG4gICAgLy8gRXhhbXBsZXM6XG4gICAgLy8gbGVnZW5kQ29sb3JzOiB7XG4gICAgLy8gICAgbWluOiBcImdyZWVuXCIsXG4gICAgLy8gICAgbWF4OiBcInJlZFwiLFxuICAgIC8vICAgIGVtcHR5OiBcIiNmZmZmZmZcIixcbiAgICAvLyAgICBiYXNlOiBcImdyZXlcIixcbiAgICAvLyAgICBvdmVyZmxvdzogXCJyZWRcIixcbiAgICAvLyAgICBjb2xvclNjYWxlcjogbnVsbCxcbiAgICAvLyB9XG4gICAgbGVnZW5kQ29sb3JzOiBudWxsLFxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gSElHSExJR0hUXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBMaXN0IG9mIGRhdGVzIHRvIGhpZ2hsaWdodFxuICAgIC8vIFZhbGlkIHZhbHVlczpcbiAgICAvLyAtIFtdOiBkb24ndCBoaWdobGlnaHQgYW55dGhpbmdcbiAgICAvLyAtIFwibm93XCI6IGhpZ2hsaWdodCB0aGUgY3VycmVudCBkYXRlXG4gICAgLy8gLSBhbiBhcnJheSBvZiBEYXRlIG9iamVjdHM6IGhpZ2hsaWdodCB0aGUgc3BlY2lmaWVkIGRhdGVzXG4gICAgaGlnaGxpZ2h0OiBbXSxcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFRFWFQgRk9STUFUVElORyAvIGkxOG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIE5hbWUgb2YgdGhlIGl0ZW1zIHRvIHJlcHJlc2VudCBpbiB0aGUgY2FsZW5kYXJcbiAgICBpdGVtTmFtZTogWydpdGVtJywgJ2l0ZW1zJ10sXG5cbiAgICAvLyBGb3JtYXR0aW5nIG9mIHRoZSBkb21haW4gbGFiZWxcbiAgICAvLyBAZGVmYXVsdDogbnVsbCwgd2lsbCB1c2UgdGhlIGZvcm1hdHRpbmcgYWNjb3JkaW5nIHRvIGRvbWFpbiB0eXBlXG4gICAgLy8gQWNjZXB0IGEgc3RyaW5nIHVzZWQgYXMgc3BlY2lmaWVyIGJ5IGQzLnRpbWUuZm9ybWF0KClcbiAgICAvLyBvciBhIGZ1bmN0aW9uXG4gICAgLy9cbiAgICAvLyBSZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvd2lraS9UaW1lLUZvcm1hdHRpbmdcbiAgICAvLyBmb3IgYWNjZXB0ZWQgZGF0ZSBmb3JtYXR0aW5nIHVzZWQgYnkgZDMudGltZS5mb3JtYXQoKVxuICAgIGRvbWFpbkxhYmVsRm9ybWF0OiBudWxsLFxuXG4gICAgLy8gRm9ybWF0dGluZyBvZiB0aGUgdGl0bGUgZGlzcGxheWVkIHdoZW4gaG92ZXJpbmcgYSBzdWJEb21haW4gY2VsbFxuICAgIHN1YkRvbWFpblRpdGxlRm9ybWF0OiB7XG4gICAgICBlbXB0eTogJ3tkYXRlfScsXG4gICAgICBmaWxsZWQ6ICd7Y291bnR9IHtuYW1lfSB7Y29ubmVjdG9yfSB7ZGF0ZX0nLFxuICAgIH0sXG5cbiAgICAvLyBGb3JtYXR0aW5nIG9mIHRoZSB7ZGF0ZX0gdXNlZCBpbiBzdWJEb21haW5UaXRsZUZvcm1hdFxuICAgIC8vIEBkZWZhdWx0OiBudWxsLCB3aWxsIHVzZSB0aGUgZm9ybWF0dGluZyBhY2NvcmRpbmcgdG8gc3ViRG9tYWluIHR5cGVcbiAgICAvLyBBY2NlcHQgYSBzdHJpbmcgdXNlZCBhcyBzcGVjaWZpZXIgYnkgZDMudGltZS5mb3JtYXQoKVxuICAgIC8vIG9yIGEgZnVuY3Rpb25cbiAgICAvL1xuICAgIC8vIFJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9kMy93aWtpL1RpbWUtRm9ybWF0dGluZ1xuICAgIC8vIGZvciBhY2NlcHRlZCBkYXRlIGZvcm1hdHRpbmcgdXNlZCBieSBkMy50aW1lLmZvcm1hdCgpXG4gICAgc3ViRG9tYWluRGF0ZUZvcm1hdDogbnVsbCxcblxuICAgIC8vIEZvcm1hdHRpbmcgb2YgdGhlIHRleHQgaW5zaWRlIGVhY2ggc3ViRG9tYWluIGNlbGxcbiAgICAvLyBAZGVmYXVsdDogbnVsbCwgbm8gdGV4dFxuICAgIC8vIEFjY2VwdCBhIHN0cmluZyB1c2VkIGFzIHNwZWNpZmllciBieSBkMy50aW1lLmZvcm1hdCgpXG4gICAgLy8gb3IgYSBmdW5jdGlvblxuICAgIC8vXG4gICAgLy8gUmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL3dpa2kvVGltZS1Gb3JtYXR0aW5nXG4gICAgLy8gZm9yIGFjY2VwdGVkIGRhdGUgZm9ybWF0dGluZyB1c2VkIGJ5IGQzLnRpbWUuZm9ybWF0KClcbiAgICBzdWJEb21haW5UZXh0Rm9ybWF0OiBudWxsLFxuXG4gICAgLy8gRm9ybWF0dGluZyBvZiB0aGUgdGl0bGUgZGlzcGxheWVkIHdoZW4gaG92ZXJpbmcgYSBsZWdlbmQgY2VsbFxuICAgIGxlZ2VuZFRpdGxlRm9ybWF0OiB7XG4gICAgICBsb3dlcjogdCgnbGVzcyB0aGFuIHttaW59IHtuYW1lfScpLFxuICAgICAgaW5uZXI6IHQoJ2JldHdlZW4ge2Rvd259IGFuZCB7dXB9IHtuYW1lfScpLFxuICAgICAgdXBwZXI6IHQoJ21vcmUgdGhhbiB7bWF4fSB7bmFtZX0nKSxcbiAgICB9LFxuXG4gICAgLy8gQW5pbWF0aW9uIGR1cmF0aW9uLCBpbiBtc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG5cbiAgICBuZXh0U2VsZWN0b3I6IGZhbHNlLFxuXG4gICAgcHJldmlvdXNTZWxlY3RvcjogZmFsc2UsXG5cbiAgICBpdGVtTmFtZXNwYWNlOiAnY2FsLWhlYXRtYXAnLFxuXG4gICAgdG9vbHRpcDogZmFsc2UsXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFVkVOVFMgQ0FMTEJBQ0tcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIENhbGxiYWNrIHdoZW4gY2xpY2tpbmcgb24gYSB0aW1lIGJsb2NrXG4gICAgb25DbGljazogbnVsbCxcblxuICAgIC8vIENhbGxiYWNrIGFmdGVyIHBhaW50aW5nIHRoZSBlbXB0eSBjYWxlbmRhclxuICAgIC8vIENhbiBiZSB1c2VkIHRvIHRyaWdnZXIgYW4gQVBJIGNhbGwsIG9uY2UgdGhlIGNhbGVuZGFyIGlzIHJlYWR5IHRvIGJlIGZpbGxlZFxuICAgIGFmdGVyTG9hZDogbnVsbCxcblxuICAgIC8vIENhbGxiYWNrIGFmdGVyIGxvYWRpbmcgdGhlIG5leHQgZG9tYWluIGluIHRoZSBjYWxlbmRhclxuICAgIGFmdGVyTG9hZE5leHREb21haW46IG51bGwsXG5cbiAgICAvLyBDYWxsYmFjayBhZnRlciBsb2FkaW5nIHRoZSBwcmV2aW91cyBkb21haW4gaW4gdGhlIGNhbGVuZGFyXG4gICAgYWZ0ZXJMb2FkUHJldmlvdXNEb21haW46IG51bGwsXG5cbiAgICAvLyBDYWxsYmFjayBhZnRlciBmaW5pc2hpbmcgYWxsIGFjdGlvbnMgb24gdGhlIGNhbGVuZGFyXG4gICAgb25Db21wbGV0ZTogbnVsbCxcblxuICAgIC8vIENhbGxiYWNrIGFmdGVyIGZldGNoaW5nIHRoZSBkYXRhcywgYnV0IGJlZm9yZSBhcHBseWluZyB0aGVtIHRvIHRoZSBjYWxlbmRhclxuICAgIC8vIFVzZWQgbWFpbmx5IHRvIGNvbnZlcnQgdGhlIGRhdGFzIGlmIHRoZXkncmUgbm90IGZvcm1hdHRlZCBsaWtlIGV4cGVjdGVkXG4gICAgLy8gVGFrZXMgdGhlIGZldGNoZWQgXCJkYXRhXCIgb2JqZWN0IGFzIGFyZ3VtZW50LCBtdXN0IHJldHVybiBhIGpzb24gb2JqZWN0XG4gICAgLy8gZm9ybWF0dGVkIGxpa2Uge3RpbWVzdGFtcDpjb3VudCwgdGltZXN0YW1wMjpjb3VudDJ9LFxuICAgIGFmdGVyTG9hZERhdGE6IGZ1bmN0aW9uICh0aW1lc3RhbXBzKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dhMHg2ZS9jYWwtaGVhdG1hcC9pc3N1ZXMvMTI2I2lzc3VlY29tbWVudC0zNzMzMDE4MDNcbiAgICAgIGNvbnN0IHN0ZFRpbWV6b25lT2Zmc2V0ID0gZGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IGphbiA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGp1bCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHN0ZFRpbWV6b25lT2Zmc2V0KG5ldyBEYXRlKCkpICogNjA7XG4gICAgICBsZXQgcmVzdWx0cyA9IHt9O1xuICAgICAgZm9yIChsZXQgdGltZXN0YW1wIGluIHRpbWVzdGFtcHMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aW1lc3RhbXBzW3RpbWVzdGFtcF07XG4gICAgICAgIHRpbWVzdGFtcCA9IHBhcnNlSW50KHRpbWVzdGFtcCwgMTApO1xuICAgICAgICByZXN1bHRzW3RpbWVzdGFtcCArIG9mZnNldF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsYmFjayB0cmlnZ2VyZWQgYWZ0ZXIgY2FsbGluZyBhbmQgY29tcGxldGluZyB1cGRhdGUoKS5cbiAgICBhZnRlclVwZGF0ZTogbnVsbCxcblxuICAgIC8vIENhbGxiYWNrIHRyaWdnZXJlZCBhZnRlciBjYWxsaW5nIG5leHQoKS5cbiAgICAvLyBUaGUgYHN0YXR1c2AgYXJndW1lbnQgaXMgZXF1YWwgdG8gdHJ1ZSBpZiB0aGVyZSBpcyBub1xuICAgIC8vIG1vcmUgbmV4dCBkb21haW4gdG8gbG9hZFxuICAgIC8vXG4gICAgLy8gVGhpcyBjYWxsYmFjayBpcyBhbHNvIGV4ZWN1dGVkIG9uY2UsIGFmdGVyIGNhbGxpbmcgcHJldmlvdXMoKSxcbiAgICAvLyBvbmx5IHdoZW4gdGhlIG1heCBkb21haW4gaXMgcmVhY2hlZFxuICAgIG9uTWF4RG9tYWluUmVhY2hlZDogbnVsbCxcblxuICAgIC8vIENhbGxiYWNrIHRyaWdnZXJlZCBhZnRlciBjYWxsaW5nIHByZXZpb3VzKCkuXG4gICAgLy8gVGhlIGBzdGF0dXNgIGFyZ3VtZW50IGlzIGVxdWFsIHRvIHRydWUgaWYgdGhlcmUgaXMgbm9cbiAgICAvLyBtb3JlIHByZXZpb3VzIGRvbWFpbiB0byBsb2FkXG4gICAgLy9cbiAgICAvLyBUaGlzIGNhbGxiYWNrIGlzIGFsc28gZXhlY3V0ZWQgb25jZSwgYWZ0ZXIgY2FsbGluZyBuZXh0KCksXG4gICAgLy8gb25seSB3aGVuIHRoZSBtaW4gZG9tYWluIGlzIHJlYWNoZWRcbiAgICBvbk1pbkRvbWFpblJlYWNoZWQ6IG51bGwsXG4gIH07XG5cbiAgdGhpcy5fZG9tYWluVHlwZSA9IHtcbiAgICBtaW46IHtcbiAgICAgIG5hbWU6ICdtaW51dGUnLFxuICAgICAgbGV2ZWw6IDEwLFxuICAgICAgbWF4SXRlbU51bWJlcjogNjAsXG4gICAgICBkZWZhdWx0Um93TnVtYmVyOiAxMCxcbiAgICAgIGRlZmF1bHRDb2x1bW5OdW1iZXI6IDYsXG4gICAgICByb3c6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldFN1YkRvbWFpblJvd051bWJlcihkKTtcbiAgICAgIH0sXG4gICAgICBjb2x1bW46IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldFN1YkRvbWFpbkNvbHVtbk51bWJlcihkKTtcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGQuZ2V0TWludXRlcygpIC8gc2VsZi5fZG9tYWluVHlwZS5taW4ucm93KGQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgeTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5nZXRNaW51dGVzKCkgJSBzZWxmLl9kb21haW5UeXBlLm1pbi5yb3coZCk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZm9ybWF0OiB7XG4gICAgICAgIGRhdGU6ICclSDolTSwgJUEgJUIgJS1lLCAlWScsXG4gICAgICAgIGxlZ2VuZDogJycsXG4gICAgICAgIGNvbm5lY3RvcjogJ2F0JyxcbiAgICAgIH0sXG4gICAgICBleHRyYWN0VW5pdDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICAgIGQuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICBkLmdldE1vbnRoKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksXG4gICAgICAgICAgZC5nZXRIb3VycygpLFxuICAgICAgICAgIGQuZ2V0TWludXRlcygpLFxuICAgICAgICApLmdldFRpbWUoKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBob3VyOiB7XG4gICAgICBuYW1lOiAnaG91cicsXG4gICAgICBsZXZlbDogMjAsXG4gICAgICBtYXhJdGVtTnVtYmVyOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKHNlbGYub3B0aW9ucy5kb21haW4pIHtcbiAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgcmV0dXJuIDI0O1xuICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgcmV0dXJuIDI0ICogNztcbiAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAyNCAqXG4gICAgICAgICAgICAgIChzZWxmLm9wdGlvbnMuZG9tYWluRHluYW1pY0RpbWVuc2lvblxuICAgICAgICAgICAgICAgID8gc2VsZi5nZXREYXlDb3VudEluTW9udGgoZClcbiAgICAgICAgICAgICAgICA6IDMxKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRSb3dOdW1iZXI6IDYsXG4gICAgICBkZWZhdWx0Q29sdW1uTnVtYmVyOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKHNlbGYub3B0aW9ucy5kb21haW4pIHtcbiAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYub3B0aW9ucy5kb21haW5EeW5hbWljRGltZW5zaW9uXG4gICAgICAgICAgICAgID8gc2VsZi5nZXREYXlDb3VudEluTW9udGgoZClcbiAgICAgICAgICAgICAgOiAzMTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJvdzogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluUm93TnVtYmVyKGQpO1xuICAgICAgfSxcbiAgICAgIGNvbHVtbjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluQ29sdW1uTnVtYmVyKGQpO1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5kb21haW4gPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY29sTGltaXQgPiAwIHx8IHNlbGYub3B0aW9ucy5yb3dMaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgKGQuZ2V0SG91cnMoKSArIChkLmdldERhdGUoKSAtIDEpICogMjQpIC9cbiAgICAgICAgICAgICAgICAgIHNlbGYuX2RvbWFpblR5cGUuaG91ci5yb3coZCksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBNYXRoLmZsb29yKGQuZ2V0SG91cnMoKSAvIHNlbGYuX2RvbWFpblR5cGUuaG91ci5yb3coZCkpICtcbiAgICAgICAgICAgICAgKGQuZ2V0RGF0ZSgpIC0gMSkgKiA0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5vcHRpb25zLmRvbWFpbiA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbExpbWl0ID4gMCB8fCBzZWxmLm9wdGlvbnMucm93TGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChkLmdldEhvdXJzKCkgKyBzZWxmLmdldFdlZWtEYXkoZCkgKiAyNCkgL1xuICAgICAgICAgICAgICAgICAgc2VsZi5fZG9tYWluVHlwZS5ob3VyLnJvdyhkKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoZC5nZXRIb3VycygpIC8gc2VsZi5fZG9tYWluVHlwZS5ob3VyLnJvdyhkKSkgK1xuICAgICAgICAgICAgICBzZWxmLmdldFdlZWtEYXkoZCkgKiA0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkLmdldEhvdXJzKCkgLyBzZWxmLl9kb21haW5UeXBlLmhvdXIucm93KGQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgeTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB2YXIgcCA9IGQuZ2V0SG91cnMoKTtcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbExpbWl0ID4gMCB8fCBzZWxmLm9wdGlvbnMucm93TGltaXQgPiAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYub3B0aW9ucy5kb21haW4pIHtcbiAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHAgKz0gKGQuZ2V0RGF0ZSgpIC0gMSkgKiAyNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgcCArPSBzZWxmLmdldFdlZWtEYXkoZCkgKiAyNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocCAlIHNlbGYuX2RvbWFpblR5cGUuaG91ci5yb3coZCkpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICBkYXRlOiAnJUhoLCAlQSAlQiAlLWUsICVZJyxcbiAgICAgICAgbGVnZW5kOiAnJUg6MDAnLFxuICAgICAgICBjb25uZWN0b3I6ICdhdCcsXG4gICAgICB9LFxuICAgICAgZXh0cmFjdFVuaXQ6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgICAgICBkLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgZC5nZXRNb250aCgpLFxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLFxuICAgICAgICAgIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgKS5nZXRUaW1lKCk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgZGF5OiB7XG4gICAgICBuYW1lOiAnZGF5JyxcbiAgICAgIGxldmVsOiAzMCxcbiAgICAgIG1heEl0ZW1OdW1iZXI6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoc2VsZi5vcHRpb25zLmRvbWFpbikge1xuICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYub3B0aW9ucy5kb21haW5EeW5hbWljRGltZW5zaW9uXG4gICAgICAgICAgICAgID8gc2VsZi5nZXREYXlDb3VudEluTW9udGgoZClcbiAgICAgICAgICAgICAgOiAzMTtcbiAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHJldHVybiBzZWxmLm9wdGlvbnMuZG9tYWluRHluYW1pY0RpbWVuc2lvblxuICAgICAgICAgICAgICA/IHNlbGYuZ2V0RGF5Q291bnRJblllYXIoZClcbiAgICAgICAgICAgICAgOiAzNjY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0Q29sdW1uTnVtYmVyOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICBkID0gbmV3IERhdGUoZCk7XG4gICAgICAgIHN3aXRjaCAoc2VsZi5vcHRpb25zLmRvbWFpbikge1xuICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYub3B0aW9ucy5kb21haW5EeW5hbWljRGltZW5zaW9uICYmXG4gICAgICAgICAgICAgICFzZWxmLm9wdGlvbnMudmVydGljYWxPcmllbnRhdGlvblxuICAgICAgICAgICAgICA/IHNlbGYuZ2V0V2Vla051bWJlcihcbiAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpICsgMSwgMCksXG4gICAgICAgICAgICAgICAgKSAtXG4gICAgICAgICAgICAgICAgICBzZWxmLmdldFdlZWtOdW1iZXIoZCkgK1xuICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICA6IDY7XG4gICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb25cbiAgICAgICAgICAgICAgPyBzZWxmLmdldFdlZWtOdW1iZXIobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAxMSwgMzEpKSAtXG4gICAgICAgICAgICAgICAgICBzZWxmLmdldFdlZWtOdW1iZXIobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwKSkgK1xuICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICA6IDU0O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdFJvd051bWJlcjogNyxcbiAgICAgIHJvdzogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluUm93TnVtYmVyKGQpO1xuICAgICAgfSxcbiAgICAgIGNvbHVtbjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluQ29sdW1uTnVtYmVyKGQpO1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgc3dpdGNoIChzZWxmLm9wdGlvbnMuZG9tYWluKSB7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRXZWVrRGF5KGQpIC8gc2VsZi5fZG9tYWluVHlwZS5kYXkucm93KGQpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbExpbWl0ID4gMCB8fCBzZWxmLm9wdGlvbnMucm93TGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgICAoZC5nZXREYXRlKCkgLSAxKSAvIHNlbGYuX2RvbWFpblR5cGUuZGF5LnJvdyhkKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRXZWVrTnVtYmVyKGQpIC1cbiAgICAgICAgICAgICAgICBzZWxmLmdldFdlZWtOdW1iZXIobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY29sTGltaXQgPiAwIHx8IHNlbGYub3B0aW9ucy5yb3dMaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAgIChzZWxmLmdldERheU9mWWVhcihkKSAtIDEpIC8gc2VsZi5fZG9tYWluVHlwZS5kYXkucm93KGQpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0V2Vla051bWJlcihkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdmFyIHAgPSBzZWxmLmdldFdlZWtEYXkoZCk7XG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb2xMaW1pdCA+IDAgfHwgc2VsZi5vcHRpb25zLnJvd0xpbWl0ID4gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChzZWxmLm9wdGlvbnMuZG9tYWluKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHAgPSBzZWxmLmdldERheU9mWWVhcihkKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHAgPSBzZWxmLmdldFdlZWtEYXkoZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBwID0gZC5nZXREYXRlKCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihwICUgc2VsZi5fZG9tYWluVHlwZS5kYXkucm93KGQpKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgZGF0ZTogJyVBICVCICUtZSwgJVknLFxuICAgICAgICBsZWdlbmQ6ICclZSAlYicsXG4gICAgICAgIGNvbm5lY3RvcjogJ29uJyxcbiAgICAgIH0sXG4gICAgICBleHRyYWN0VW5pdDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHdlZWs6IHtcbiAgICAgIG5hbWU6ICd3ZWVrJyxcbiAgICAgIGxldmVsOiA0MCxcbiAgICAgIG1heEl0ZW1OdW1iZXI6IDU0LFxuICAgICAgZGVmYXVsdENvbHVtbk51bWJlcjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgICAgICBzd2l0Y2ggKHNlbGYub3B0aW9ucy5kb21haW4pIHtcbiAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9kb21haW5UeXBlLndlZWsubWF4SXRlbU51bWJlcjtcbiAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb25cbiAgICAgICAgICAgICAgPyBzZWxmLmdldFdlZWtOdW1iZXIoXG4gICAgICAgICAgICAgICAgICBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSArIDEsIDApLFxuICAgICAgICAgICAgICAgICkgLSBzZWxmLmdldFdlZWtOdW1iZXIoZClcbiAgICAgICAgICAgICAgOiA1O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdFJvd051bWJlcjogMSxcbiAgICAgIHJvdzogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluUm93TnVtYmVyKGQpO1xuICAgICAgfSxcbiAgICAgIGNvbHVtbjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluQ29sdW1uTnVtYmVyKGQpO1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgc3dpdGNoIChzZWxmLm9wdGlvbnMuZG9tYWluKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRXZWVrTnVtYmVyKGQpIC8gc2VsZi5fZG9tYWluVHlwZS53ZWVrLnJvdyhkKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRNb250aFdlZWtOdW1iZXIoZCkgLyBzZWxmLl9kb21haW5UeXBlLndlZWsucm93KGQpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5nZXRXZWVrTnVtYmVyKGQpICUgc2VsZi5fZG9tYWluVHlwZS53ZWVrLnJvdyhkKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgZGF0ZTogJyVCIFdlZWsgIyVXJyxcbiAgICAgICAgbGVnZW5kOiAnJUIgV2VlayAjJVcnLFxuICAgICAgICBjb25uZWN0b3I6ICdpbicsXG4gICAgICB9LFxuICAgICAgZXh0cmFjdFVuaXQ6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgICAgIC8vIEFjY29yZGluZyB0byBJU08tODYwMSwgd2VlayBudW1iZXIgY29tcHV0YXRpb24gYXJlIGJhc2VkIG9uIHdlZWsgc3RhcnRpbmcgb24gTW9uZGF5XG4gICAgICAgIHZhciB3ZWVrRGF5ID0gZHQuZ2V0RGF5KCkgLSAoc2VsZi5vcHRpb25zLndlZWtTdGFydE9uTW9uZGF5ID8gMSA6IDApO1xuICAgICAgICBpZiAod2Vla0RheSA8IDApIHtcbiAgICAgICAgICB3ZWVrRGF5ID0gNjtcbiAgICAgICAgfVxuICAgICAgICBkdC5zZXREYXRlKGR0LmdldERhdGUoKSAtIHdlZWtEYXkpO1xuICAgICAgICByZXR1cm4gZHQuZ2V0VGltZSgpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIG1vbnRoOiB7XG4gICAgICBuYW1lOiAnbW9udGgnLFxuICAgICAgbGV2ZWw6IDUwLFxuICAgICAgbWF4SXRlbU51bWJlcjogMTIsXG4gICAgICBkZWZhdWx0Q29sdW1uTnVtYmVyOiAxMixcbiAgICAgIGRlZmF1bHRSb3dOdW1iZXI6IDEsXG4gICAgICByb3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluUm93TnVtYmVyKCk7XG4gICAgICB9LFxuICAgICAgY29sdW1uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmdldFN1YkRvbWFpbkNvbHVtbk51bWJlcigpO1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZC5nZXRNb250aCgpIC8gc2VsZi5fZG9tYWluVHlwZS5tb250aC5yb3coZCkpO1xuICAgICAgICB9LFxuICAgICAgICB5OiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmdldE1vbnRoKCkgJSBzZWxmLl9kb21haW5UeXBlLm1vbnRoLnJvdyhkKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgZGF0ZTogJyVCICVZJyxcbiAgICAgICAgbGVnZW5kOiAnJUInLFxuICAgICAgICBjb25uZWN0b3I6ICdpbicsXG4gICAgICB9LFxuICAgICAgZXh0cmFjdFVuaXQ6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSkuZ2V0VGltZSgpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHllYXI6IHtcbiAgICAgIG5hbWU6ICd5ZWFyJyxcbiAgICAgIGxldmVsOiA2MCxcbiAgICAgIHJvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLnJvd0xpbWl0IHx8IDE7XG4gICAgICB9LFxuICAgICAgY29sdW1uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLm9wdGlvbnMuY29sTGltaXQgfHwgMTtcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0sXG4gICAgICAgIHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgZGF0ZTogJyVZJyxcbiAgICAgICAgbGVnZW5kOiAnJVknLFxuICAgICAgICBjb25uZWN0b3I6ICdpbicsXG4gICAgICB9LFxuICAgICAgZXh0cmFjdFVuaXQ6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCkpLmdldFRpbWUoKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcblxuICBmb3IgKHZhciB0eXBlIGluIHRoaXMuX2RvbWFpblR5cGUpIHtcbiAgICBpZiAodGhpcy5fZG9tYWluVHlwZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgdmFyIGQgPSB0aGlzLl9kb21haW5UeXBlW3R5cGVdO1xuICAgICAgdGhpcy5fZG9tYWluVHlwZVsneF8nICsgdHlwZV0gPSB7XG4gICAgICAgIG5hbWU6ICd4XycgKyB0eXBlLFxuICAgICAgICBsZXZlbDogZC50eXBlLFxuICAgICAgICBtYXhJdGVtTnVtYmVyOiBkLm1heEl0ZW1OdW1iZXIsXG4gICAgICAgIGRlZmF1bHRSb3dOdW1iZXI6IGQuZGVmYXVsdFJvd051bWJlcixcbiAgICAgICAgZGVmYXVsdENvbHVtbk51bWJlcjogZC5kZWZhdWx0Q29sdW1uTnVtYmVyLFxuICAgICAgICByb3c6IGQuY29sdW1uLFxuICAgICAgICBjb2x1bW46IGQucm93LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IGQucG9zaXRpb24ueSxcbiAgICAgICAgICB5OiBkLnBvc2l0aW9uLngsXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZC5mb3JtYXQsXG4gICAgICAgIGV4dHJhY3RVbml0OiBkLmV4dHJhY3RVbml0LFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWNvcmQgdGhlIGFkZHJlc3Mgb2YgdGhlIGxhc3QgaW5zZXJ0ZWQgZG9tYWluIHdoZW4gYnJvd3NpbmdcbiAgdGhpcy5sYXN0SW5zZXJ0ZWRTdmcgPSBudWxsO1xuXG4gIHRoaXMuX2NvbXBsZXRlZCA9IGZhbHNlO1xuXG4gIC8vIFJlY29yZCBhbGwgdGhlIHZhbGlkIGRvbWFpbnNcbiAgLy8gRWFjaCBkb21haW4gdmFsdWUgaXMgYSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gIHRoaXMuX2RvbWFpbnMgPSBkMy5tYXAoKTtcblxuICB0aGlzLmdyYXBoRGltID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgfTtcblxuICB0aGlzLmxlZ2VuZERpbSA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gIH07XG5cbiAgdGhpcy5OQVZJR0FURV9MRUZUID0gMTtcbiAgdGhpcy5OQVZJR0FURV9SSUdIVCA9IDI7XG5cbiAgLy8gVmFyaW91cyB1cGRhdGUgbW9kZSB3aGVuIHVzaW5nIHRoZSB1cGRhdGUoKSBBUElcbiAgdGhpcy5SRVNFVF9BTExfT05fVVBEQVRFID0gMDtcbiAgdGhpcy5SRVNFVF9TSU5HTEVfT05fVVBEQVRFID0gMTtcbiAgdGhpcy5BUFBFTkRfT05fVVBEQVRFID0gMjtcblxuICB0aGlzLkRFRkFVTFRfTEVHRU5EX01BUkdJTiA9IDEwO1xuXG4gIHRoaXMucm9vdCA9IG51bGw7XG4gIHRoaXMudG9vbHRpcCA9IG51bGw7XG5cbiAgdGhpcy5fbWF4RG9tYWluUmVhY2hlZCA9IGZhbHNlO1xuICB0aGlzLl9taW5Eb21haW5SZWFjaGVkID0gZmFsc2U7XG5cbiAgdGhpcy5kb21haW5Qb3NpdGlvbiA9IG5ldyBEb21haW5Qb3NpdGlvbigpO1xuICB0aGlzLkxlZ2VuZCA9IG51bGw7XG4gIHRoaXMubGVnZW5kU2NhbGUgPSBudWxsO1xuXG4gIC8vIExpc3Qgb2YgZG9tYWlucyB0aGF0IGFyZSBza2lwcGVkIGJlY2F1c2Ugb2YgRFNUXG4gIC8vIEFsbCB0aW1lcyBiZWxvbmdpbmcgdG8gdGhlc2UgZG9tYWlucyBzaG91bGQgYmUgcmUtYXNzaWduZWQgdG8gdGhlIHByZXZpb3VzIGRvbWFpblxuICB0aGlzLkRTVERvbWFpbiA9IFtdO1xuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHRoZSBncmFwaCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICogQHJldHVybiBib29sIFRydWUgaWYgdGhlIGNhbGVuZGFyIGlzIGNyZWF0ZWRcbiAgICovXG4gIHRoaXMuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZlxuICAgICAgLmdldERvbWFpbihzZWxmLm9wdGlvbnMuc3RhcnQpXG4gICAgICAubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmdldFRpbWUoKTtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHNlbGYuX2RvbWFpbnMuc2V0KFxuICAgICAgICAgIGQsXG4gICAgICAgICAgc2VsZi5nZXRTdWJEb21haW4oZCkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0OiBzZWxmLl9kb21haW5UeXBlW3NlbGYub3B0aW9ucy5zdWJEb21haW5dLmV4dHJhY3RVbml0KGQpLFxuICAgICAgICAgICAgICB2OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgc2VsZi5yb290ID0gZDNcbiAgICAgIC5zZWxlY3Qoc2VsZi5vcHRpb25zLml0ZW1TZWxlY3RvcilcbiAgICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnY2FsLWhlYXRtYXAtY29udGFpbmVyJyk7XG5cbiAgICBzZWxmLnJvb3QuYXR0cigneCcsIDApLmF0dHIoJ3knLCAwKS5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2NsYXNzJywgJ2dyYXBoJyk7XG5cbiAgICBzZWxmLkxlZ2VuZCA9IG5ldyBMZWdlbmQoc2VsZik7XG5cbiAgICBpZiAoc2VsZi5vcHRpb25zLnBhaW50T25Mb2FkKSB7XG4gICAgICBfaW5pdENhbGVuZGFyKCk7XG4gICAgfVxuICAgIHNlbGYucm9vdC5jYWxsKHNlbGYudGlwKTtcbiAgICBzZWxmLnJvb3QuY2FsbChzZWxmLmxlZ2VuZFRpcCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBfaW5pdENhbGVuZGFyKCkge1xuICAgIHNlbGYudmVydGljYWxEb21haW5MYWJlbCA9XG4gICAgICBzZWxmLm9wdGlvbnMubGFiZWwucG9zaXRpb24gPT09ICd0b3AnIHx8XG4gICAgICBzZWxmLm9wdGlvbnMubGFiZWwucG9zaXRpb24gPT09ICdib3R0b20nO1xuXG4gICAgc2VsZi5kb21haW5WZXJ0aWNhbExhYmVsSGVpZ2h0ID1cbiAgICAgIHNlbGYub3B0aW9ucy5sYWJlbC5oZWlnaHQgPT09IG51bGxcbiAgICAgICAgPyBNYXRoLm1heCgyNSwgc2VsZi5vcHRpb25zLmNlbGxTaXplICogMilcbiAgICAgICAgOiBzZWxmLm9wdGlvbnMubGFiZWwuaGVpZ2h0O1xuICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggPSAwO1xuXG4gICAgaWYgKFxuICAgICAgc2VsZi5vcHRpb25zLmRvbWFpbkxhYmVsRm9ybWF0ID09PSAnJyAmJlxuICAgICAgc2VsZi5vcHRpb25zLmxhYmVsLmhlaWdodCA9PT0gbnVsbFxuICAgICkge1xuICAgICAgc2VsZi5kb21haW5WZXJ0aWNhbExhYmVsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGYudmVydGljYWxEb21haW5MYWJlbCkge1xuICAgICAgc2VsZi5kb21haW5WZXJ0aWNhbExhYmVsSGVpZ2h0ID0gMDtcbiAgICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggPSBzZWxmLm9wdGlvbnMubGFiZWwud2lkdGg7XG4gICAgfVxuXG4gICAgc2VsZi5wYWludCgpO1xuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4gICAgLy8gQVRUQUNISU5HIERPTUFJTiBOQVZJR0FUSU9OIEVWRU5UICAgICAgICAgICAgICAgICAgICAvL1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuICAgIGlmIChzZWxmLm9wdGlvbnMubmV4dFNlbGVjdG9yICE9PSBmYWxzZSkge1xuICAgICAgZDMuc2VsZWN0KHNlbGYub3B0aW9ucy5uZXh0U2VsZWN0b3IpLm9uKFxuICAgICAgICAnY2xpY2suJyArIHNlbGYub3B0aW9ucy5pdGVtTmFtZXNwYWNlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gc2VsZi5sb2FkTmV4dERvbWFpbigxKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYub3B0aW9ucy5wcmV2aW91c1NlbGVjdG9yICE9PSBmYWxzZSkge1xuICAgICAgZDMuc2VsZWN0KHNlbGYub3B0aW9ucy5wcmV2aW91c1NlbGVjdG9yKS5vbihcbiAgICAgICAgJ2NsaWNrLicgKyBzZWxmLm9wdGlvbnMuaXRlbU5hbWVzcGFjZSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGYubG9hZFByZXZpb3VzRG9tYWluKDEpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzZWxmLkxlZ2VuZC5yZWRyYXcoXG4gICAgICBzZWxmLmdyYXBoRGltLndpZHRoIC1cbiAgICAgICAgc2VsZi5vcHRpb25zLmRvbWFpbkd1dHRlciAtXG4gICAgICAgIHNlbGYub3B0aW9ucy5jZWxsUGFkZGluZyxcbiAgICApO1xuICAgIHNlbGYuYWZ0ZXJMb2FkKCk7XG5cbiAgICB2YXIgZG9tYWlucyA9IHNlbGYuZ2V0RG9tYWluS2V5cygpO1xuXG4gICAgLy8gRmlsbCB0aGUgZ3JhcGggd2l0aCBzb21lIGRhdGFzXG4gICAgaWYgKHNlbGYub3B0aW9ucy5sb2FkT25Jbml0KSB7XG4gICAgICBzZWxmLmdldERhdGFzKFxuICAgICAgICBzZWxmLm9wdGlvbnMuZGF0YSxcbiAgICAgICAgbmV3IERhdGUoZG9tYWluc1swXSksXG4gICAgICAgIHNlbGYuZ2V0U3ViRG9tYWluKGRvbWFpbnNbZG9tYWlucy5sZW5ndGggLSAxXSkucG9wKCksXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLmZpbGwoKTtcbiAgICAgICAgICBzZWxmLm9uQ29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYub25Db21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHNlbGYuY2hlY2tJZk1pbkRvbWFpbklzUmVhY2hlZChkb21haW5zWzBdKTtcbiAgICBzZWxmLmNoZWNrSWZNYXhEb21haW5Jc1JlYWNoZWQoc2VsZi5nZXROZXh0RG9tYWluKCkuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGRvbWFpbiBibG9jaywgd2l0aG91dCB0aGUgZG9tYWluIGd1dHRlclxuICAvLyBAcGFyYW0gaW50IGQgRG9tYWluIHN0YXJ0IHRpbWVzdGFtcFxuICBmdW5jdGlvbiB3KGQsIG91dGVyKSB7XG4gICAgdmFyIHdpZHRoID1cbiAgICAgIHNlbGYub3B0aW9ucy5jZWxsU2l6ZSAqXG4gICAgICAgIHNlbGYuX2RvbWFpblR5cGVbc2VsZi5vcHRpb25zLnN1YkRvbWFpbl0uY29sdW1uKGQpICtcbiAgICAgIHNlbGYub3B0aW9ucy5jZWxsUGFkZGluZyAqXG4gICAgICAgIHNlbGYuX2RvbWFpblR5cGVbc2VsZi5vcHRpb25zLnN1YkRvbWFpbl0uY29sdW1uKGQpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIG91dGVyID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gKHdpZHRoICs9XG4gICAgICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggK1xuICAgICAgICBzZWxmLm9wdGlvbnMuZG9tYWluR3V0dGVyICtcbiAgICAgICAgc2VsZi5vcHRpb25zLmRvbWFpbk1hcmdpblsxXSArXG4gICAgICAgIHNlbGYub3B0aW9ucy5kb21haW5NYXJnaW5bM10pO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgZG9tYWluIGJsb2NrLCB3aXRob3V0IHRoZSBkb21haW4gZ3V0dGVyXG4gIGZ1bmN0aW9uIGgoZCwgb3V0ZXIpIHtcbiAgICB2YXIgaGVpZ2h0ID1cbiAgICAgIHNlbGYub3B0aW9ucy5jZWxsU2l6ZSAqIHNlbGYuX2RvbWFpblR5cGVbc2VsZi5vcHRpb25zLnN1YkRvbWFpbl0ucm93KGQpICtcbiAgICAgIHNlbGYub3B0aW9ucy5jZWxsUGFkZGluZyAqXG4gICAgICAgIHNlbGYuX2RvbWFpblR5cGVbc2VsZi5vcHRpb25zLnN1YkRvbWFpbl0ucm93KGQpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIG91dGVyID09PSB0cnVlKSB7XG4gICAgICBoZWlnaHQgKz1cbiAgICAgICAgc2VsZi5vcHRpb25zLmRvbWFpbkd1dHRlciArXG4gICAgICAgIHNlbGYuZG9tYWluVmVydGljYWxMYWJlbEhlaWdodCArXG4gICAgICAgIHNlbGYub3B0aW9ucy5kb21haW5NYXJnaW5bMF0gK1xuICAgICAgICBzZWxmLm9wdGlvbnMuZG9tYWluTWFyZ2luWzJdO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBpbnQgbmF2aWdhdGlvbkRpclxuICAgKi9cbiAgdGhpcy5wYWludCA9IGZ1bmN0aW9uIChuYXZpZ2F0aW9uRGlyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbmF2aWdhdGlvbkRpciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFBhaW50aW5nIGFsbCB0aGUgZG9tYWluc1xuICAgIHZhciBkb21haW5TdmcgPSBzZWxmLnJvb3RcbiAgICAgIC5zZWxlY3QoJy5ncmFwaCcpXG4gICAgICAuc2VsZWN0QWxsKCcuZ3JhcGgtZG9tYWluJylcbiAgICAgIC5kYXRhKFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLmdldERvbWFpbktleXMoKTtcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdGlvbkRpciA9PT0gc2VsZi5OQVZJR0FURV9MRUZUID8gZGF0YS5yZXZlcnNlKCkgOiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB2YXIgZW50ZXJpbmdEb21haW5EaW0gPSAwO1xuICAgIHZhciBleGl0aW5nRG9tYWluRGltID0gMDtcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuICAgIC8vIFBBSU5USU5HIERPTUFJTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgICB2YXIgc3ZnID0gZG9tYWluU3ZnXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB3KGQsIHRydWUpO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gaChkLCB0cnVlKTtcbiAgICAgIH0pXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnZlcnRpY2FsT3JpZW50YXRpb24pIHtcbiAgICAgICAgICBzZWxmLmdyYXBoRGltLndpZHRoID0gTWF0aC5tYXgoc2VsZi5ncmFwaERpbS53aWR0aCwgdyhkLCB0cnVlKSk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGdldERvbWFpblBvc2l0aW9uKGQsIHNlbGYuZ3JhcGhEaW0sICd3aWR0aCcsIHcoZCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0aWNhbE9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGdldERvbWFpblBvc2l0aW9uKGQsIHNlbGYuZ3JhcGhEaW0sICdoZWlnaHQnLCBoKGQsIHRydWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmdyYXBoRGltLmhlaWdodCA9IE1hdGgubWF4KHNlbGYuZ3JhcGhEaW0uaGVpZ2h0LCBoKGQsIHRydWUpKTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBjbGFzc25hbWUgPSAnZ3JhcGgtZG9tYWluJztcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShkKTtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmRvbWFpbikge1xuICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgY2xhc3NuYW1lICs9ICcgaF8nICsgZGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2xhc3NuYW1lICs9ICcgZF8nICsgZGF0ZS5nZXREYXRlKCkgKyAnIGR5XycgKyBkYXRlLmdldERheSgpO1xuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgIGNsYXNzbmFtZSArPSAnIHdfJyArIHNlbGYuZ2V0V2Vla051bWJlcihkYXRlKTtcbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgY2xhc3NuYW1lICs9ICcgbV8nICsgKGRhdGUuZ2V0TW9udGgoKSArIDEpO1xuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIGNsYXNzbmFtZSArPSAnIHlfJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NuYW1lO1xuICAgICAgfSk7XG4gICAgc2VsZi5sYXN0SW5zZXJ0ZWRTdmcgPSBzdmc7XG5cbiAgICBmdW5jdGlvbiBnZXREb21haW5Qb3NpdGlvbihkb21haW5JbmRleCwgZ3JhcGhEaW0sIGF4aXMsIGRvbWFpbkRpbSkge1xuICAgICAgdmFyIHRtcCA9IDA7XG4gICAgICBzd2l0Y2ggKG5hdmlnYXRpb25EaXIpIHtcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICB0bXAgPSBncmFwaERpbVtheGlzXTtcblxuICAgICAgICAgIGdyYXBoRGltW2F4aXNdICs9IGRvbWFpbkRpbTtcbiAgICAgICAgICBzZWxmLmRvbWFpblBvc2l0aW9uLnNldFBvc2l0aW9uKGRvbWFpbkluZGV4LCB0bXApO1xuICAgICAgICAgIHJldHVybiB0bXA7XG5cbiAgICAgICAgY2FzZSBzZWxmLk5BVklHQVRFX1JJR0hUOlxuICAgICAgICAgIHNlbGYuZG9tYWluUG9zaXRpb24uc2V0UG9zaXRpb24oZG9tYWluSW5kZXgsIGdyYXBoRGltW2F4aXNdKTtcblxuICAgICAgICAgIGVudGVyaW5nRG9tYWluRGltID0gZG9tYWluRGltO1xuICAgICAgICAgIGV4aXRpbmdEb21haW5EaW0gPSBzZWxmLmRvbWFpblBvc2l0aW9uLmdldFBvc2l0aW9uRnJvbUluZGV4KDEpO1xuXG4gICAgICAgICAgc2VsZi5kb21haW5Qb3NpdGlvbi5zaGlmdFJpZ2h0QnkoZXhpdGluZ0RvbWFpbkRpbSk7XG4gICAgICAgICAgcmV0dXJuIGdyYXBoRGltW2F4aXNdO1xuXG4gICAgICAgIGNhc2Ugc2VsZi5OQVZJR0FURV9MRUZUOlxuICAgICAgICAgIHRtcCA9IC1kb21haW5EaW07XG5cbiAgICAgICAgICBlbnRlcmluZ0RvbWFpbkRpbSA9IC10bXA7XG4gICAgICAgICAgZXhpdGluZ0RvbWFpbkRpbSA9IGdyYXBoRGltW2F4aXNdIC0gc2VsZi5kb21haW5Qb3NpdGlvbi5nZXRMYXN0KCk7XG5cbiAgICAgICAgICBzZWxmLmRvbWFpblBvc2l0aW9uLnNldFBvc2l0aW9uKGRvbWFpbkluZGV4LCB0bXApO1xuICAgICAgICAgIHNlbGYuZG9tYWluUG9zaXRpb24uc2hpZnRMZWZ0QnkoZW50ZXJpbmdEb21haW5EaW0pO1xuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3ZnXG4gICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB3KGQsIHRydWUpIC0gb3B0aW9ucy5kb21haW5HdXR0ZXIgLSBvcHRpb25zLmNlbGxQYWRkaW5nO1xuICAgICAgfSlcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gaChkLCB0cnVlKSAtIG9wdGlvbnMuZG9tYWluR3V0dGVyIC0gb3B0aW9ucy5jZWxsUGFkZGluZztcbiAgICAgIH0pXG4gICAgICAuYXR0cignY2xhc3MnLCAnZG9tYWluLWJhY2tncm91bmQnKTtcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuICAgIC8vIFBBSU5USU5HIFNVQkRPTUFJTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbiAgICB2YXIgc3ViRG9tYWluU3ZnR3JvdXAgPSBzdmdcbiAgICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubGFiZWwucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHJldHVybiBzZWxmLmRvbWFpbkhvcml6b250YWxMYWJlbFdpZHRoICsgb3B0aW9ucy5kb21haW5NYXJnaW5bM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZG9tYWluTWFyZ2luWzNdO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxhYmVsLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIHJldHVybiBzZWxmLmRvbWFpblZlcnRpY2FsTGFiZWxIZWlnaHQgKyBvcHRpb25zLmRvbWFpbk1hcmdpblswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kb21haW5NYXJnaW5bMF07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYXR0cignY2xhc3MnLCAnZ3JhcGgtc3ViZG9tYWluLWdyb3VwJyk7XG4gICAgdmFyIHJlY3QgPSBzdWJEb21haW5TdmdHcm91cFxuICAgICAgLnNlbGVjdEFsbCgnZycpXG4gICAgICAuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fZG9tYWlucy5nZXQoZCk7XG4gICAgICB9KVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoJ2cnKTtcbiAgICByZWN0XG4gICAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgJ2dyYXBoLXJlY3QnICtcbiAgICAgICAgICBzZWxmLmdldEhpZ2hsaWdodENsYXNzTmFtZShkLnQpICtcbiAgICAgICAgICAob3B0aW9ucy5vbkNsaWNrICE9PSBudWxsID8gJyBob3Zlcl9jdXJzb3InIDogJycpXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3dpZHRoJywgb3B0aW9ucy5jZWxsU2l6ZSlcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBvcHRpb25zLmNlbGxTaXplKVxuICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gc2VsZi5wb3NpdGlvblN1YkRvbWFpblgoZC50KTtcbiAgICAgIH0pXG4gICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnBvc2l0aW9uU3ViRG9tYWluWShkLnQpO1xuICAgICAgfSlcbiAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vbkNsaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYub25DbGljayhuZXcgRGF0ZShkLnQpLCBkLnYpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhbGwoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAob3B0aW9ucy5jZWxsUmFkaXVzID4gMCkge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICAgICAgLmF0dHIoJ3J4Jywgb3B0aW9ucy5jZWxsUmFkaXVzKVxuICAgICAgICAgICAgLmF0dHIoJ3J5Jywgb3B0aW9ucy5jZWxsUmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzZWxmLmxlZ2VuZFNjYWxlICE9PSBudWxsICYmXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRDb2xvcnMgIT09IG51bGwgJiZcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZENvbG9ycy5oYXNPd25Qcm9wZXJ0eSgnYmFzZScpXG4gICAgICAgICkge1xuICAgICAgICAgIHNlbGVjdGlvbi5hdHRyKCdmaWxsJywgb3B0aW9ucy5sZWdlbmRDb2xvcnMuYmFzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwKSB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgIHNlbGYudGlwLnNob3coZCwgdGhpcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgc2VsZi50aXAuaGlkZShkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8vIEFwcGVuZGluZyBhIHRpdGxlIHRvIGVhY2ggc3ViZG9tYWluXG4gICAgaWYgKCFvcHRpb25zLnRvb2x0aXApIHtcbiAgICAgIHJlY3QuYXBwZW5kKCd0aXRsZScpLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShuZXcgRGF0ZShkLnQpLCBvcHRpb25zLnN1YkRvbWFpbkRhdGVGb3JtYXQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4gICAgLy8gUEFJTlRJTkcgTEFCRUwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuICAgIGlmIChvcHRpb25zLmRvbWFpbkxhYmVsRm9ybWF0ICE9PSAnJykge1xuICAgICAgc3ZnXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZ3JhcGgtbGFiZWwnKVxuICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdmFyIHkgPSBvcHRpb25zLmRvbWFpbk1hcmdpblswXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMubGFiZWwucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgIHkgKz0gc2VsZi5kb21haW5WZXJ0aWNhbExhYmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICB5ICs9IGgoZCkgKyBzZWxmLmRvbWFpblZlcnRpY2FsTGFiZWxIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB5ICtcbiAgICAgICAgICAgIG9wdGlvbnMubGFiZWwub2Zmc2V0LnkgKlxuICAgICAgICAgICAgICAoKG9wdGlvbnMubGFiZWwucm90YXRlID09PSAncmlnaHQnICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sYWJlbC5wb3NpdGlvbiA9PT0gJ3JpZ2h0JykgfHxcbiAgICAgICAgICAgICAgKG9wdGlvbnMubGFiZWwucm90YXRlID09PSAnbGVmdCcgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxhYmVsLnBvc2l0aW9uID09PSAnbGVmdCcpXG4gICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgIDogMSlcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdmFyIHggPSBvcHRpb25zLmRvbWFpbk1hcmdpblszXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMubGFiZWwucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgeCArPSB3KGQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICB4ICs9IHcoZCkgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLmxhYmVsLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB4ICtcbiAgICAgICAgICAgICAgc2VsZi5kb21haW5Ib3Jpem9udGFsTGFiZWxXaWR0aCAtXG4gICAgICAgICAgICAgIG9wdGlvbnMubGFiZWwub2Zmc2V0LnggKlxuICAgICAgICAgICAgICAgIChvcHRpb25zLmxhYmVsLnJvdGF0ZSA9PT0gJ3JpZ2h0JyA/IC0xIDogMSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB4ICsgb3B0aW9ucy5sYWJlbC5vZmZzZXQueDtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5sYWJlbC5hbGlnbikge1xuICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgIHJldHVybiAnc3RhcnQnO1xuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnZlcnRpY2FsRG9tYWluTGFiZWwgPyAnbWlkZGxlJyA6ICd0b3AnO1xuICAgICAgICB9KVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdERhdGUobmV3IERhdGUoZCksIG9wdGlvbnMuZG9tYWluTGFiZWxGb3JtYXQpO1xuICAgICAgICB9KVxuICAgICAgICAuY2FsbChkb21haW5Sb3RhdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvbWFpblJvdGF0ZShzZWxlY3Rpb24pIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5sYWJlbC5yb3RhdGUpIHtcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHNlbGVjdGlvbi5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIHMgPSAncm90YXRlKDkwKSwgJztcbiAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5sYWJlbC5wb3NpdGlvbikge1xuICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgcyArPSAndHJhbnNsYXRlKC0nICsgdyhkKSArICcgLCAtJyArIHcoZCkgKyAnKSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHMgKz0gJ3RyYW5zbGF0ZSgwLCAtJyArIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggKyAnKSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBzZWxlY3Rpb24uYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBzID0gJ3JvdGF0ZSgyNzApLCAnO1xuICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zLmxhYmVsLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBzICs9XG4gICAgICAgICAgICAgICAgICAndHJhbnNsYXRlKC0nICtcbiAgICAgICAgICAgICAgICAgICh3KGQpICsgc2VsZi5kb21haW5Ib3Jpem9udGFsTGFiZWxXaWR0aCkgK1xuICAgICAgICAgICAgICAgICAgJyAsICcgK1xuICAgICAgICAgICAgICAgICAgdyhkKSArXG4gICAgICAgICAgICAgICAgICAnKSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHMgKz1cbiAgICAgICAgICAgICAgICAgICd0cmFuc2xhdGUoLScgK1xuICAgICAgICAgICAgICAgICAgc2VsZi5kb21haW5Ib3Jpem9udGFsTGFiZWxXaWR0aCArXG4gICAgICAgICAgICAgICAgICAnICwgJyArXG4gICAgICAgICAgICAgICAgICBzZWxmLmRvbWFpbkhvcml6b250YWxMYWJlbFdpZHRoICtcbiAgICAgICAgICAgICAgICAgICcpJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4gICAgLy8gUEFJTlRJTkcgRE9NQUlOIFNVQkRPTUFJTiBDT05URU5UICAgICAgICAgICAgICAgICAgICAvL1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuICAgIGlmIChvcHRpb25zLnN1YkRvbWFpblRleHRGb3JtYXQgIT09IG51bGwpIHtcbiAgICAgIHJlY3RcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICdzdWJkb21haW4tdGV4dCcgKyBzZWxmLmdldEhpZ2hsaWdodENsYXNzTmFtZShkLnQpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYucG9zaXRpb25TdWJEb21haW5YKGQudCkgKyBvcHRpb25zLmNlbGxTaXplIC8gMjtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLnBvc2l0aW9uU3ViRG9tYWluWShkLnQpICsgb3B0aW9ucy5jZWxsU2l6ZSAvIDI7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAuYXR0cignZG9taW5hbnQtYmFzZWxpbmUnLCAnY2VudHJhbCcpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShuZXcgRGF0ZShkLnQpLCBvcHRpb25zLnN1YkRvbWFpblRleHRGb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbiAgICAvLyBBTklNQVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgICBpZiAobmF2aWdhdGlvbkRpciAhPT0gZmFsc2UpIHtcbiAgICAgIGRvbWFpblN2Z1xuICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgIC5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKVxuICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMudmVydGljYWxPcmllbnRhdGlvblxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IHNlbGYuZG9tYWluUG9zaXRpb24uZ2V0UG9zaXRpb24oZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy52ZXJ0aWNhbE9yaWVudGF0aW9uXG4gICAgICAgICAgICA/IHNlbGYuZG9tYWluUG9zaXRpb24uZ2V0UG9zaXRpb24oZClcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBXaWR0aCA9IHNlbGYuZ3JhcGhEaW0ud2lkdGg7XG4gICAgdmFyIHRlbXBIZWlnaHQgPSBzZWxmLmdyYXBoRGltLmhlaWdodDtcblxuICAgIGlmIChvcHRpb25zLnZlcnRpY2FsT3JpZW50YXRpb24pIHtcbiAgICAgIHNlbGYuZ3JhcGhEaW0uaGVpZ2h0ICs9IGVudGVyaW5nRG9tYWluRGltIC0gZXhpdGluZ0RvbWFpbkRpbTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5ncmFwaERpbS53aWR0aCArPSBlbnRlcmluZ0RvbWFpbkRpbSAtIGV4aXRpbmdEb21haW5EaW07XG4gICAgfVxuXG4gICAgLy8gQXQgdGhlIHRpbWUgb2YgZXhpdCwgZG9tYWluc1dpZHRoIGFuZCBkb21haW5zSGVpZ2h0IGFscmVhZHkgYXV0b21hdGljYWxseSBzaGlmdGVkXG4gICAgZG9tYWluU3ZnXG4gICAgICAuZXhpdCgpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24ob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbilcbiAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGljYWxPcmllbnRhdGlvbikge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAobmF2aWdhdGlvbkRpcikge1xuICAgICAgICAgICAgY2FzZSBzZWxmLk5BVklHQVRFX0xFRlQ6XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihzZWxmLmdyYXBoRGltLndpZHRoLCB0ZW1wV2lkdGgpO1xuICAgICAgICAgICAgY2FzZSBzZWxmLk5BVklHQVRFX1JJR0hUOlxuICAgICAgICAgICAgICByZXR1cm4gLXcoZCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0aWNhbE9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgc3dpdGNoIChuYXZpZ2F0aW9uRGlyKSB7XG4gICAgICAgICAgICBjYXNlIHNlbGYuTkFWSUdBVEVfTEVGVDpcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHNlbGYuZ3JhcGhEaW0uaGVpZ2h0LCB0ZW1wSGVpZ2h0KTtcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5OQVZJR0FURV9SSUdIVDpcbiAgICAgICAgICAgICAgcmV0dXJuIC1oKGQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5yZW1vdmUoKTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgcm9vdCBjb250YWluZXJcbiAgICBzZWxmLnJlc2l6ZSgpO1xuICB9O1xufTtcblxuQ2FsSGVhdE1hcC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbmQgbWVyZ2UgdXNlciBzZXR0aW5ncyB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBVc2VyIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge2Jvb2x9IEZhbHNlIGlmIHNldHRpbmdzIGNvbnRhaW5zIGVycm9yXG4gICAqL1xuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czpmYWxzZSAqL1xuICBpbml0OiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gKHBhcmVudC5vcHRpb25zID0gbWVyZ2VSZWN1cnNpdmUocGFyZW50Lm9wdGlvbnMsIHNldHRpbmdzKSk7XG5cbiAgICAvLyBGYXRhbCBlcnJvcnNcbiAgICAvLyBTdG9wIHNjcmlwdCBleGVjdXRpb24gb24gZXJyb3JcbiAgICB2YWxpZGF0ZURvbWFpblR5cGUoKTtcbiAgICB2YWxpZGF0ZVNlbGVjdG9yKG9wdGlvbnMuaXRlbVNlbGVjdG9yLCBmYWxzZSwgJ2l0ZW1TZWxlY3RvcicpO1xuXG4gICAgaWYgKHBhcmVudC5hbGxvd2VkRGF0YVR5cGUuaW5kZXhPZihvcHRpb25zLmRhdGFUeXBlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgZGF0YSB0eXBlICdcIiArIG9wdGlvbnMuZGF0YVR5cGUgKyBcIicgaXMgbm90IHZhbGlkIGRhdGEgdHlwZVwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZDMuc2VsZWN0KG9wdGlvbnMuaXRlbVNlbGVjdG9yKVswXVswXSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSBub2RlICdcIiArXG4gICAgICAgICAgb3B0aW9ucy5pdGVtU2VsZWN0b3IgK1xuICAgICAgICAgIFwiJyBzcGVjaWZpZWQgaW4gaXRlbVNlbGVjdG9yIGRvZXMgbm90IGV4aXN0c1wiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFsaWRhdGVTZWxlY3RvcihvcHRpb25zLm5leHRTZWxlY3RvciwgdHJ1ZSwgJ25leHRTZWxlY3RvcicpO1xuICAgICAgdmFsaWRhdGVTZWxlY3RvcihvcHRpb25zLnByZXZpb3VzU2VsZWN0b3IsIHRydWUsICdwcmV2aW91c1NlbGVjdG9yJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIG90aGVyIHNldHRpbmdzIGNvbnRhaW5zIGVycm9yLCB3aWxsIGZhbGxiYWNrIHRvIGRlZmF1bHRcblxuICAgIGlmICghc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3N1YkRvbWFpbicpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc3ViRG9tYWluID0gZ2V0T3B0aW1hbFN1YkRvbWFpbihzZXR0aW5ncy5kb21haW4pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLml0ZW1OYW1lc3BhY2UgIT09ICdzdHJpbmcnIHx8XG4gICAgICBvcHRpb25zLml0ZW1OYW1lc3BhY2UgPT09ICcnXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgJ2l0ZW1OYW1lc3BhY2UgY2FuIG5vdCBiZSBlbXB0eSwgZmFsbGluZyBiYWNrIHRvIGNhbC1oZWF0bWFwJyxcbiAgICAgICk7XG4gICAgICBvcHRpb25zLml0ZW1OYW1lc3BhY2UgPSAnY2FsLWhlYXRtYXAnO1xuICAgIH1cblxuICAgIC8vIERvbid0IHRvdWNoIHRoZXNlIHNldHRpbmdzXG4gICAgdmFyIHMgPSBbXG4gICAgICAnZGF0YScsXG4gICAgICAnb25Db21wbGV0ZScsXG4gICAgICAnb25DbGljaycsXG4gICAgICAnYWZ0ZXJMb2FkJyxcbiAgICAgICdhZnRlckxvYWREYXRhJyxcbiAgICAgICdhZnRlckxvYWRQcmV2aW91c0RvbWFpbicsXG4gICAgICAnYWZ0ZXJMb2FkTmV4dERvbWFpbicsXG4gICAgICAnYWZ0ZXJVcGRhdGUnLFxuICAgIF07XG5cbiAgICBmb3IgKHZhciBrIGluIHMpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShzW2tdKSkge1xuICAgICAgICBvcHRpb25zW3Nba11dID0gc2V0dGluZ3Nbc1trXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5zdWJEb21haW5EYXRlRm9ybWF0ID1cbiAgICAgIHR5cGVvZiBvcHRpb25zLnN1YkRvbWFpbkRhdGVGb3JtYXQgPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5zdWJEb21haW5EYXRlRm9ybWF0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3B0aW9ucy5zdWJEb21haW5EYXRlRm9ybWF0XG4gICAgICAgIDogdGhpcy5fZG9tYWluVHlwZVtvcHRpb25zLnN1YkRvbWFpbl0uZm9ybWF0LmRhdGU7XG4gICAgb3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdCA9XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdCA9PT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRvbWFpbkxhYmVsRm9ybWF0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdFxuICAgICAgICA6IHRoaXMuX2RvbWFpblR5cGVbb3B0aW9ucy5kb21haW5dLmZvcm1hdC5sZWdlbmQ7XG4gICAgb3B0aW9ucy5zdWJEb21haW5UZXh0Rm9ybWF0ID1cbiAgICAgICh0eXBlb2Ygb3B0aW9ucy5zdWJEb21haW5UZXh0Rm9ybWF0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBvcHRpb25zLnN1YkRvbWFpblRleHRGb3JtYXQgIT09ICcnKSB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMuc3ViRG9tYWluVGV4dEZvcm1hdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdGlvbnMuc3ViRG9tYWluVGV4dEZvcm1hdFxuICAgICAgICA6IG51bGw7XG4gICAgb3B0aW9ucy5kb21haW5NYXJnaW4gPSBleHBhbmRNYXJnaW5TZXR0aW5nKG9wdGlvbnMuZG9tYWluTWFyZ2luKTtcbiAgICBvcHRpb25zLmxlZ2VuZE1hcmdpbiA9IGV4cGFuZE1hcmdpblNldHRpbmcob3B0aW9ucy5sZWdlbmRNYXJnaW4pO1xuICAgIG9wdGlvbnMuaGlnaGxpZ2h0ID0gcGFyZW50LmV4cGFuZERhdGVTZXR0aW5nKG9wdGlvbnMuaGlnaGxpZ2h0KTtcbiAgICBvcHRpb25zLml0ZW1OYW1lID0gZXhwYW5kSXRlbU5hbWUob3B0aW9ucy5pdGVtTmFtZSk7XG4gICAgb3B0aW9ucy5jb2xMaW1pdCA9IHBhcnNlQ29sTGltaXQob3B0aW9ucy5jb2xMaW1pdCk7XG4gICAgb3B0aW9ucy5yb3dMaW1pdCA9IHBhcnNlUm93TGltaXQob3B0aW9ucy5yb3dMaW1pdCk7XG4gICAgaWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnbGVnZW5kTWFyZ2luJykpIHtcbiAgICAgIGF1dG9BZGRMZWdlbmRNYXJnaW4oKTtcbiAgICB9XG4gICAgYXV0b0FsaWduTGFiZWwoKTtcblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoYXQgYSBxdWVyeVN0cmluZyBpcyB2YWxpZFxuICAgICAqXG4gICAgICogQHBhcmFtICB7RWxlbWVudHxzdHJpbmd8Ym9vbH0gc2VsZWN0b3IgICBUaGUgcXVlcnlTdHJpbmcgdG8gdGVzdFxuICAgICAqIEBwYXJhbSAge2Jvb2x9ICBjYW5CZUZhbHNlICBXaGV0aGVyIGZhbHNlIGlzIGFuIGFjY2VwdGVkIGFuZCB2YWxpZCB2YWx1ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICBOYW1lIG9mIHRoZSB0ZXN0ZWQgc2VsZWN0b3JcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gICAgICAgIElmIHRoZSBzZWxlY3RvciBpcyBub3QgdmFsaWRcbiAgICAgKiBAcmV0dXJuIHtib29sfSAgICAgICAgVHJ1ZSBpZiB0aGUgc2VsZWN0b3IgaXMgYSB2YWxpZCBxdWVyeVN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2VsZWN0b3Ioc2VsZWN0b3IsIGNhbkJlRmFsc2UsIG5hbWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKChjYW5CZUZhbHNlICYmIHNlbGVjdG9yID09PSBmYWxzZSkgfHxcbiAgICAgICAgICBzZWxlY3RvciBpbnN0YW5jZW9mIEVsZW1lbnQgfHxcbiAgICAgICAgICB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICBzZWxlY3RvciAhPT0gJydcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlICcgKyBuYW1lICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9wdGltYWwgc3ViRG9tYWluIGZvciB0aGUgc3BlY2lmaWVkIGRvbWFpblxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBkb21haW4gYSBkb21haW4gbmFtZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgIHRoZSBzdWJEb21haW4gbmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9wdGltYWxTdWJEb21haW4oZG9tYWluKSB7XG4gICAgICBzd2l0Y2ggKGRvbWFpbikge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICByZXR1cm4gJ21vbnRoJztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgIHJldHVybiAnZGF5JztcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgcmV0dXJuICdkYXknO1xuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIHJldHVybiAnaG91cic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICdtaW4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZSBkb21haW4gYW5kIHN1YmRvbWFpbiBhcmUgdmFsaWRcbiAgICAgKlxuICAgICAqIEB0aHJvdyB7RXJyb3J9IHdoZW4gZG9tYWluIG9yIHN1YmRvbWFpbiBhcmUgbm90IHZhbGlkXG4gICAgICogQHJldHVybiB7Ym9vbH0gVHJ1ZSBpZiBkb21haW4gYW5kIHN1YmRvbWFpbiBhcmUgdmFsaWQgYW5kIGNvbXBhdGlibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZURvbWFpblR5cGUoKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFwYXJlbnQuX2RvbWFpblR5cGUuaGFzT3duUHJvcGVydHkob3B0aW9ucy5kb21haW4pIHx8XG4gICAgICAgIG9wdGlvbnMuZG9tYWluID09PSAnbWluJyB8fFxuICAgICAgICBvcHRpb25zLmRvbWFpbi5zdWJzdHJpbmcoMCwgMikgPT09ICd4XydcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZG9tYWluICdcIiArIG9wdGlvbnMuZG9tYWluICsgXCInIGlzIG5vdCB2YWxpZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAhcGFyZW50Ll9kb21haW5UeXBlLmhhc093blByb3BlcnR5KG9wdGlvbnMuc3ViRG9tYWluKSB8fFxuICAgICAgICBvcHRpb25zLnN1YkRvbWFpbiA9PT0gJ3llYXInXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVGhlIHN1YkRvbWFpbiAnXCIgKyBvcHRpb25zLnN1YkRvbWFpbiArIFwiJyBpcyBub3QgdmFsaWRcIixcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwYXJlbnQuX2RvbWFpblR5cGVbb3B0aW9ucy5kb21haW5dLmxldmVsIDw9XG4gICAgICAgIHBhcmVudC5fZG9tYWluVHlwZVtvcHRpb25zLnN1YkRvbWFpbl0ubGV2ZWxcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCInXCIgK1xuICAgICAgICAgICAgb3B0aW9ucy5zdWJEb21haW4gK1xuICAgICAgICAgICAgXCInIGlzIG5vdCBhIHZhbGlkIHN1YkRvbWFpbiB0byAnXCIgK1xuICAgICAgICAgICAgb3B0aW9ucy5kb21haW4gK1xuICAgICAgICAgICAgXCInXCIsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmUtdHVuZSB0aGUgbGFiZWwgYWxpZ25lbWVudCBkZXBlbmRpbmcgb24gaXRzIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvQWxpZ25MYWJlbCgpIHtcbiAgICAgIC8vIEF1dG8tYWxpZ24gbGFiZWwsIGRlcGVuZGluZyBvbiBpdCdzIHBvc2l0aW9uXG4gICAgICBpZiAoXG4gICAgICAgICFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnbGFiZWwnKSB8fFxuICAgICAgICAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2xhYmVsJykgJiZcbiAgICAgICAgICAhc2V0dGluZ3MubGFiZWwuaGFzT3duUHJvcGVydHkoJ2FsaWduJykpXG4gICAgICApIHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmxhYmVsLnBvc2l0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBvcHRpb25zLmxhYmVsLmFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIG9wdGlvbnMubGFiZWwuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb3B0aW9ucy5sYWJlbC5hbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGFiZWwucm90YXRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBvcHRpb25zLmxhYmVsLmFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmxhYmVsLnJvdGF0ZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIG9wdGlvbnMubGFiZWwuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAhc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2xhYmVsJykgfHxcbiAgICAgICAgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdsYWJlbCcpICYmXG4gICAgICAgICAgIXNldHRpbmdzLmxhYmVsLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSlcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgb3B0aW9ucy5sYWJlbC5wb3NpdGlvbiA9PT0gJ2xlZnQnIHx8XG4gICAgICAgICAgb3B0aW9ucy5sYWJlbC5wb3NpdGlvbiA9PT0gJ3JpZ2h0J1xuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLmxhYmVsLm9mZnNldCA9IHtcbiAgICAgICAgICAgIHg6IDEwLFxuICAgICAgICAgICAgeTogMTUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIG5vdCBzcGVjaWZpZWQsIGFkZCBzb21lIG1hcmdpbiBhcm91bmQgdGhlIGxlZ2VuZCBkZXBlbmRpbmcgb24gaXRzIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvQWRkTGVnZW5kTWFyZ2luKCkge1xuICAgICAgc3dpdGNoIChvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZE1hcmdpblsyXSA9IHBhcmVudC5ERUZBVUxUX0xFR0VORF9NQVJHSU47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRNYXJnaW5bMF0gPSBwYXJlbnQuREVGQVVMVF9MRUdFTkRfTUFSR0lOO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kTWFyZ2luW1xuICAgICAgICAgICAgb3B0aW9ucy5sZWdlbmRIb3Jpem9udGFsUG9zaXRpb24gPT09ICdyaWdodCcgPyAzIDogMVxuICAgICAgICAgIF0gPSBwYXJlbnQuREVGQVVMVF9MRUdFTkRfTUFSR0lOO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZCBhIG51bWJlciBvZiBhbiBhcnJheSBvZiBudW1iZXJzIHRvIGFuIHVzYWJsZSA0IHZhbHVlcyBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtICB7aW50ZWdlcnxhcnJheX0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgIGFycmF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhwYW5kTWFyZ2luU2V0dGluZyh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXJnaW4gb25seSB0YWtlcyBhbiBpbnRlZ2VyIG9yIGFuIGFycmF5IG9mIGludGVnZXJzJyk7XG4gICAgICAgIHZhbHVlID0gWzBdO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFt2YWx1ZVswXSwgdmFsdWVbMF0sIHZhbHVlWzBdLCB2YWx1ZVswXV07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gW3ZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMF0sIHZhbHVlWzFdXTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBbdmFsdWVbMF0sIHZhbHVlWzFdLCB2YWx1ZVsyXSwgdmFsdWVbMV1dO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgwLCA0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIGFycmF5IGxpa2UgW3Npbmd1bGFyLWZvcm0sIHBsdXJhbC1mb3JtXVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fSB2YWx1ZSBEYXRlIHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgQW4gYXJyYXkgbGlrZSBbc2luZ3VsYXItZm9ybSwgcGx1cmFsLWZvcm1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhwYW5kSXRlbU5hbWUodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIHZhbHVlICsgKHZhbHVlICE9PSAnJyA/ICdzJyA6ICcnKV07XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFt2YWx1ZVswXSwgdmFsdWVbMF0gKyAncyddO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbJ2l0ZW0nLCAnaXRlbXMnXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbExpbWl0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUm93TGltaXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA+IDAgJiYgb3B0aW9ucy5jb2xMaW1pdCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgJ2NvbExpbWl0IGFuZCByb3dMaW1pdCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLCByb3dMaW1pdCB3aWxsIGJlIGlnbm9yZWQnLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2luaXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIGtleXdvcmQgb3IgYW4gYXJyYXkgb2Yga2V5d29yZC9kYXRlIHRvIGFuIGFycmF5IG9mIGRhdGUgb2JqZWN0c1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl8RGF0ZX0gdmFsdWUgRGF0YSB0byBjb252ZXJ0XG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICBBbiBhcnJheSBvZiBEYXRlc1xuICAgKi9cbiAgZXhwYW5kRGF0ZVNldHRpbmc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09ICdub3cnKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgIT09IGZhbHNlO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbGwgdGhlIGNhbGVuZGFyIGJ5IGNvbG9yaW5nIHRoZSBjZWxsc1xuICAgKlxuICAgKiBAcGFyYW0gYXJyYXkgc3ZnIEFuIGFycmF5IG9mIGh0bWwgbm9kZSB0byBhcHBseSB0aGUgdHJhbnNmb3JtYXRpb24gdG8gKG9wdGlvbmFsKVxuICAgKiAgICAgICAgICAgICAgICAgIEl0J3MgdXNlZCB0byBsaW1pdCB0aGUgcGFpbnRpbmcgdG8gb25seSBhIHN1YnNldCBvZiB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuICBmaWxsOiBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJlbnQub3B0aW9ucztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBzdmcgPSBwYXJlbnQucm9vdC5zZWxlY3RBbGwoJy5ncmFwaC1kb21haW4nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IHN2Z1xuICAgICAgLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgIC5zZWxlY3RBbGwoJ2cnKVxuICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fZG9tYWlucy5nZXQoZCk7XG4gICAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb2xvcml6ZSB0aGUgY2VsbCB2aWEgYSBzdHlsZSBhdHRyaWJ1dGUgaWYgZW5hYmxlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFN0eWxlKGVsZW1lbnQpIHtcbiAgICAgIGlmIChwYXJlbnQubGVnZW5kU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZC52ID09PSBudWxsICYmXG4gICAgICAgICAgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc2lkZXJNaXNzaW5nRGF0YUFzWmVybycpICYmXG4gICAgICAgICAgIW9wdGlvbnMuY29uc2lkZXJNaXNzaW5nRGF0YUFzWmVyb1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5sZWdlbmRDb2xvcnMuaGFzT3duUHJvcGVydHkoJ2Jhc2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubGVnZW5kQ29sb3JzLmJhc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzICE9PSBudWxsICYmXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRDb2xvcnMuaGFzT3duUHJvcGVydHkoJ2VtcHR5JykgJiZcbiAgICAgICAgICAoZC52ID09PSAwIHx8XG4gICAgICAgICAgICAoZC52ID09PSBudWxsICYmXG4gICAgICAgICAgICAgIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8nKSAmJlxuICAgICAgICAgICAgICBvcHRpb25zLmNvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8pKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5sZWdlbmRDb2xvcnMuZW1wdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZC52IDwgMCAmJlxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kWzBdID4gMCAmJlxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzICE9PSBudWxsICYmXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRDb2xvcnMuaGFzT3duUHJvcGVydHkoJ292ZXJmbG93JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMubGVnZW5kQ29sb3JzLm92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudC5sZWdlbmRTY2FsZShcbiAgICAgICAgICBNYXRoLm1pbihkLnYsIG9wdGlvbnMubGVnZW5kW29wdGlvbnMubGVnZW5kLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlY3RcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKVxuICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaHRtbENsYXNzID0gcGFyZW50LmdldEhpZ2hsaWdodENsYXNzTmFtZShkLnQpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgcGFzdERhdGUgPSBwYXJlbnQuZGF0ZUlzTGVzc1RoYW4oZC50LCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgdmFyIHNhbWVEYXRlID0gcGFyZW50LmRhdGVJc0VxdWFsKGQudCwgbmV3IERhdGUoKSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcmVudC5sZWdlbmRTY2FsZSA9PT0gbnVsbCB8fFxuICAgICAgICAgIChkLnYgPT09IG51bGwgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8nKSAmJlxuICAgICAgICAgICAgIW9wdGlvbnMuY29uc2lkZXJNaXNzaW5nRGF0YUFzWmVybyAmJlxuICAgICAgICAgICAgIW9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdiYXNlJykpXG4gICAgICAgICkge1xuICAgICAgICAgIGh0bWxDbGFzcy5wdXNoKCdncmFwaC1yZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2FtZURhdGUpIHtcbiAgICAgICAgICBodG1sQ2xhc3MucHVzaCgnbm93Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhc3REYXRlKSB7XG4gICAgICAgICAgaHRtbENsYXNzLnB1c2goJ2Z1dHVyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGQudiAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWxDbGFzcy5wdXNoKFxuICAgICAgICAgICAgcGFyZW50LkxlZ2VuZC5nZXRDbGFzcyhkLnYsIHBhcmVudC5sZWdlbmRTY2FsZSA9PT0gbnVsbCksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8gJiYgcGFzdERhdGUpIHtcbiAgICAgICAgICBodG1sQ2xhc3MucHVzaChcbiAgICAgICAgICAgIHBhcmVudC5MZWdlbmQuZ2V0Q2xhc3MoMCwgcGFyZW50LmxlZ2VuZFNjYWxlID09PSBudWxsKSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub25DbGljayAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWxDbGFzcy5wdXNoKCdob3Zlcl9jdXJzb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sQ2xhc3Muam9pbignICcpO1xuICAgICAgfSlcbiAgICAgIC5jYWxsKGFkZFN0eWxlKTtcblxuICAgIHJlY3RcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKVxuICAgICAgLnNlbGVjdCgndGl0bGUnKVxuICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5nZXRTdWJEb21haW5UaXRsZShkKTtcbiAgICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0U3ViRG9tYWluVGV4dChlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3ViRG9tYWluVGV4dEZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbGVtZW50LnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zdWJEb21haW5UZXh0Rm9ybWF0KGQudCwgZC52KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBzdWJEb21haW5UZXh0IGNsYXNzIGlmIG5lY2Vzc2FyeVxuICAgICAqIEFsc28gY2hhbmdlIHRoZSB0ZXh0LCBlLmcgd2hlbiB0ZXh0IGlzIHJlcHJlc2VudGluZyB0aGUgdmFsdWVcbiAgICAgKiBpbnN0ZWFkIG9mIHRoZSBkYXRlXG4gICAgICovXG4gICAgcmVjdFxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXG4gICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAnc3ViZG9tYWluLXRleHQnICsgcGFyZW50LmdldEhpZ2hsaWdodENsYXNzTmFtZShkLnQpO1xuICAgICAgfSlcbiAgICAgIC5jYWxsKGZvcm1hdFN1YkRvbWFpblRleHQpXG4gICAgICAuYXR0cignZmlsbCcsIGQgPT4ge1xuICAgICAgICBpZiAoIWQudikgcmV0dXJuICcjMDAwJztcbiAgICAgICAgY29uc3QgcmdiID0gcGFyZW50LmxlZ2VuZFNjYWxlKFxuICAgICAgICAgIE1hdGgubWluKGQudiwgb3B0aW9ucy5sZWdlbmRbb3B0aW9ucy5sZWdlbmQubGVuZ3RoIC0gMV0pLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZ2V0Q29udHJhc3RpbmdDb2xvcihyZ2IsIDEzNSk7XG4gICAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU3ByaW50ZiBsaWtlIGZ1bmN0aW9uLlxuICAgKiBSZXBsYWNlcyBwbGFjZWhvbGRlcnMgezB9IGluIHN0cmluZyB3aXRoIHZhbHVlcyBmcm9tIHByb3ZpZGVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBmb3JtYXR0ZWQgU3RyaW5nIGNvbnRhaW5pbmcgcGxhY2Vob2xkZXJzLlxuICAgKiBAcGFyYW0gb2JqZWN0IGFyZ3MgT2JqZWN0IHdpdGggcHJvcGVydGllcyB0byByZXBsYWNlIHBsYWNlaG9sZGVycyBpbiBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4gU3RyaW5nXG4gICAqL1xuICBmb3JtYXRTdHJpbmdXaXRoT2JqZWN0OiBmdW5jdGlvbiAoZm9ybWF0dGVkLCBhcmdzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXJncykge1xuICAgICAgaWYgKGFyZ3MuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIHByb3AgKyAnXFxcXH0nLCAnZ2knKTtcbiAgICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UocmVnZXhwLCBhcmdzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbiAgLy8gRVZFTlRTIENBTExCQUNLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgZm9yIHRyaWdnZXJpbmcgZXZlbnQgY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtICBzdHJpbmcgIGV2ZW50TmFtZSAgICAgICBOYW1lIG9mIHRoZSBldmVudCB0byB0cmlnZ2VyXG4gICAqIEBwYXJhbSAgYXJyYXkgIHN1Y2Nlc3NBcmdzICAgICBMaXN0IG9mIGFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrXG4gICAqIEBwYXJhbSAgYm9vbGVhbiAgc2tpcCAgICAgIFdoZXRoZXIgdG8gc2tpcCB0aGUgZXZlbnQgdHJpZ2dlcmluZ1xuICAgKiBAcmV0dXJuIG1peGVkICBUcnVlIHdoZW4gdGhlIHRyaWdnZXJpbmcgd2FzIHNraXBwZWQsIGZhbHNlIG9uIGVycm9yLCBlbHNlIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgdHJpZ2dlckV2ZW50OiBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWNjZXNzQXJncywgc2tpcCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICgoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiBza2lwKSB8fCB0aGlzLm9wdGlvbnNbZXZlbnROYW1lXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnNbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzQXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdWNjZXNzQXJncyA9IHN1Y2Nlc3NBcmdzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zW2V2ZW50TmFtZV0uYXBwbHkodGhpcywgc3VjY2Vzc0FyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnUHJvdmlkZWQgY2FsbGJhY2sgZm9yICcgKyBldmVudE5hbWUgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgdHJpZ2dlcmVkIG9uIGEgbW91c2UgY2xpY2sgb24gYSBzdWJEb21haW4gY2VsbFxuICAgKlxuICAgKiBAcGFyYW0gIERhdGUgICAgZCAgICBEYXRlIG9mIHRoZSBzdWJkb21haW4gYmxvY2tcbiAgICogQHBhcmFtICBpbnQgICAgaXRlbU5iICBOdW1iZXIgb2YgaXRlbXMgaW4gdGhhdCBkYXRlXG4gICAqL1xuICBvbkNsaWNrOiBmdW5jdGlvbiAoZCwgaXRlbU5iKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlckV2ZW50KCdvbkNsaWNrJywgW2QsIGl0ZW1OYl0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgZHJhd2luZyB0aGUgY2FsZW5kYXIsIGJ5dCBiZWZvcmUgZmlsbGluZyBpdCB3aXRoIGRhdGFcbiAgICovXG4gIGFmdGVyTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLnRyaWdnZXJFdmVudCgnYWZ0ZXJMb2FkJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2ZW50IHRyaWdnZXJlZCBhZnRlciBjb21wbGV0aW5nIGRyYXdpbmcgYW5kIGZpbGxpbmcgdGhlIGNhbGVuZGFyXG4gICAqL1xuICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHJlc3BvbnNlID0gdGhpcy50cmlnZ2VyRXZlbnQoJ29uQ29tcGxldGUnLCBbXSwgdGhpcy5fY29tcGxldGVkKTtcbiAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHNoaWZ0aW5nIHRoZSBjYWxlbmRhciBvbmUgZG9tYWluIGJhY2tcbiAgICpcbiAgICogQHBhcmFtICBEYXRlICAgIHN0YXJ0ICBEb21haW4gc3RhcnQgZGF0ZVxuICAgKiBAcGFyYW0gIERhdGUgICAgZW5kICAgIERvbWFpbiBlbmQgZGF0ZVxuICAgKi9cbiAgYWZ0ZXJMb2FkUHJldmlvdXNEb21haW46IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLnRyaWdnZXJFdmVudCgnYWZ0ZXJMb2FkUHJldmlvdXNEb21haW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3ViRG9tYWluID0gcGFyZW50LmdldFN1YkRvbWFpbihzdGFydCk7XG4gICAgICByZXR1cm4gW3N1YkRvbWFpbi5zaGlmdCgpLCBzdWJEb21haW4ucG9wKCldO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgc2hpZnRpbmcgdGhlIGNhbGVuZGFyIG9uZSBkb21haW4gYWJvdmVcbiAgICpcbiAgICogQHBhcmFtICBEYXRlICAgIHN0YXJ0ICBEb21haW4gc3RhcnQgZGF0ZVxuICAgKiBAcGFyYW0gIERhdGUgICAgZW5kICAgIERvbWFpbiBlbmQgZGF0ZVxuICAgKi9cbiAgYWZ0ZXJMb2FkTmV4dERvbWFpbjogZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlckV2ZW50KCdhZnRlckxvYWROZXh0RG9tYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN1YkRvbWFpbiA9IHBhcmVudC5nZXRTdWJEb21haW4oc3RhcnQpO1xuICAgICAgcmV0dXJuIFtzdWJEb21haW4uc2hpZnQoKSwgc3ViRG9tYWluLnBvcCgpXTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIGxvYWRpbmcgdGhlIGxlZnRtb3N0IGRvbWFpbiBhbGxvd2VkIGJ5IG1pbkRhdGVcbiAgICpcbiAgICogQHBhcmFtICBib29sZWFuICByZWFjaGVkIFRydWUgaWYgdGhlIGxlZnRtb3N0IGRvbWFpbiB3YXMgcmVhY2hlZFxuICAgKi9cbiAgb25NaW5Eb21haW5SZWFjaGVkOiBmdW5jdGlvbiAocmVhY2hlZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuX21pbkRvbWFpblJlYWNoZWQgPSByZWFjaGVkO1xuICAgIHJldHVybiB0aGlzLnRyaWdnZXJFdmVudCgnb25NaW5Eb21haW5SZWFjaGVkJywgW3JlYWNoZWRdKTtcbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIGxvYWRpbmcgdGhlIHJpZ2h0bW9zdCBkb21haW4gYWxsb3dlZCBieSBtYXhEYXRlXG4gICAqXG4gICAqIEBwYXJhbSAgYm9vbGVhbiAgcmVhY2hlZCBUcnVlIGlmIHRoZSByaWdodG1vc3QgZG9tYWluIHdhcyByZWFjaGVkXG4gICAqL1xuICBvbk1heERvbWFpblJlYWNoZWQ6IGZ1bmN0aW9uIChyZWFjaGVkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdGhpcy5fbWF4RG9tYWluUmVhY2hlZCA9IHJlYWNoZWQ7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlckV2ZW50KCdvbk1heERvbWFpblJlYWNoZWQnLCBbcmVhY2hlZF0pO1xuICB9LFxuXG4gIGNoZWNrSWZNaW5Eb21haW5Jc1JlYWNoZWQ6IGZ1bmN0aW9uIChkYXRlLCB1cHBlckJvdW5kKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHRoaXMubWluRG9tYWluSXNSZWFjaGVkKGRhdGUpKSB7XG4gICAgICB0aGlzLm9uTWluRG9tYWluUmVhY2hlZCh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKHRoaXMuX21heERvbWFpblJlYWNoZWQgJiYgIXRoaXMubWF4RG9tYWluSXNSZWFjaGVkKHVwcGVyQm91bmQpKSB7XG4gICAgICAgIHRoaXMub25NYXhEb21haW5SZWFjaGVkKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY2hlY2tJZk1heERvbWFpbklzUmVhY2hlZDogZnVuY3Rpb24gKGRhdGUsIGxvd2VyQm91bmQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodGhpcy5tYXhEb21haW5Jc1JlYWNoZWQoZGF0ZSkpIHtcbiAgICAgIHRoaXMub25NYXhEb21haW5SZWFjaGVkKHRydWUpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAodGhpcy5fbWluRG9tYWluUmVhY2hlZCAmJiAhdGhpcy5taW5Eb21haW5Jc1JlYWNoZWQobG93ZXJCb3VuZCkpIHtcbiAgICAgICAgdGhpcy5vbk1pbkRvbWFpblJlYWNoZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLnRyaWdnZXJFdmVudCgnYWZ0ZXJVcGRhdGUnKTtcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbiAgLy8gRk9STUFUVEVSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuICBmb3JtYXROdW1iZXI6IGQzLmZvcm1hdCgnLGcnKSxcblxuICBmb3JtYXREYXRlOiBmdW5jdGlvbiAoZCwgZm9ybWF0KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBmb3JtYXQgPSAndGl0bGUnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZiA9IGQzLnRpbWUuZm9ybWF0KGZvcm1hdCk7XG4gICAgICByZXR1cm4gZihkKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3ViRG9tYWluVGl0bGU6IGZ1bmN0aW9uIChkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKGQudiA9PT0gbnVsbCAmJiAhdGhpcy5vcHRpb25zLmNvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFN0cmluZ1dpdGhPYmplY3QoXG4gICAgICAgIHRoaXMub3B0aW9ucy5zdWJEb21haW5UaXRsZUZvcm1hdC5lbXB0eSxcbiAgICAgICAge1xuICAgICAgICAgIGRhdGU6IHRoaXMuZm9ybWF0RGF0ZShcbiAgICAgICAgICAgIG5ldyBEYXRlKGQudCksXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ViRG9tYWluRGF0ZUZvcm1hdCxcbiAgICAgICAgICApLFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZhbHVlID0gZC52O1xuICAgICAgLy8gQ29uc2lkZXIgbnVsbCBhcyAwXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgdGhpcy5vcHRpb25zLmNvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8pIHtcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRTdHJpbmdXaXRoT2JqZWN0KFxuICAgICAgICB0aGlzLm9wdGlvbnMuc3ViRG9tYWluVGl0bGVGb3JtYXQuZmlsbGVkLFxuICAgICAgICB7XG4gICAgICAgICAgY291bnQ6IHRoaXMuZm9ybWF0TnVtYmVyKHZhbHVlKSxcbiAgICAgICAgICBuYW1lOiB0aGlzLm9wdGlvbnMuaXRlbU5hbWVbdmFsdWUgIT09IDEgPyAxIDogMF0sXG4gICAgICAgICAgY29ubmVjdG9yOiB0aGlzLl9kb21haW5UeXBlW3RoaXMub3B0aW9ucy5zdWJEb21haW5dLmZvcm1hdC5jb25uZWN0b3IsXG4gICAgICAgICAgZGF0ZTogdGhpcy5mb3JtYXREYXRlKFxuICAgICAgICAgICAgbmV3IERhdGUoZC50KSxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdWJEb21haW5EYXRlRm9ybWF0LFxuICAgICAgICAgICksXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbiAgLy8gRE9NQUlOIE5BVklHQVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgLyoqXG4gICAqIFNoaWZ0IHRoZSBjYWxlbmRhciBvbmUgZG9tYWluIGZvcndhcmRcbiAgICpcbiAgICogVGhlIG5ldyBkb21haW4gaXMgbG9hZGVkIG9ubHkgaWYgaXQncyBub3QgYmV5b25kIG1heERhdGVcbiAgICpcbiAgICogQHBhcmFtIGludCBuIE51bWJlciBvZiBkb21haW5zIHRvIGxvYWRcbiAgICogQHJldHVybiBib29sIFRydWUgaWYgdGhlIG5leHQgZG9tYWluIHdhcyBsb2FkZWQsIGVsc2UgZmFsc2VcbiAgICovXG4gIGxvYWROZXh0RG9tYWluOiBmdW5jdGlvbiAobikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh0aGlzLl9tYXhEb21haW5SZWFjaGVkIHx8IG4gPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYm91bmQgPSB0aGlzLmxvYWROZXdEb21haW5zKFxuICAgICAgdGhpcy5OQVZJR0FURV9SSUdIVCxcbiAgICAgIHRoaXMuZ2V0RG9tYWluKHRoaXMuZ2V0TmV4dERvbWFpbigpLCBuKSxcbiAgICApO1xuXG4gICAgdGhpcy5hZnRlckxvYWROZXh0RG9tYWluKGJvdW5kLmVuZCk7XG4gICAgdGhpcy5jaGVja0lmTWF4RG9tYWluSXNSZWFjaGVkKHRoaXMuZ2V0TmV4dERvbWFpbigpLmdldFRpbWUoKSwgYm91bmQuc3RhcnQpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNoaWZ0IHRoZSBjYWxlbmRhciBvbmUgZG9tYWluIGJhY2t3YXJkXG4gICAqXG4gICAqIFRoZSBwcmV2aW91cyBkb21haW4gaXMgbG9hZGVkIG9ubHkgaWYgaXQncyBub3QgYmV5b25kIHRoZSBtaW5EYXRlXG4gICAqXG4gICAqIEBwYXJhbSBpbnQgbiBOdW1iZXIgb2YgZG9tYWlucyB0byBsb2FkXG4gICAqIEByZXR1cm4gYm9vbCBUcnVlIGlmIHRoZSBwcmV2aW91cyBkb21haW4gd2FzIGxvYWRlZCwgZWxzZSBmYWxzZVxuICAgKi9cbiAgbG9hZFByZXZpb3VzRG9tYWluOiBmdW5jdGlvbiAobikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh0aGlzLl9taW5Eb21haW5SZWFjaGVkIHx8IG4gPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYm91bmQgPSB0aGlzLmxvYWROZXdEb21haW5zKFxuICAgICAgdGhpcy5OQVZJR0FURV9MRUZULFxuICAgICAgdGhpcy5nZXREb21haW4odGhpcy5nZXREb21haW5LZXlzKClbMF0sIC1uKS5yZXZlcnNlKCksXG4gICAgKTtcblxuICAgIHRoaXMuYWZ0ZXJMb2FkUHJldmlvdXNEb21haW4oYm91bmQuc3RhcnQpO1xuICAgIHRoaXMuY2hlY2tJZk1pbkRvbWFpbklzUmVhY2hlZChib3VuZC5zdGFydCwgYm91bmQuZW5kKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGxvYWROZXdEb21haW5zOiBmdW5jdGlvbiAoZGlyZWN0aW9uLCBuZXdEb21haW5zKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGJhY2t3YXJkID0gZGlyZWN0aW9uID09PSB0aGlzLk5BVklHQVRFX0xFRlQ7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgdG90YWwgPSBuZXdEb21haW5zLmxlbmd0aDtcbiAgICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0RG9tYWluS2V5cygpO1xuXG4gICAgZnVuY3Rpb24gYnVpbGRTdWJEb21haW4oZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdDogcGFyZW50Ll9kb21haW5UeXBlW3BhcmVudC5vcHRpb25zLnN1YkRvbWFpbl0uZXh0cmFjdFVuaXQoZCksXG4gICAgICAgIHY6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBvdXQgb2YgYm91bmQgZG9tYWlucyBmcm9tIGxpc3Qgb2YgbmV3IGRvbWFpbnMgdG8gcHJlcGVuZFxuICAgIHdoaWxlICgrK2kgPCB0b3RhbCkge1xuICAgICAgaWYgKGJhY2t3YXJkICYmIHRoaXMubWluRG9tYWluSXNSZWFjaGVkKG5ld0RvbWFpbnNbaV0pKSB7XG4gICAgICAgIG5ld0RvbWFpbnMgPSBuZXdEb21haW5zLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWJhY2t3YXJkICYmIHRoaXMubWF4RG9tYWluSXNSZWFjaGVkKG5ld0RvbWFpbnNbaV0pKSB7XG4gICAgICAgIG5ld0RvbWFpbnMgPSBuZXdEb21haW5zLnNsaWNlKDAsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdEb21haW5zID0gbmV3RG9tYWlucy5zbGljZSgtdGhpcy5vcHRpb25zLnJhbmdlKTtcblxuICAgIGZvciAoaSA9IDAsIHRvdGFsID0gbmV3RG9tYWlucy5sZW5ndGg7IGkgPCB0b3RhbDsgaSArPSAxKSB7XG4gICAgICB0aGlzLl9kb21haW5zLnNldChcbiAgICAgICAgbmV3RG9tYWluc1tpXS5nZXRUaW1lKCksXG4gICAgICAgIHRoaXMuZ2V0U3ViRG9tYWluKG5ld0RvbWFpbnNbaV0pLm1hcChidWlsZFN1YkRvbWFpbiksXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9kb21haW5zLnJlbW92ZShiYWNrd2FyZCA/IGRvbWFpbnMucG9wKCkgOiBkb21haW5zLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIGRvbWFpbnMgPSB0aGlzLmdldERvbWFpbktleXMoKTtcblxuICAgIGlmIChiYWNrd2FyZCkge1xuICAgICAgbmV3RG9tYWlucyA9IG5ld0RvbWFpbnMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHRoaXMucGFpbnQoZGlyZWN0aW9uKTtcblxuICAgIHRoaXMuZ2V0RGF0YXMoXG4gICAgICB0aGlzLm9wdGlvbnMuZGF0YSxcbiAgICAgIG5ld0RvbWFpbnNbMF0sXG4gICAgICB0aGlzLmdldFN1YkRvbWFpbihuZXdEb21haW5zW25ld0RvbWFpbnMubGVuZ3RoIC0gMV0pLnBvcCgpLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXJlbnQuZmlsbChwYXJlbnQubGFzdEluc2VydGVkU3ZnKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbmV3RG9tYWluc1tiYWNrd2FyZCA/IDAgOiAxXSxcbiAgICAgIGVuZDogZG9tYWluc1tkb21haW5zLmxlbmd0aCAtIDFdLFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIGEgZGF0ZSBpcyBpbnNpZGUgdGhlIHNjb3BlIGRldGVybWluZWQgYnkgbWF4RGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaW50IGRhdGV0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBpbiBtcyB0byB0ZXN0XG4gICAqIEByZXR1cm4gYm9vbCBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgZGF0ZSBjb3JyZXNwb25kIHRvIHRoZSBjYWxlbmRhciB1cHBlciBib3VuZFxuICAgKi9cbiAgbWF4RG9tYWluSXNSZWFjaGVkOiBmdW5jdGlvbiAoZGF0ZXRpbWVzdGFtcCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm9wdGlvbnMubWF4RGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgdGhpcy5vcHRpb25zLm1heERhdGUuZ2V0VGltZSgpIDwgZGF0ZXRpbWVzdGFtcFxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIGEgZGF0ZSBpcyBpbnNpZGUgdGhlIHNjb3BlIGRldGVybWluZWQgYnkgbWluRGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaW50IGRhdGV0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBpbiBtcyB0byB0ZXN0XG4gICAqIEByZXR1cm4gYm9vbCBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgZGF0ZSBjb3JyZXNwb25kIHRvIHRoZSBjYWxlbmRhciBsb3dlciBib3VuZFxuICAgKi9cbiAgbWluRG9tYWluSXNSZWFjaGVkOiBmdW5jdGlvbiAoZGF0ZXRpbWVzdGFtcCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm9wdGlvbnMubWluRGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgdGhpcy5vcHRpb25zLm1pbkRhdGUuZ2V0VGltZSgpID49IGRhdGV0aW1lc3RhbXBcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2YgdGhlIGNhbGVuZGFyJ3MgZG9tYWluIHRpbWVzdGFtcFxuICAgKlxuICAgKiBAcmV0dXJuIEFycmF5IGEgc29ydGVkIGFycmF5IG9mIHRpbWVzdGFtcFxuICAgKi9cbiAgZ2V0RG9tYWluS2V5czogZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLl9kb21haW5zXG4gICAgICAua2V5cygpXG4gICAgICAubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChkLCAxMCk7XG4gICAgICB9KVxuICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4gIC8vIFBPU0lUSU9OTklORyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgcG9zaXRpb25TdWJEb21haW5YOiBmdW5jdGlvbiAoZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2RvbWFpblR5cGVbdGhpcy5vcHRpb25zLnN1YkRvbWFpbl0ucG9zaXRpb24ueChcbiAgICAgIG5ldyBEYXRlKGQpLFxuICAgICk7XG4gICAgcmV0dXJuIGluZGV4ICogdGhpcy5vcHRpb25zLmNlbGxTaXplICsgaW5kZXggKiB0aGlzLm9wdGlvbnMuY2VsbFBhZGRpbmc7XG4gIH0sXG5cbiAgcG9zaXRpb25TdWJEb21haW5ZOiBmdW5jdGlvbiAoZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2RvbWFpblR5cGVbdGhpcy5vcHRpb25zLnN1YkRvbWFpbl0ucG9zaXRpb24ueShcbiAgICAgIG5ldyBEYXRlKGQpLFxuICAgICk7XG4gICAgcmV0dXJuIGluZGV4ICogdGhpcy5vcHRpb25zLmNlbGxTaXplICsgaW5kZXggKiB0aGlzLm9wdGlvbnMuY2VsbFBhZGRpbmc7XG4gIH0sXG5cbiAgZ2V0U3ViRG9tYWluQ29sdW1uTnVtYmVyOiBmdW5jdGlvbiAoZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucm93TGltaXQgPiAwKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX2RvbWFpblR5cGVbdGhpcy5vcHRpb25zLnN1YkRvbWFpbl0ubWF4SXRlbU51bWJlcjtcbiAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpID0gaShkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLmNlaWwoaSAvIHRoaXMub3B0aW9ucy5yb3dMaW1pdCk7XG4gICAgfVxuXG4gICAgdmFyIGogPSB0aGlzLl9kb21haW5UeXBlW3RoaXMub3B0aW9ucy5zdWJEb21haW5dLmRlZmF1bHRDb2x1bW5OdW1iZXI7XG4gICAgaWYgKHR5cGVvZiBqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBqID0gaihkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb2xMaW1pdCB8fCBqO1xuICB9LFxuXG4gIGdldFN1YkRvbWFpblJvd051bWJlcjogZnVuY3Rpb24gKGQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbExpbWl0ID4gMCkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9kb21haW5UeXBlW3RoaXMub3B0aW9ucy5zdWJEb21haW5dLm1heEl0ZW1OdW1iZXI7XG4gICAgICBpZiAodHlwZW9mIGkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaSA9IGkoZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKGkgLyB0aGlzLm9wdGlvbnMuY29sTGltaXQpO1xuICAgIH1cblxuICAgIHZhciBqID0gdGhpcy5fZG9tYWluVHlwZVt0aGlzLm9wdGlvbnMuc3ViRG9tYWluXS5kZWZhdWx0Um93TnVtYmVyO1xuICAgIGlmICh0eXBlb2YgaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaiA9IGooZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucm93TGltaXQgfHwgajtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgY2xhc3NuYW1lIGlmIHRoZSBzcGVjaWZpZWQgZGF0ZSBzaG91bGQgYmUgaGlnaGxpZ2h0ZWRcbiAgICpcbiAgICogQHBhcmFtICB0aW1lc3RhbXAgZGF0ZSBEYXRlIG9mIHRoZSBjdXJyZW50IHN1YkRvbWFpblxuICAgKiBAcmV0dXJuIFN0cmluZyB0aGUgaGlnaGxpZ2h0IGNsYXNzXG4gICAqL1xuICBnZXRIaWdobGlnaHRDbGFzc05hbWU6IGZ1bmN0aW9uIChkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZCA9IG5ldyBEYXRlKGQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGVJc0VxdWFsKHRoaXMub3B0aW9ucy5oaWdobGlnaHRbaV0sIGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNOb3codGhpcy5vcHRpb25zLmhpZ2hsaWdodFtpXSlcbiAgICAgICAgICAgID8gJyBoaWdobGlnaHQtbm93J1xuICAgICAgICAgICAgOiAnIGhpZ2hsaWdodCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIGRhdGUgaXMgbm93LFxuICAgKiBhY2NvcmRpbmcgdG8gdGhlIHR5cGUgb2Ygc3ViZG9tYWluXG4gICAqXG4gICAqIEBwYXJhbSAgRGF0ZSBkIFRoZSBkYXRlIHRvIGNvbXBhcmVcbiAgICogQHJldHVybiBib29sIFRydWUgaWYgdGhlIGRhdGUgY29ycmVzcG9uZCB0byBhIHN1YmRvbWFpbiBjZWxsXG4gICAqL1xuICBpc05vdzogZnVuY3Rpb24gKGQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRlSXNFcXVhbChkLCBuZXcgRGF0ZSgpKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgMiBkYXRlcyBhcmUgZXF1YWxzXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgc3ViZG9tYWluLWF3YXJlLFxuICAgKiBhbmQgZGF0ZXMgY29tcGFyaXNvbiBhcmUgZGVwZW5kZW50IG9mIHRoZSBzdWJkb21haW5cbiAgICpcbiAgICogQHBhcmFtICBEYXRlIGRhdGVBIEZpcnN0IGRhdGUgdG8gY29tcGFyZVxuICAgKiBAcGFyYW0gIERhdGUgZGF0ZUIgU2Vjb24gZGF0ZSB0byBjb21wYXJlXG4gICAqIEByZXR1cm4gYm9vbCB0cnVlIGlmIHRoZSAyIGRhdGVzIGFyZSBlcXVhbHNcbiAgICovXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiBmYWxzZSAqL1xuICBkYXRlSXNFcXVhbDogZnVuY3Rpb24gKGRhdGVBLCBkYXRlQikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghKGRhdGVBIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIGRhdGVBID0gbmV3IERhdGUoZGF0ZUEpO1xuICAgIH1cblxuICAgIGlmICghKGRhdGVCIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIGRhdGVCID0gbmV3IERhdGUoZGF0ZUIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnN1YkRvbWFpbikge1xuICAgICAgY2FzZSAneF9taW4nOlxuICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRlQS5nZXRGdWxsWWVhcigpID09PSBkYXRlQi5nZXRGdWxsWWVhcigpICYmXG4gICAgICAgICAgZGF0ZUEuZ2V0TW9udGgoKSA9PT0gZGF0ZUIuZ2V0TW9udGgoKSAmJlxuICAgICAgICAgIGRhdGVBLmdldERhdGUoKSA9PT0gZGF0ZUIuZ2V0RGF0ZSgpICYmXG4gICAgICAgICAgZGF0ZUEuZ2V0SG91cnMoKSA9PT0gZGF0ZUIuZ2V0SG91cnMoKSAmJlxuICAgICAgICAgIGRhdGVBLmdldE1pbnV0ZXMoKSA9PT0gZGF0ZUIuZ2V0TWludXRlcygpXG4gICAgICAgICk7XG4gICAgICBjYXNlICd4X2hvdXInOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZGF0ZUEuZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZUIuZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgIGRhdGVBLmdldE1vbnRoKCkgPT09IGRhdGVCLmdldE1vbnRoKCkgJiZcbiAgICAgICAgICBkYXRlQS5nZXREYXRlKCkgPT09IGRhdGVCLmdldERhdGUoKSAmJlxuICAgICAgICAgIGRhdGVBLmdldEhvdXJzKCkgPT09IGRhdGVCLmdldEhvdXJzKClcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgJ3hfZGF5JzpcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZGF0ZUEuZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZUIuZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgIGRhdGVBLmdldE1vbnRoKCkgPT09IGRhdGVCLmdldE1vbnRoKCkgJiZcbiAgICAgICAgICBkYXRlQS5nZXREYXRlKCkgPT09IGRhdGVCLmdldERhdGUoKVxuICAgICAgICApO1xuICAgICAgY2FzZSAneF93ZWVrJzpcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGRhdGVBLmdldEZ1bGxZZWFyKCkgPT09IGRhdGVCLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgICAgICB0aGlzLmdldFdlZWtOdW1iZXIoZGF0ZUEpID09PSB0aGlzLmdldFdlZWtOdW1iZXIoZGF0ZUIpXG4gICAgICAgICk7XG4gICAgICBjYXNlICd4X21vbnRoJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkYXRlQS5nZXRGdWxsWWVhcigpID09PSBkYXRlQi5nZXRGdWxsWWVhcigpICYmXG4gICAgICAgICAgZGF0ZUEuZ2V0TW9udGgoKSA9PT0gZGF0ZUIuZ2V0TW9udGgoKVxuICAgICAgICApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB3ZXRoZXIgb3Igbm90IGRhdGVBIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBkYXRlQi4gVGhpcyBmdW5jdGlvbiBpcyBzdWJkb21haW4gYXdhcmUuXG4gICAqIFBlcmZvcm1zIGF1dG9tYXRpYyBjb252ZXJzaW9uIG9mIHZhbHVlcy5cbiAgICogQHBhcmFtIGRhdGVBIG1heSBiZSBhIG51bWJlciBvciBhIERhdGVcbiAgICogQHBhcmFtIGRhdGVCIG1heSBiZSBhIG51bWJlciBvciBhIERhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBkYXRlSXNMZXNzVGhhbjogZnVuY3Rpb24gKGRhdGVBLCBkYXRlQikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICghKGRhdGVBIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIGRhdGVBID0gbmV3IERhdGUoZGF0ZUEpO1xuICAgIH1cblxuICAgIGlmICghKGRhdGVCIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIGRhdGVCID0gbmV3IERhdGUoZGF0ZUIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZWRNaWxsaXMoZGF0ZSwgc3ViZG9tYWluKSB7XG4gICAgICBzd2l0Y2ggKHN1YmRvbWFpbikge1xuICAgICAgICBjYXNlICd4X21pbic6XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgICApLmdldFRpbWUoKTtcbiAgICAgICAgY2FzZSAneF9ob3VyJzpcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgICAgKS5nZXRUaW1lKCk7XG4gICAgICAgIGNhc2UgJ3hfZGF5JzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgICApLmdldFRpbWUoKTtcbiAgICAgICAgY2FzZSAneF93ZWVrJzpcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ3hfbW9udGgnOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpKS5nZXRUaW1lKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBub3JtYWxpemVkTWlsbGlzKGRhdGVBLCB0aGlzLm9wdGlvbnMuc3ViRG9tYWluKSA8XG4gICAgICBub3JtYWxpemVkTWlsbGlzKGRhdGVCLCB0aGlzLm9wdGlvbnMuc3ViRG9tYWluKVxuICAgICk7XG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4gIC8vIERBVEUgQ09NUFVUQVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkYXkgb2YgdGhlIHllYXIgZm9yIHRoZSBkYXRlXG4gICAqIEBwYXJhbSAgRGF0ZVxuICAgKiBAcmV0dXJuICBpbnQgRGF5IG9mIHRoZSB5ZWFyIFsxLDM2Nl1cbiAgICovXG4gIGdldERheU9mWWVhcjogZDMudGltZS5mb3JtYXQoJyVqJyksXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHllYXJcbiAgICogTW9uZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcbiAgICogQHJldHVybiBpbnQgIFdlZWsgbnVtYmVyIFswLTUzXVxuICAgKi9cbiAgZ2V0V2Vla051bWJlcjogZnVuY3Rpb24gKGQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZiA9XG4gICAgICB0aGlzLm9wdGlvbnMud2Vla1N0YXJ0T25Nb25kYXkgPT09IHRydWVcbiAgICAgICAgPyBkMy50aW1lLmZvcm1hdCgnJVcnKVxuICAgICAgICA6IGQzLnRpbWUuZm9ybWF0KCclVScpO1xuICAgIHJldHVybiBmKGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHdlZWsgbnVtYmVyLCByZWxhdGl2ZSB0byBpdHMgbW9udGhcbiAgICpcbiAgICogQHBhcmFtICBpbnR8RGF0ZSBkIERhdGUgb3IgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIGludCBXZWVrIG51bWJlciwgcmVsYXRpdmUgdG8gdGhlIG1vbnRoIFswLTVdXG4gICAqL1xuICBnZXRNb250aFdlZWtOdW1iZXI6IGZ1bmN0aW9uIChkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xuICAgICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIH1cblxuICAgIHZhciBtb250aEZpcnN0V2Vla051bWJlciA9IHRoaXMuZ2V0V2Vla051bWJlcihcbiAgICAgIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpKSxcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmdldFdlZWtOdW1iZXIoZCkgLSBtb250aEZpcnN0V2Vla051bWJlciAtIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoZSBkYXRlcycgeWVhclxuICAgKlxuICAgKiBAcGFyYW0gIGludHxEYXRlIGQgRGF0ZSBvciB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4gaW50IE51bWJlciBvZiB3ZWVrcyBpbiB0aGUgZGF0ZSdzIHllYXJcbiAgICovXG4gIGdldFdlZWtOdW1iZXJJblllYXI6IGZ1bmN0aW9uIChkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xuICAgICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgZGF0ZSdzIG1vbnRoXG4gICAqXG4gICAqIEBwYXJhbSAgaW50fERhdGUgZCBEYXRlIG9yIHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiBpbnQgTnVtYmVyIG9mIGRheXMgaW4gdGhlIGRhdGUncyBtb250aFxuICAgKi9cbiAgZ2V0RGF5Q291bnRJbk1vbnRoOiBmdW5jdGlvbiAoZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLmdldEVuZE9mTW9udGgoZCkuZ2V0RGF0ZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBkYXRlJ3MgeWVhclxuICAgKlxuICAgKiBAcGFyYW0gIGludHxEYXRlIGQgRGF0ZSBvciB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4gaW50IE51bWJlciBvZiBkYXlzIGluIHRoZSBkYXRlJ3MgeWVhclxuICAgKi9cbiAgZ2V0RGF5Q291bnRJblllYXI6IGZ1bmN0aW9uIChkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xuICAgICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAxLCAyOSkuZ2V0TW9udGgoKSA9PT0gMSA/IDM2NiA6IDM2NTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrZGF5IGZyb20gYSBkYXRlXG4gICAqXG4gICAqIFJldHVybiB0aGUgd2VlayBkYXkgbnVtYmVyICgwLTYpIG9mIGEgZGF0ZSxcbiAgICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHdlZWsgc3RhcnQgb24gbW9uZGF5IG9yIHN1bmRheVxuICAgKlxuICAgKiBAcGFyYW0gIERhdGUgZFxuICAgKiBAcmV0dXJuIGludCBUaGUgd2VlayBkYXkgbnVtYmVyICgwLTYpXG4gICAqL1xuICBnZXRXZWVrRGF5OiBmdW5jdGlvbiAoZCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMud2Vla1N0YXJ0T25Nb25kYXkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZC5nZXREYXkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGQuZ2V0RGF5KCkgPT09IDAgPyA2IDogZC5nZXREYXkoKSAtIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAqIEBwYXJhbSAgRGF0ZXxpbnQgIGQgIERhdGUgb3IgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIERhdGUgICAgICBMYXN0IGRheSBvZiB0aGUgbW9udGhcbiAgICovXG4gIGdldEVuZE9mTW9udGg6IGZ1bmN0aW9uIChkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xuICAgICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkgKyAxLCAwKTtcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtICBEYXRlIGRhdGVcbiAgICogQHBhcmFtICBpbnQgY291bnRcbiAgICogQHBhcmFtICBzdHJpbmcgc3RlcFxuICAgKiBAcmV0dXJuIERhdGVcbiAgICovXG4gIGp1bXBEYXRlOiBmdW5jdGlvbiAoZGF0ZSwgY291bnQsIHN0ZXApIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgIGQuc2V0SG91cnMoZC5nZXRIb3VycygpICsgY291bnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGQuc2V0SG91cnMoZC5nZXRIb3VycygpICsgY291bnQgKiAyNCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGQuc2V0SG91cnMoZC5nZXRIb3VycygpICsgY291bnQgKiAyNCAqIDcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgZC5zZXRNb250aChkLmdldE1vbnRoKCkgKyBjb3VudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgIGQuc2V0RnVsbFllYXIoZC5nZXRGdWxsWWVhcigpICsgY291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShkKTtcbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbiAgLy8gRE9NQUlOIENPTVBVVEFUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHRoZSBtaW51dGVzIGJldHdlZW4gMiBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gIERhdGUgIGQgIGRhdGUgIEEgZGF0ZVxuICAgKiBAcGFyYW0gIGludHxkYXRlICByYW5nZSAgTnVtYmVyIG9mIG1pbnV0ZXMgaW4gdGhlIHJhbmdlLCBvciBhIHN0b3AgZGF0ZVxuICAgKiBAcmV0dXJuIGFycmF5ICBBbiBhcnJheSBvZiBtaW51dGVzXG4gICAqL1xuICBnZXRNaW51dGVEb21haW46IGZ1bmN0aW9uIChkLCByYW5nZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKFxuICAgICAgZC5nZXRGdWxsWWVhcigpLFxuICAgICAgZC5nZXRNb250aCgpLFxuICAgICAgZC5nZXREYXRlKCksXG4gICAgICBkLmdldEhvdXJzKCksXG4gICAgKTtcbiAgICB2YXIgc3RvcCA9IG51bGw7XG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgc3RvcCA9IG5ldyBEYXRlKFxuICAgICAgICByYW5nZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICByYW5nZS5nZXRNb250aCgpLFxuICAgICAgICByYW5nZS5nZXREYXRlKCksXG4gICAgICAgIHJhbmdlLmdldEhvdXJzKCksXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0YXJ0ICsgcmFuZ2UgKiAxMDAwICogNjApO1xuICAgIH1cbiAgICByZXR1cm4gZDMudGltZS5taW51dGVzKE1hdGgubWluKHN0YXJ0LCBzdG9wKSwgTWF0aC5tYXgoc3RhcnQsIHN0b3ApKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGFsbCB0aGUgaG91cnMgYmV0d2VlbiAyIGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSAgRGF0ZSAgZCAgQSBkYXRlXG4gICAqIEBwYXJhbSAgaW50fGRhdGUgIHJhbmdlICBOdW1iZXIgb2YgaG91cnMgaW4gdGhlIHJhbmdlLCBvciBhIHN0b3AgZGF0ZVxuICAgKiBAcmV0dXJuIGFycmF5ICBBbiBhcnJheSBvZiBob3Vyc1xuICAgKi9cbiAgZ2V0SG91ckRvbWFpbjogZnVuY3Rpb24gKGQsIHJhbmdlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoXG4gICAgICBkLmdldEZ1bGxZZWFyKCksXG4gICAgICBkLmdldE1vbnRoKCksXG4gICAgICBkLmdldERhdGUoKSxcbiAgICAgIGQuZ2V0SG91cnMoKSxcbiAgICApO1xuICAgIHZhciBzdG9wID0gbnVsbDtcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBzdG9wID0gbmV3IERhdGUoXG4gICAgICAgIHJhbmdlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgIHJhbmdlLmdldE1vbnRoKCksXG4gICAgICAgIHJhbmdlLmdldERhdGUoKSxcbiAgICAgICAgcmFuZ2UuZ2V0SG91cnMoKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShzdGFydCk7XG4gICAgICBzdG9wLnNldEhvdXJzKHN0b3AuZ2V0SG91cnMoKSArIHJhbmdlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWlucyA9IGQzLnRpbWUuaG91cnMoTWF0aC5taW4oc3RhcnQsIHN0b3ApLCBNYXRoLm1heChzdGFydCwgc3RvcCkpO1xuXG4gICAgLy8gUGFzc2luZyBmcm9tIERTVCB0byBzdGFuZGFyZCB0aW1lXG4gICAgLy8gSWYgdGhlcmUgYXJlIDI1IGhvdXJzLCBsZXQncyBjb21wcmVzcyB0aGUgZHVwbGljYXRlIGhvdXJzXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciB0b3RhbCA9IGRvbWFpbnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbDsgaSArPSAxKSB7XG4gICAgICBpZiAoaSA+IDAgJiYgZG9tYWluc1tpXS5nZXRIb3VycygpID09PSBkb21haW5zW2kgLSAxXS5nZXRIb3VycygpKSB7XG4gICAgICAgIHRoaXMuRFNURG9tYWluLnB1c2goZG9tYWluc1tpXS5nZXRUaW1lKCkpO1xuICAgICAgICBkb21haW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZDMudGltZS5ob3VycyBpcyByZXR1cm5pbmcgbW9yZSBob3VycyB0aGFuIG5lZWRlZCB3aGVuIGNoYW5naW5nXG4gICAgLy8gZnJvbSBEU1QgdG8gc3RhbmRhcmQgdGltZSwgYmVjYXVzZSB0aGVyZSBpcyByZWFsbHkgMiBob3VycyBiZXR3ZWVuXG4gICAgLy8gMWFtIGFuZCAyYW0hXG4gICAgaWYgKHR5cGVvZiByYW5nZSA9PT0gJ251bWJlcicgJiYgZG9tYWlucy5sZW5ndGggPiBNYXRoLmFicyhyYW5nZSkpIHtcbiAgICAgIGRvbWFpbnMuc3BsaWNlKGRvbWFpbnMubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbWFpbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdGhlIGRheXMgYmV0d2VlbiAyIGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSAgRGF0ZSAgICBkICAgIEEgZGF0ZVxuICAgKiBAcGFyYW0gIGludHxkYXRlICByYW5nZSAgTnVtYmVyIG9mIGRheXMgaW4gdGhlIHJhbmdlLCBvciBhIHN0b3AgZGF0ZVxuICAgKiBAcmV0dXJuIGFycmF5ICBBbiBhcnJheSBvZiB3ZWVrc1xuICAgKi9cbiAgZ2V0RGF5RG9tYWluOiBmdW5jdGlvbiAoZCwgcmFuZ2UpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICAgIHZhciBzdG9wID0gbnVsbDtcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBzdG9wID0gbmV3IERhdGUocmFuZ2UuZ2V0RnVsbFllYXIoKSwgcmFuZ2UuZ2V0TW9udGgoKSwgcmFuZ2UuZ2V0RGF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcCA9IG5ldyBEYXRlKHN0YXJ0KTtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShzdG9wLnNldERhdGUoc3RvcC5nZXREYXRlKCkgKyBwYXJzZUludChyYW5nZSwgMTApKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQzLnRpbWUuZGF5cyhNYXRoLm1pbihzdGFydCwgc3RvcCksIE1hdGgubWF4KHN0YXJ0LCBzdG9wKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdGhlIHdlZWtzIGJldHdlZW4gMiBkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0gIERhdGUgIGQgIEEgZGF0ZVxuICAgKiBAcGFyYW0gIGludHxkYXRlICByYW5nZSAgTnVtYmVyIG9mIG1pbnV0ZXMgaW4gdGhlIHJhbmdlLCBvciBhIHN0b3AgZGF0ZVxuICAgKiBAcmV0dXJuIGFycmF5ICBBbiBhcnJheSBvZiB3ZWVrc1xuICAgKi9cbiAgZ2V0V2Vla0RvbWFpbjogZnVuY3Rpb24gKGQsIHJhbmdlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHdlZWtTdGFydDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMud2Vla1N0YXJ0T25Nb25kYXkgPT09IGZhbHNlKSB7XG4gICAgICB3ZWVrU3RhcnQgPSBuZXcgRGF0ZShcbiAgICAgICAgZC5nZXRGdWxsWWVhcigpLFxuICAgICAgICBkLmdldE1vbnRoKCksXG4gICAgICAgIGQuZ2V0RGF0ZSgpIC0gZC5nZXREYXkoKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkLmdldERheSgpID09PSAxKSB7XG4gICAgICAgIHdlZWtTdGFydCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gICAgICB9IGVsc2UgaWYgKGQuZ2V0RGF5KCkgPT09IDApIHtcbiAgICAgICAgd2Vla1N0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcbiAgICAgICAgd2Vla1N0YXJ0LnNldERhdGUod2Vla1N0YXJ0LmdldERhdGUoKSAtIDYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2Vla1N0YXJ0ID0gbmV3IERhdGUoXG4gICAgICAgICAgZC5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgIGQuZ2V0TW9udGgoKSxcbiAgICAgICAgICBkLmdldERhdGUoKSAtIGQuZ2V0RGF5KCkgKyAxLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbmREYXRlID0gbmV3IERhdGUod2Vla1N0YXJ0KTtcblxuICAgIHZhciBzdG9wID0gcmFuZ2U7XG4gICAgaWYgKHR5cGVvZiByYW5nZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShlbmREYXRlLnNldERhdGUoZW5kRGF0ZS5nZXREYXRlKCkgKyByYW5nZSAqIDcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLndlZWtTdGFydE9uTW9uZGF5ID09PSB0cnVlXG4gICAgICA/IGQzLnRpbWUubW9uZGF5cyhNYXRoLm1pbih3ZWVrU3RhcnQsIHN0b3ApLCBNYXRoLm1heCh3ZWVrU3RhcnQsIHN0b3ApKVxuICAgICAgOiBkMy50aW1lLnN1bmRheXMoTWF0aC5taW4od2Vla1N0YXJ0LCBzdG9wKSwgTWF0aC5tYXgod2Vla1N0YXJ0LCBzdG9wKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdGhlIG1vbnRocyBiZXR3ZWVuIDIgZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtICBEYXRlICAgIGQgICAgQSBkYXRlXG4gICAqIEBwYXJhbSAgaW50fGRhdGUgIHJhbmdlICBOdW1iZXIgb2YgbW9udGhzIGluIHRoZSByYW5nZSwgb3IgYSBzdG9wIGRhdGVcbiAgICogQHJldHVybiBhcnJheSAgQW4gYXJyYXkgb2YgbW9udGhzXG4gICAqL1xuICBnZXRNb250aERvbWFpbjogZnVuY3Rpb24gKGQsIHJhbmdlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpO1xuICAgIHZhciBzdG9wID0gbnVsbDtcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBzdG9wID0gbmV3IERhdGUocmFuZ2UuZ2V0RnVsbFllYXIoKSwgcmFuZ2UuZ2V0TW9udGgoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShzdGFydCk7XG4gICAgICBzdG9wID0gc3RvcC5zZXRNb250aChzdG9wLmdldE1vbnRoKCkgKyByYW5nZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQzLnRpbWUubW9udGhzKE1hdGgubWluKHN0YXJ0LCBzdG9wKSwgTWF0aC5tYXgoc3RhcnQsIHN0b3ApKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGFsbCB0aGUgeWVhcnMgYmV0d2VlbiAyIGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSAgRGF0ZSAgZCAgZGF0ZSAgQSBkYXRlXG4gICAqIEBwYXJhbSAgaW50fGRhdGUgIHJhbmdlICBOdW1iZXIgb2YgbWludXRlcyBpbiB0aGUgcmFuZ2UsIG9yIGEgc3RvcCBkYXRlXG4gICAqIEByZXR1cm4gYXJyYXkgIEFuIGFycmF5IG9mIGhvdXJzXG4gICAqL1xuICBnZXRZZWFyRG9tYWluOiBmdW5jdGlvbiAoZCwgcmFuZ2UpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDApO1xuICAgIHZhciBzdG9wID0gbnVsbDtcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBzdG9wID0gbmV3IERhdGUocmFuZ2UuZ2V0RnVsbFllYXIoKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCkgKyByYW5nZSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQzLnRpbWUueWVhcnMoTWF0aC5taW4oc3RhcnQsIHN0b3ApLCBNYXRoLm1heChzdGFydCwgc3RvcCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYXJyYXkgb2YgZG9tYWluIHN0YXJ0IGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSAgaW50fERhdGUgZGF0ZSBBIHJhbmRvbSBkYXRlIGluY2x1ZGVkIGluIHRoZSB3YW50ZWQgZG9tYWluXG4gICAqIEBwYXJhbSAgaW50fERhdGUgcmFuZ2UgTnVtYmVyIG9mIGRhdGVzIHRvIGdldCwgb3IgYSBzdG9wIGRhdGVcbiAgICogQHJldHVybiBBcnJheSBvZiBkYXRlc1xuICAgKi9cbiAgZ2V0RG9tYWluOiBmdW5jdGlvbiAoZGF0ZSwgcmFuZ2UpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByYW5nZSA9IHRoaXMub3B0aW9ucy5yYW5nZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5kb21haW4pIHtcbiAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0SG91ckRvbWFpbihkYXRlLCByYW5nZSk7XG5cbiAgICAgICAgLy8gQ2FzZSB3aGVyZSBhbiBob3VyIGlzIG1pc3NpbmcsIHdoZW4gcGFzc2luZyBmcm9tIHN0YW5kYXJkIHRpbWUgdG8gRFNUXG4gICAgICAgIC8vIE1pc3NpbmcgaG91ciBpcyBwZXJmZWN0bHkgYWNjZXB0YWJsIGluIHN1YkRvbWFpbiwgYnV0IG5vdCBpbiBkb21haW5zXG4gICAgICAgIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdudW1iZXInICYmIGRvbWFpbnMubGVuZ3RoIDwgcmFuZ2UpIHtcbiAgICAgICAgICBpZiAocmFuZ2UgPiAwKSB7XG4gICAgICAgICAgICBkb21haW5zLnB1c2godGhpcy5nZXRIb3VyRG9tYWluKGRvbWFpbnNbZG9tYWlucy5sZW5ndGggLSAxXSwgMilbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb21haW5zLnNoaWZ0KHRoaXMuZ2V0SG91ckRvbWFpbihkb21haW5zWzBdLCAtMilbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tYWlucztcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERheURvbWFpbihkYXRlLCByYW5nZSk7XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2Vla0RvbWFpbihkYXRlLCByYW5nZSk7XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoRG9tYWluKGRhdGUsIHJhbmdlKTtcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRZZWFyRG9tYWluKGRhdGUsIHJhbmdlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IGZhbHNlICovXG4gIGdldFN1YkRvbWFpbjogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGludFxuICAgICAqL1xuICAgIHZhciBjb21wdXRlRGF5U3ViRG9tYWluU2l6ZSA9IGZ1bmN0aW9uIChkYXRlLCBkb21haW4pIHtcbiAgICAgIHN3aXRjaCAoZG9tYWluKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgIHJldHVybiBwYXJlbnQuZ2V0RGF5Q291bnRJblllYXIoZGF0ZSk7XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmdldERheUNvdW50SW5Nb250aChkYXRlKTtcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgcmV0dXJuIDc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gaW50XG4gICAgICovXG4gICAgdmFyIGNvbXB1dGVNaW5TdWJEb21haW5TaXplID0gZnVuY3Rpb24gKGRhdGUsIGRvbWFpbikge1xuICAgICAgc3dpdGNoIChkb21haW4pIHtcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgcmV0dXJuIDYwO1xuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgIHJldHVybiA2MCAqIDI0O1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICByZXR1cm4gNjAgKiAyNCAqIDc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gaW50XG4gICAgICovXG4gICAgdmFyIGNvbXB1dGVIb3VyU3ViRG9tYWluU2l6ZSA9IGZ1bmN0aW9uIChkYXRlLCBkb21haW4pIHtcbiAgICAgIHN3aXRjaCAoZG9tYWluKSB7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgcmV0dXJuIDI0O1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICByZXR1cm4gMTY4O1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5nZXREYXlDb3VudEluTW9udGgoZGF0ZSkgKiAyNDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBpbnRcbiAgICAgKi9cbiAgICB2YXIgY29tcHV0ZVdlZWtTdWJEb21haW5TaXplID0gZnVuY3Rpb24gKGRhdGUsIGRvbWFpbikge1xuICAgICAgaWYgKGRvbWFpbiA9PT0gJ21vbnRoJykge1xuICAgICAgICB2YXIgZW5kT2ZNb250aCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCk7XG4gICAgICAgIHZhciBlbmRXZWVrTmIgPSBwYXJlbnQuZ2V0V2Vla051bWJlcihlbmRPZk1vbnRoKTtcbiAgICAgICAgdmFyIHN0YXJ0V2Vla05iID0gcGFyZW50LmdldFdlZWtOdW1iZXIoXG4gICAgICAgICAgbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkpLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzdGFydFdlZWtOYiA+IGVuZFdlZWtOYikge1xuICAgICAgICAgIHN0YXJ0V2Vla05iID0gMDtcbiAgICAgICAgICBlbmRXZWVrTmIgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbmRXZWVrTmIgLSBzdGFydFdlZWtOYiArIDE7XG4gICAgICB9IGVsc2UgaWYgKGRvbWFpbiA9PT0gJ3llYXInKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuZ2V0V2Vla051bWJlcihuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDExLCAzMSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zdWJEb21haW4pIHtcbiAgICAgIGNhc2UgJ3hfbWluJzpcbiAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1pbnV0ZURvbWFpbihcbiAgICAgICAgICBkYXRlLFxuICAgICAgICAgIGNvbXB1dGVNaW5TdWJEb21haW5TaXplKGRhdGUsIHRoaXMub3B0aW9ucy5kb21haW4pLFxuICAgICAgICApO1xuICAgICAgY2FzZSAneF9ob3VyJzpcbiAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRIb3VyRG9tYWluKFxuICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgY29tcHV0ZUhvdXJTdWJEb21haW5TaXplKGRhdGUsIHRoaXMub3B0aW9ucy5kb21haW4pLFxuICAgICAgICApO1xuICAgICAgY2FzZSAneF9kYXknOlxuICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF5RG9tYWluKFxuICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgY29tcHV0ZURheVN1YkRvbWFpblNpemUoZGF0ZSwgdGhpcy5vcHRpb25zLmRvbWFpbiksXG4gICAgICAgICk7XG4gICAgICBjYXNlICd4X3dlZWsnOlxuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdlZWtEb21haW4oXG4gICAgICAgICAgZGF0ZSxcbiAgICAgICAgICBjb21wdXRlV2Vla1N1YkRvbWFpblNpemUoZGF0ZSwgdGhpcy5vcHRpb25zLmRvbWFpbiksXG4gICAgICAgICk7XG4gICAgICBjYXNlICd4X21vbnRoJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9udGhEb21haW4oZGF0ZSwgMTIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBuLXRoIG5leHQgZG9tYWluIGFmdGVyIHRoZSBjYWxlbmRhciBuZXdlc3QgKHJpZ2h0bW9zdCkgZG9tYWluXG4gICAqIEBwYXJhbSAgaW50IG5cbiAgICogQHJldHVybiBEYXRlIFRoZSBzdGFydCBkYXRlIG9mIHRoZSB3YW50ZWQgZG9tYWluXG4gICAqL1xuICBnZXROZXh0RG9tYWluOiBmdW5jdGlvbiAobikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RG9tYWluKFxuICAgICAgdGhpcy5qdW1wRGF0ZSh0aGlzLmdldERvbWFpbktleXMoKS5wb3AoKSwgbiwgdGhpcy5vcHRpb25zLmRvbWFpbiksXG4gICAgICAxLFxuICAgIClbMF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBkb21haW4gYmVmb3JlIHRoZSBjYWxlbmRhciBvbGRlc3QgKGxlZnRtb3N0KSBkb21haW5cbiAgICogQHBhcmFtICBpbnQgblxuICAgKiBAcmV0dXJuIERhdGUgVGhlIHN0YXJ0IGRhdGUgb2YgdGhlIHdhbnRlZCBkb21haW5cbiAgICovXG4gIGdldFByZXZpb3VzRG9tYWluOiBmdW5jdGlvbiAobikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RG9tYWluKFxuICAgICAgdGhpcy5qdW1wRGF0ZSh0aGlzLmdldERvbWFpbktleXMoKS5zaGlmdCgpLCAtbiwgdGhpcy5vcHRpb25zLmRvbWFpbiksXG4gICAgICAxLFxuICAgIClbMF07XG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4gIC8vIERBVEFTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhbmQgaW50ZXJwcmV0IGRhdGEgZnJvbSB0aGUgZGF0YXNvdXJjZVxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nfG9iamVjdCBzb3VyY2VcbiAgICogQHBhcmFtIERhdGUgc3RhcnREYXRlXG4gICAqIEBwYXJhbSBEYXRlIGVuZERhdGVcbiAgICogQHBhcmFtIGZ1bmN0aW9uIGNhbGxiYWNrXG4gICAqIEBwYXJhbSBmdW5jdGlvbnxib29sZWFuIGFmdGVyTG9hZCBmdW5jdGlvbiB1c2VkIHRvIGNvbnZlcnQgdGhlIGRhdGEgaW50byBhIGpzb24gb2JqZWN0LiBVc2UgdHJ1ZSB0byB1c2UgdGhlIGFmdGVyTG9hZCBjYWxsYmFja1xuICAgKiBAcGFyYW0gdXBkYXRlTW9kZVxuICAgKlxuICAgKiBAcmV0dXJuIG1peGVkXG4gICAqIC0gVHJ1ZSBpZiB0aGVyZSBhcmUgbm8gZGF0YSB0byBsb2FkXG4gICAqIC0gRmFsc2UgaWYgZGF0YSBhcmUgbG9hZGVkIGFzeW5jaHJvbm91c2x5XG4gICAqL1xuICBnZXREYXRhczogZnVuY3Rpb24gKFxuICAgIHNvdXJjZSxcbiAgICBzdGFydERhdGUsXG4gICAgZW5kRGF0ZSxcbiAgICBjYWxsYmFjayxcbiAgICBhZnRlckxvYWQsXG4gICAgdXBkYXRlTW9kZSxcbiAgKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNSkge1xuICAgICAgYWZ0ZXJMb2FkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA2KSB7XG4gICAgICB1cGRhdGVNb2RlID0gdGhpcy5BUFBFTkRfT05fVVBEQVRFO1xuICAgIH1cbiAgICB2YXIgX2NhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yLCBkYXRhKSB7XG4gICAgICBpZiAoYWZ0ZXJMb2FkICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZW9mIGFmdGVyTG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRhdGEgPSBhZnRlckxvYWQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYub3B0aW9ucy5hZnRlckxvYWREYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGF0YSA9IHNlbGYub3B0aW9ucy5hZnRlckxvYWREYXRhKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm92aWRlZCBjYWxsYmFjayBmb3IgYWZ0ZXJMb2FkRGF0YSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgc2VsZi5vcHRpb25zLmRhdGFUeXBlID09PSAnY3N2JyB8fFxuICAgICAgICBzZWxmLm9wdGlvbnMuZGF0YVR5cGUgPT09ICd0c3YnXG4gICAgICApIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuaW50ZXJwcmV0Q1NWKGRhdGEpO1xuICAgICAgfVxuICAgICAgc2VsZi5wYXJzZURhdGFzKGRhdGEsIHVwZGF0ZU1vZGUsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHN3aXRjaCAodHlwZW9mIHNvdXJjZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJycpIHtcbiAgICAgICAgICBfY2FsbGJhY2sobnVsbCwge30pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnBhcnNlVVJJKHNvdXJjZSwgc3RhcnREYXRlLCBlbmREYXRlKTtcbiAgICAgICAgICB2YXIgcmVxdWVzdFR5cGUgPSAnR0VUJztcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmRhdGFQb3N0UGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVxdWVzdFR5cGUgPSAnUE9TVCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmRhdGFQb3N0UGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHRoaXMucGFyc2VVUkkoXG4gICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5kYXRhUG9zdFBheWxvYWQsXG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgZW5kRGF0ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHhociA9IG51bGw7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICB4aHIgPSBkMy5qc29uKHVybCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY3N2JzpcbiAgICAgICAgICAgICAgeGhyID0gZDMuY3N2KHVybCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHN2JzpcbiAgICAgICAgICAgICAgeGhyID0gZDMudHN2KHVybCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHh0JzpcbiAgICAgICAgICAgICAgeGhyID0gZDMudGV4dCh1cmwsICd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGpzaGludCBtYXhkZXB0aDo1XG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5kYXRhUmVxdWVzdEhlYWRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGhlYWRlciBpbiBzZWxmLm9wdGlvbnMuZGF0YVJlcXVlc3RIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZGF0YVJlcXVlc3RIZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICB4aHIuaGVhZGVyKGhlYWRlciwgc2VsZi5vcHRpb25zLmRhdGFSZXF1ZXN0SGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHhoci5zZW5kKHJlcXVlc3RUeXBlLCBwYXlsb2FkLCBfY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChzb3VyY2UgPT09IE9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKG51bGwsIHNvdXJjZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBfY2FsbGJhY2sobnVsbCwge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlIHRoZSBjYWxlbmRhciBpbnRlcm5hbCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBvYmplY3QgZGF0YVxuICAgKiBAcGFyYW0gY29uc3RhbnQgdXBkYXRlTW9kZVxuICAgKiBAcGFyYW0gRGF0ZSBzdGFydERhdGVcbiAgICogQHBhcmFtIERhdGUgZW5kRGF0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICovXG4gIHBhcnNlRGF0YXM6IGZ1bmN0aW9uIChkYXRhLCB1cGRhdGVNb2RlLCBzdGFydERhdGUsIGVuZERhdGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAodXBkYXRlTW9kZSA9PT0gdGhpcy5SRVNFVF9BTExfT05fVVBEQVRFKSB7XG4gICAgICB0aGlzLl9kb21haW5zLmZvckVhY2goZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlbaW5kZXhdLnYgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0ZW1wID0ge307XG5cbiAgICB2YXIgZXh0cmFjdFRpbWUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQudDtcbiAgICB9O1xuXG4gICAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgICBmb3IgKHZhciBkIGluIGRhdGEpIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoZCAqIDEwMDApO1xuICAgICAgdmFyIGRvbWFpblVuaXQgPSB0aGlzLmdldERvbWFpbihkYXRlKVswXS5nZXRUaW1lKCk7XG4gICAgICAvLyBUaGUgY3VycmVudCBkYXRhIGJlbG9uZ3MgdG8gYSBkb21haW4gdGhhdCB3YXMgY29tcHJlc3NlZFxuICAgICAgLy8gQ29tcHJlc3MgdGhlIGRhdGEgZm9yIHRoZSB0d28gZHVwbGljYXRlIGhvdXJzIGludG8gdGhlIHNhbWUgaG91clxuICAgICAgaWYgKHRoaXMuRFNURG9tYWluLmluZGV4T2YoZG9tYWluVW5pdCkgPj0gMCkge1xuICAgICAgICAvLyBSZS1hc3NpZ24gYWxsIGRhdGEgdG8gdGhlIGZpcnN0IG9yIHRoZSBzZWNvbmQgZHVwbGljYXRlIGhvdXJzXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGljaCBpcyB2aXNpYmxlXG4gICAgICAgIGlmICh0aGlzLl9kb21haW5zLmhhcyhkb21haW5Vbml0IC0gMzYwMCAqIDEwMDApKSB7XG4gICAgICAgICAgZG9tYWluVW5pdCAtPSAzNjAwICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGlmIGRhdGEgaXMgbm90IHJlbGV2YW50IHRvIGN1cnJlbnQgZG9tYWluXG4gICAgICBpZiAoXG4gICAgICAgIGlzTmFOKGQpIHx8XG4gICAgICAgICFkYXRhLmhhc093blByb3BlcnR5KGQpIHx8XG4gICAgICAgICF0aGlzLl9kb21haW5zLmhhcyhkb21haW5Vbml0KSB8fFxuICAgICAgICAhKGRvbWFpblVuaXQgPj0gK3N0YXJ0RGF0ZSAmJiBkb21haW5Vbml0IDwgK2VuZERhdGUpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJEb21haW5zRGF0YSA9IHRoaXMuX2RvbWFpbnMuZ2V0KGRvbWFpblVuaXQpO1xuXG4gICAgICBpZiAoIXRlbXAuaGFzT3duUHJvcGVydHkoZG9tYWluVW5pdCkpIHtcbiAgICAgICAgdGVtcFtkb21haW5Vbml0XSA9IHN1YkRvbWFpbnNEYXRhLm1hcChleHRyYWN0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHRlbXBbZG9tYWluVW5pdF0uaW5kZXhPZihcbiAgICAgICAgdGhpcy5fZG9tYWluVHlwZVt0aGlzLm9wdGlvbnMuc3ViRG9tYWluXS5leHRyYWN0VW5pdChkYXRlKSxcbiAgICAgICk7XG5cbiAgICAgIGlmICh1cGRhdGVNb2RlID09PSB0aGlzLlJFU0VUX1NJTkdMRV9PTl9VUERBVEUpIHtcbiAgICAgICAgc3ViRG9tYWluc0RhdGFbaW5kZXhdLnYgPSBkYXRhW2RdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc05hTihzdWJEb21haW5zRGF0YVtpbmRleF0udikpIHtcbiAgICAgICAgICBzdWJEb21haW5zRGF0YVtpbmRleF0udiArPSBkYXRhW2RdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YkRvbWFpbnNEYXRhW2luZGV4XS52ID0gZGF0YVtkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwYXJzZVVSSTogZnVuY3Rpb24gKHN0ciwgc3RhcnREYXRlLCBlbmREYXRlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gVXNlIGEgdGltZXN0YW1wIGluIHNlY29uZHNcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7XFx7dDpzdGFydFxcfVxcfS9nLCBzdGFydERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xce1xce3Q6ZW5kXFx9XFx9L2csIGVuZERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XG5cbiAgICAvLyBVc2UgYSBzdHJpbmcgZGF0ZSwgZm9sbG93aW5nIHRoZSBJU08tODYwMVxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHtcXHtkOnN0YXJ0XFx9XFx9L2csIHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpKTtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7XFx7ZDplbmRcXH1cXH0vZywgZW5kRGF0ZS50b0lTT1N0cmluZygpKTtcblxuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgaW50ZXJwcmV0Q1NWOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBkID0ge307XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcbiAgICB2YXIgaSwgdG90YWw7XG4gICAgZm9yIChpID0gMCwgdG90YWwgPSBkYXRhLmxlbmd0aDsgaSA8IHRvdGFsOyBpICs9IDEpIHtcbiAgICAgIGRbZGF0YVtpXVtrZXlzWzBdXV0gPSArZGF0YVtpXVtrZXlzWzFdXTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0aGUgY2FsZW5kYXIgbGF5b3V0IGFuZCBkaW1lbnNpb25cbiAgICpcbiAgICogRXhwYW5kIGFuZCBzaHJpbmsgdGhlIGNvbnRhaW5lciBkZXBlbmRpbmcgb24gaXRzIGNoaWxkcmVuIGRpbWVuc2lvblxuICAgKiBBbHNvIHJlYXJyYW5nZSB0aGUgY2hpbGRyZW4gcG9zaXRpb24gZGVwZW5kaW5nIG9uIHRoZWlyIGRpbWVuc2lvbixcbiAgICogYW5kIHRoZSBsZWdlbmQgcG9zaXRpb25cbiAgICpcbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuICByZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmVudC5vcHRpb25zO1xuICAgIHZhciBsZWdlbmRXaWR0aCA9IG9wdGlvbnMuZGlzcGxheUxlZ2VuZFxuICAgICAgPyBwYXJlbnQuTGVnZW5kLmdldERpbSgnd2lkdGgnKSArXG4gICAgICAgIG9wdGlvbnMubGVnZW5kTWFyZ2luWzFdICtcbiAgICAgICAgb3B0aW9ucy5sZWdlbmRNYXJnaW5bM11cbiAgICAgIDogMDtcbiAgICB2YXIgbGVnZW5kSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5TGVnZW5kXG4gICAgICA/IHBhcmVudC5MZWdlbmQuZ2V0RGltKCdoZWlnaHQnKSArXG4gICAgICAgIG9wdGlvbnMubGVnZW5kTWFyZ2luWzBdICtcbiAgICAgICAgb3B0aW9ucy5sZWdlbmRNYXJnaW5bMl1cbiAgICAgIDogMDtcblxuICAgIHZhciBncmFwaFdpZHRoID1cbiAgICAgIHBhcmVudC5ncmFwaERpbS53aWR0aCAtIG9wdGlvbnMuZG9tYWluR3V0dGVyIC0gb3B0aW9ucy5jZWxsUGFkZGluZztcbiAgICB2YXIgZ3JhcGhIZWlnaHQgPVxuICAgICAgcGFyZW50LmdyYXBoRGltLmhlaWdodCAtIG9wdGlvbnMuZG9tYWluR3V0dGVyIC0gb3B0aW9ucy5jZWxsUGFkZGluZztcblxuICAgIHRoaXMucm9vdFxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXG4gICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdtaWRkbGUnIHx8XG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRWZXJ0aWNhbFBvc2l0aW9uID09PSAnY2VudGVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZ3JhcGhXaWR0aCArIGxlZ2VuZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heChncmFwaFdpZHRoLCBsZWdlbmRXaWR0aCk7XG4gICAgICB9KVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbiA9PT0gJ21pZGRsZScgfHxcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdjZW50ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChncmFwaEhlaWdodCwgbGVnZW5kSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JhcGhIZWlnaHQgKyBsZWdlbmRIZWlnaHQ7XG4gICAgICB9KTtcblxuICAgIHRoaXMucm9vdFxuICAgICAgLnNlbGVjdCgnLmdyYXBoJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKVxuICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZ2VuZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdtaWRkbGUnIHx8XG4gICAgICAgICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdjZW50ZXInKSAmJlxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kSG9yaXpvbnRhbFBvc2l0aW9uID09PSAnbGVmdCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZ2VuZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4gIC8vIFBVQkxJQyBBUEkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4gIC8qKlxuICAgKiBTaGlmdCB0aGUgY2FsZW5kYXIgZm9yd2FyZFxuICAgKi9cbiAgbmV4dDogZnVuY3Rpb24gKG4pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbiA9IDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWROZXh0RG9tYWluKG4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaGlmdCB0aGUgY2FsZW5kYXIgYmFja3dhcmRcbiAgICovXG4gIHByZXZpb3VzOiBmdW5jdGlvbiAobikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZFByZXZpb3VzRG9tYWluKG4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBKdW1wIGRpcmVjdGx5IHRvIGEgc3BlY2lmaWMgZGF0ZVxuICAgKlxuICAgKiBKdW1wVG8gd2lsbCBzY3JvbGwgdGhlIGNhbGVuZGFyIHVudGlsIHRoZSB3YW50ZWQgZG9tYWluIHdpdGggdGhlIHNwZWNpZmllZFxuICAgKiBkYXRlIGlzIHZpc2libGUuIFVubGVzcyB5b3Ugc2V0IHJlc2V0IHRvIHRydWUsIHRoZSB3YW50ZWQgZG9tYWluXG4gICAqIHdpbGwgbm90IG5lY2Vzc2FyaWx5IGJlIHRoZSBmaXJzdCAobGVmdG1vc3QpIGRvbWFpbiBvZiB0aGUgY2FsZW5kYXIuXG4gICAqXG4gICAqIEBwYXJhbSBEYXRlIGRhdGUgSnVtcCB0byB0aGUgZG9tYWluIGNvbnRhaW5pbmcgdGhhdCBkYXRlXG4gICAqIEBwYXJhbSBib29sIHJlc2V0IFdoZXRoZXIgdGhlIHdhbnRlZCBkb21haW4gc2hvdWxkIGJlIHRoZSBmaXJzdCBkb21haW4gb2YgdGhlIGNhbGVuZGFyXG4gICAqIEBwYXJhbSBib29sIFRydWUgb2YgdGhlIGNhbGVuZGFyIHdhcyBzY3JvbGxlZFxuICAgKi9cbiAganVtcFRvOiBmdW5jdGlvbiAoZGF0ZSwgcmVzZXQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJlc2V0ID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBkb21haW5zID0gdGhpcy5nZXREb21haW5LZXlzKCk7XG4gICAgdmFyIGZpcnN0RG9tYWluID0gZG9tYWluc1swXTtcbiAgICB2YXIgbGFzdERvbWFpbiA9IGRvbWFpbnNbZG9tYWlucy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChkYXRlIDwgZmlyc3REb21haW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRQcmV2aW91c0RvbWFpbih0aGlzLmdldERvbWFpbihmaXJzdERvbWFpbiwgZGF0ZSkubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWROZXh0RG9tYWluKHRoaXMuZ2V0RG9tYWluKGZpcnN0RG9tYWluLCBkYXRlKS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0ZSA+IGxhc3REb21haW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE5leHREb21haW4odGhpcy5nZXREb21haW4obGFzdERvbWFpbiwgZGF0ZSkubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIGJhY2sgdG8gdGhlIHN0YXJ0IGRhdGVcbiAgICpcbiAgICogQHNpbmNlICAzLjMuOFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICovXG4gIHJld2luZDogZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuanVtcFRvKHRoaXMub3B0aW9ucy5zdGFydCwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY2FsZW5kYXIgd2l0aCBuZXcgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gIG9iamVjdHxzdHJpbmcgICAgZGF0YVNvdXJjZSAgICBUaGUgY2FsZW5kYXIncyBkYXRhc291cmNlLCBzYW1lIHR5cGUgYXMgdGhpcy5vcHRpb25zLmRhdGFcbiAgICogQHBhcmFtICBib29sZWFufGZ1bmN0aW9uICAgIGFmdGVyTG9hZCAgICBXaGV0aGVyIHRvIGV4ZWN1dGUgYWZ0ZXJMb2FkKCkgb24gdGhlIGRhdGEuIFBhc3MgZGlyZWN0bHkgYSBmdW5jdGlvblxuICAgKiBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIGFmdGVyTG9hZCgpIGNhbGxiYWNrXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhU291cmNlLCBhZnRlckxvYWQsIHVwZGF0ZU1vZGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGF0YVNvdXJjZSA9IHRoaXMub3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGFmdGVyTG9hZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgdXBkYXRlTW9kZSA9IHRoaXMuUkVTRVRfQUxMX09OX1VQREFURTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0RG9tYWluS2V5cygpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmdldERhdGFzKFxuICAgICAgZGF0YVNvdXJjZSxcbiAgICAgIG5ldyBEYXRlKGRvbWFpbnNbMF0pLFxuICAgICAgdGhpcy5nZXRTdWJEb21haW4oZG9tYWluc1tkb21haW5zLmxlbmd0aCAtIDFdKS5wb3AoKSxcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5maWxsKCk7XG4gICAgICAgIHNlbGYuYWZ0ZXJVcGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxvYWQsXG4gICAgICB1cGRhdGVNb2RlLFxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGVnZW5kXG4gICAqXG4gICAqIEBwYXJhbSBhcnJheSBsZWdlbmQgYW4gYXJyYXkgb2YgaW50ZWdlciwgcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgdGhyZXNob2xkIHZhbHVlXG4gICAqIEBwYXJhbSBhcnJheSBjb2xvclJhbmdlIGFuIGFycmF5IG9mIDIgaGV4IGNvbG9ycywgZm9yIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvbG9yc1xuICAgKi9cbiAgc2V0TGVnZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9sZExlZ2VuZCA9IHRoaXMub3B0aW9ucy5sZWdlbmQuc2xpY2UoMCk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5sZWdlbmQgPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkgJiYgYXJndW1lbnRzWzFdLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZWdlbmRDb2xvcnMgPSBbYXJndW1lbnRzWzFdWzBdLCBhcmd1bWVudHNbMV1bMV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlZ2VuZENvbG9ycyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgIWFycmF5RXF1YWxzKG9sZExlZ2VuZCwgdGhpcy5vcHRpb25zLmxlZ2VuZCkpIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID49IDJcbiAgICApIHtcbiAgICAgIHRoaXMuTGVnZW5kLmJ1aWxkQ29sb3JzKCk7XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICB9XG5cbiAgICB0aGlzLkxlZ2VuZC5yZWRyYXcoXG4gICAgICB0aGlzLmdyYXBoRGltLndpZHRoIC1cbiAgICAgICAgdGhpcy5vcHRpb25zLmRvbWFpbkd1dHRlciAtXG4gICAgICAgIHRoaXMub3B0aW9ucy5jZWxsUGFkZGluZyxcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGxlZ2VuZFxuICAgKlxuICAgKiBAcmV0dXJuIGJvb2wgRmFsc2UgaWYgdGhlcmUgaXMgbm8gbGVnZW5kIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlTGVnZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheUxlZ2VuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMuZGlzcGxheUxlZ2VuZCA9IGZhbHNlO1xuICAgIHRoaXMuTGVnZW5kLnJlbW92ZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHRoZSBsZWdlbmRcbiAgICpcbiAgICogQHJldHVybiBib29sIEZhbHNlIGlmIHRoZSBsZWdlbmQgd2FzIGFscmVhZHkgZGlzcGxheWVkXG4gICAqL1xuICBzaG93TGVnZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5TGVnZW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy5kaXNwbGF5TGVnZW5kID0gdHJ1ZTtcbiAgICB0aGlzLkxlZ2VuZC5yZWRyYXcoXG4gICAgICB0aGlzLmdyYXBoRGltLndpZHRoIC1cbiAgICAgICAgdGhpcy5vcHRpb25zLmRvbWFpbkd1dHRlciAtXG4gICAgICAgIHRoaXMub3B0aW9ucy5jZWxsUGFkZGluZyxcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIaWdobGlnaHQgZGF0ZXNcbiAgICpcbiAgICogQWRkIGEgaGlnaGxpZ2h0IGNsYXNzIHRvIGEgc2V0IG9mIGRhdGVzXG4gICAqXG4gICAqIEBzaW5jZSAgMy4zLjVcbiAgICogQHBhcmFtICBhcnJheSBBcnJheSBvZiBkYXRlcyB0byBoaWdobGlnaHRcbiAgICogQHJldHVybiBib29sIFRydWUgaWYgZGF0ZXMgd2VyZSBoaWdobGlnaHRlZFxuICAgKi9cbiAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoYXJncykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmICgodGhpcy5vcHRpb25zLmhpZ2hsaWdodCA9IHRoaXMuZXhwYW5kRGF0ZVNldHRpbmcoYXJncykpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgY2FsZW5kYXJcbiAgICpcbiAgICogVXNhZ2U6IGNhbCA9IGNhbC5kZXN0cm95KCk7XG4gICAqXG4gICAqIEBzaW5jZSAgMy4zLjZcbiAgICogQHBhcmFtIGZ1bmN0aW9uIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdHJpZ2dlciBhZnRlciBkZXN0cm95aW5nIHRoZSBjYWxlbmRhclxuICAgKiBAcmV0dXJuIG51bGxcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMucm9vdFxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbilcbiAgICAgIC5hdHRyKCd3aWR0aCcsIDApXG4gICAgICAuYXR0cignaGVpZ2h0JywgMClcbiAgICAgIC5yZW1vdmUoKVxuICAgICAgLmVhY2goJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm92aWRlZCBjYWxsYmFjayBmb3IgZGVzdHJveSgpIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGdldFNWRzogZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAnLmNhbC1oZWF0bWFwLWNvbnRhaW5lcic6IHt9LFxuICAgICAgJy5ncmFwaCc6IHt9LFxuICAgICAgJy5ncmFwaC1yZWN0Jzoge30sXG4gICAgICAncmVjdC5oaWdobGlnaHQnOiB7fSxcbiAgICAgICdyZWN0Lm5vdyc6IHt9LFxuICAgICAgJ3JlY3QuaGlnaGxpZ2h0LW5vdyc6IHt9LFxuICAgICAgJ3RleHQuaGlnaGxpZ2h0Jzoge30sXG4gICAgICAndGV4dC5ub3cnOiB7fSxcbiAgICAgICd0ZXh0LmhpZ2hsaWdodC1ub3cnOiB7fSxcbiAgICAgICcuZG9tYWluLWJhY2tncm91bmQnOiB7fSxcbiAgICAgICcuZ3JhcGgtbGFiZWwnOiB7fSxcbiAgICAgICcuc3ViZG9tYWluLXRleHQnOiB7fSxcbiAgICAgICcucTAnOiB7fSxcbiAgICAgICcucWknOiB7fSxcbiAgICB9O1xuXG4gICAgZm9yIChcbiAgICAgIHZhciBqID0gMSwgdG90YWwgPSB0aGlzLm9wdGlvbnMubGVnZW5kLmxlbmd0aCArIDE7XG4gICAgICBqIDw9IHRvdGFsO1xuICAgICAgaiArPSAxXG4gICAgKSB7XG4gICAgICBzdHlsZXNbJy5xJyArIGpdID0ge307XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG5cbiAgICB2YXIgd2hpdGVsaXN0U3R5bGVzID0gW1xuICAgICAgLy8gU1ZHIHNwZWNpZmljIHByb3BlcnRpZXNcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgICAgICdzdHJva2UtbGluZWNhcCcsXG4gICAgICAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAgICAgJ2ZpbGwnLFxuICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgICAnZmlsbC1ydWxlJyxcbiAgICAgICdtYXJrZXInLFxuICAgICAgJ21hcmtlci1zdGFydCcsXG4gICAgICAnbWFya2VyLW1pZCcsXG4gICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAnYWxpZ25lbWVudC1iYXNlbGluZScsXG4gICAgICAnYmFzZWxpbmUtc2hpZnQnLFxuICAgICAgJ2RvbWluYW50LWJhc2VsaW5lJyxcbiAgICAgICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgICAgICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXG4gICAgICAna2VybmluZycsXG4gICAgICAndGV4dC1hbmNob3InLFxuICAgICAgJ3NoYXBlLXJlbmRlcmluZycsXG5cbiAgICAgIC8vIFRleHQgU3BlY2lmaWMgcHJvcGVydGllc1xuICAgICAgJ3RleHQtdHJhbnNmb3JtJyxcbiAgICAgICdmb250LWZhbWlseScsXG4gICAgICAnZm9udCcsXG4gICAgICAnZm9udC1zaXplJyxcbiAgICAgICdmb250LXdlaWdodCcsXG4gICAgXTtcblxuICAgIHZhciBmaWx0ZXJTdHlsZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh3aGl0ZWxpc3RTdHlsZXMuaW5kZXhPZihwcm9wZXJ0eSkgIT09IC0xKSB7XG4gICAgICAgIHN0eWxlc1thdHRyaWJ1dGVdW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcm9vdC5zZWxlY3QoZSlbMF1bMF07XG4gICAgfTtcblxuICAgIC8qIGpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgIGZvciAodmFyIGVsZW1lbnQgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShlbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbSA9IGdldEVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgIGlmIChkb20gPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBET00gTGV2ZWwgMiBDU1Mgd2F5XG4gICAgICAvKiBqc2hpbnQgbWF4ZGVwdGg6IGZhbHNlICovXG4gICAgICBpZiAoJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdykge1xuICAgICAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKGRvbSwgbnVsbCk7XG4gICAgICAgIGlmIChjcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmaWx0ZXJTdHlsZXMoZWxlbWVudCwgY3MuaXRlbShpKSwgY3MuZ2V0UHJvcGVydHlWYWx1ZShjcy5pdGVtKGkpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3BlcmEgd29ya2Fyb3VuZC4gT3BlcmEgZG9lc25cInQgc3VwcG9ydCBgaXRlbWAvYGxlbmd0aGBcbiAgICAgICAgICAvLyBvbiBDU1NTdHlsZURlY2xhcmF0aW9uLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gY3MpIHtcbiAgICAgICAgICAgIGlmIChjcy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICBmaWx0ZXJTdHlsZXMoZWxlbWVudCwgaywgY3Nba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBJRSB3YXlcbiAgICAgIH0gZWxzZSBpZiAoJ2N1cnJlbnRTdHlsZScgaW4gZG9tKSB7XG4gICAgICAgIHZhciBjc3MgPSBkb20uY3VycmVudFN0eWxlO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNzcykge1xuICAgICAgICAgIGZpbHRlclN0eWxlcyhlbGVtZW50LCBwLCBjc3NbcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9XG4gICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArXG4gICAgICAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+PHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPjwhW0NEQVRBWyAnO1xuXG4gICAgZm9yICh2YXIgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgICBzdHJpbmcgKz0gc3R5bGUgKyAnIHtcXG4nO1xuICAgICAgZm9yICh2YXIgbCBpbiBzdHlsZXNbc3R5bGVdKSB7XG4gICAgICAgIHN0cmluZyArPSAnXFx0JyArIGwgKyAnOicgKyBzdHlsZXNbc3R5bGVdW2xdICsgJztcXG4nO1xuICAgICAgfVxuICAgICAgc3RyaW5nICs9ICd9XFxuJztcbiAgICB9XG5cbiAgICBzdHJpbmcgKz0gJ11dPjwvc3R5bGU+JztcbiAgICBzdHJpbmcgKz0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyh0aGlzLnJvb3RbMF1bMF0pO1xuICAgIHN0cmluZyArPSAnPC9zdmc+JztcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cbi8vIERPTUFJTiBQT1NJVElPTiBDT01QVVRBVElPTiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwb3NpdGlvbiBvZiBhIGRvbWFpbiwgcmVsYXRpdmUgdG8gdGhlIGNhbGVuZGFyXG4gKi9cbnZhciBEb21haW5Qb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHRoaXMucG9zaXRpb25zID0gZDMubWFwKCk7XG59O1xuXG5Eb21haW5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgcmV0dXJuIHRoaXMucG9zaXRpb25zLmdldChkKTtcbn07XG5cbkRvbWFpblBvc2l0aW9uLnByb3RvdHlwZS5nZXRQb3NpdGlvbkZyb21JbmRleCA9IGZ1bmN0aW9uIChpKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0S2V5cygpO1xuICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuZ2V0KGRvbWFpbnNbaV0pO1xufTtcblxuRG9tYWluUG9zaXRpb24ucHJvdG90eXBlLmdldExhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0S2V5cygpO1xuICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuZ2V0KGRvbWFpbnNbZG9tYWlucy5sZW5ndGggLSAxXSk7XG59O1xuXG5Eb21haW5Qb3NpdGlvbi5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoZCwgZGltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB0aGlzLnBvc2l0aW9ucy5zZXQoZCwgZGltKTtcbn07XG5cbkRvbWFpblBvc2l0aW9uLnByb3RvdHlwZS5zaGlmdFJpZ2h0QnkgPSBmdW5jdGlvbiAoZXhpdGluZ0RvbWFpbkRpbSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdGhpcy5wb3NpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc2V0KGtleSwgdmFsdWUgLSBleGl0aW5nRG9tYWluRGltKTtcbiAgfSk7XG5cbiAgdmFyIGRvbWFpbnMgPSB0aGlzLmdldEtleXMoKTtcbiAgdGhpcy5wb3NpdGlvbnMucmVtb3ZlKGRvbWFpbnNbMF0pO1xufTtcblxuRG9tYWluUG9zaXRpb24ucHJvdG90eXBlLnNoaWZ0TGVmdEJ5ID0gZnVuY3Rpb24gKGVudGVyaW5nRG9tYWluRGltKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB0aGlzLnBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSArIGVudGVyaW5nRG9tYWluRGltKTtcbiAgfSk7XG5cbiAgdmFyIGRvbWFpbnMgPSB0aGlzLmdldEtleXMoKTtcbiAgdGhpcy5wb3NpdGlvbnMucmVtb3ZlKGRvbWFpbnNbZG9tYWlucy5sZW5ndGggLSAxXSk7XG59O1xuXG5Eb21haW5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHJldHVybiB0aGlzLnBvc2l0aW9ucy5rZXlzKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBwYXJzZUludChhLCAxMCkgLSBwYXJzZUludChiLCAxMCk7XG4gIH0pO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG4vLyBMRUdFTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG52YXIgTGVnZW5kID0gZnVuY3Rpb24gKGNhbGVuZGFyKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gIHRoaXMuY29tcHV0ZURpbSgpO1xuXG4gIGlmIChjYWxlbmRhci5vcHRpb25zLmxlZ2VuZENvbG9ycyAhPT0gbnVsbCkge1xuICAgIHRoaXMuYnVpbGRDb2xvcnMoKTtcbiAgfVxufTtcblxuTGVnZW5kLnByb3RvdHlwZS5jb21wdXRlRGltID0gZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLmNhbGVuZGFyLm9wdGlvbnM7IC8vIFNob3J0ZXIgYWNjZXNzb3IgZm9yIHZhcmlhYmxlIG5hbWUgbWFuZ2xpbmcgd2hlbiBtaW5pZnlpbmdcbiAgdGhpcy5kaW0gPSB7XG4gICAgd2lkdGg6XG4gICAgICBvcHRpb25zLmxlZ2VuZENlbGxTaXplICogKG9wdGlvbnMubGVnZW5kLmxlbmd0aCArIDEpICtcbiAgICAgIG9wdGlvbnMubGVnZW5kQ2VsbFBhZGRpbmcgKiBvcHRpb25zLmxlZ2VuZC5sZW5ndGgsXG4gICAgaGVpZ2h0OiBvcHRpb25zLmxlZ2VuZENlbGxTaXplLFxuICB9O1xufTtcblxuTGVnZW5kLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB0aGlzLmNhbGVuZGFyLnJvb3Quc2VsZWN0KCcuZ3JhcGgtbGVnZW5kJykucmVtb3ZlKCk7XG4gIHRoaXMuY2FsZW5kYXIucmVzaXplKCk7XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKCF0aGlzLmNhbGVuZGFyLm9wdGlvbnMuZGlzcGxheUxlZ2VuZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuICB2YXIgbGVnZW5kID0gY2FsZW5kYXIucm9vdDtcbiAgdmFyIGxlZ2VuZEl0ZW07XG4gIHZhciBvcHRpb25zID0gY2FsZW5kYXIub3B0aW9uczsgLy8gU2hvcnRlciBhY2Nlc3NvciBmb3IgdmFyaWFibGUgbmFtZSBtYW5nbGluZyB3aGVuIG1pbmlmeWluZ1xuXG4gIHRoaXMuY29tcHV0ZURpbSgpO1xuXG4gIHZhciBfbGVnZW5kID0gb3B0aW9ucy5sZWdlbmQuc2xpY2UoMCk7XG4gIF9sZWdlbmQucHVzaChfbGVnZW5kW19sZWdlbmQubGVuZ3RoIC0gMV0gKyAxKTtcblxuICB2YXIgbGVnZW5kRWxlbWVudCA9IGNhbGVuZGFyLnJvb3Quc2VsZWN0KCcuZ3JhcGgtbGVnZW5kJyk7XG4gIGlmIChsZWdlbmRFbGVtZW50WzBdWzBdICE9PSBudWxsKSB7XG4gICAgbGVnZW5kID0gbGVnZW5kRWxlbWVudDtcbiAgICBsZWdlbmRJdGVtID0gbGVnZW5kLnNlbGVjdCgnZycpLnNlbGVjdEFsbCgncmVjdCcpLmRhdGEoX2xlZ2VuZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3JlYXRpbmcgdGhlIG5ldyBsZWdlbmQgRE9NIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgIGxlZ2VuZCA9XG4gICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICd0b3AnXG4gICAgICAgID8gbGVnZW5kLmluc2VydCgnc3ZnJywgJy5ncmFwaCcpXG4gICAgICAgIDogbGVnZW5kLmFwcGVuZCgnc3ZnJyk7XG5cbiAgICBsZWdlbmQuYXR0cigneCcsIGdldExlZ2VuZFhQb3NpdGlvbigpKS5hdHRyKCd5JywgZ2V0TGVnZW5kWVBvc2l0aW9uKCkpO1xuXG4gICAgbGVnZW5kSXRlbSA9IGxlZ2VuZFxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2dyYXBoLWxlZ2VuZCcpXG4gICAgICAuYXR0cignaGVpZ2h0JywgcGFyZW50LmdldERpbSgnaGVpZ2h0JykpXG4gICAgICAuYXR0cignd2lkdGgnLCBwYXJlbnQuZ2V0RGltKCd3aWR0aCcpKVxuICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAuc2VsZWN0QWxsKClcbiAgICAgIC5kYXRhKF9sZWdlbmQpO1xuICB9XG5cbiAgbGVnZW5kSXRlbVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZCgncmVjdCcpXG4gICAgLmNhbGwobGVnZW5kQ2VsbExheW91dClcbiAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNhbGVuZGFyLkxlZ2VuZC5nZXRDbGFzcyhkLCBjYWxlbmRhci5sZWdlbmRTY2FsZSA9PT0gbnVsbCk7XG4gICAgfSlcbiAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgMClcbiAgICAuY2FsbChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhbGVuZGFyLmxlZ2VuZFNjYWxlICE9PSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzICE9PSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdiYXNlJylcbiAgICAgICkge1xuICAgICAgICBzZWxlY3Rpb24uYXR0cignZmlsbCcsIG9wdGlvbnMubGVnZW5kQ29sb3JzLmJhc2UpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmFwcGVuZCgndGl0bGUnKTtcblxuICBsZWdlbmRJdGVtXG4gICAgLmV4aXQoKVxuICAgIC50cmFuc2l0aW9uKClcbiAgICAuZHVyYXRpb24ob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbilcbiAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgMClcbiAgICAucmVtb3ZlKCk7XG5cbiAgbGVnZW5kSXRlbVxuICAgIC50cmFuc2l0aW9uKClcbiAgICAuZGVsYXkoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiAob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiAqIGkpIC8gMTA7XG4gICAgfSlcbiAgICAuY2FsbChsZWdlbmRDZWxsTGF5b3V0KVxuICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAxKVxuICAgIC5jYWxsKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICBpZiAoY2FsZW5kYXIubGVnZW5kU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBjYWxlbmRhci5sZWdlbmRTY2FsZShkIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmxlZ2VuZFNjYWxlKG9wdGlvbnMubGVnZW5kW2kgLSAxXSk7XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBjYWxlbmRhci5MZWdlbmQuZ2V0Q2xhc3MoZCwgY2FsZW5kYXIubGVnZW5kU2NhbGUgPT09IG51bGwpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgZnVuY3Rpb24gbGVnZW5kQ2VsbExheW91dChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgIC5hdHRyKCd3aWR0aCcsIG9wdGlvbnMubGVnZW5kQ2VsbFNpemUpXG4gICAgICAuYXR0cignaGVpZ2h0Jywgb3B0aW9ucy5sZWdlbmRDZWxsU2l6ZSlcbiAgICAgIC5hdHRyKCdyeCcsIG9wdGlvbnMubGVnZW5kQ2VsbFJhZGl1cylcbiAgICAgIC5hdHRyKCdyeScsIG9wdGlvbnMubGVnZW5kQ2VsbFJhZGl1cylcbiAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGkgKiAob3B0aW9ucy5sZWdlbmRDZWxsU2l6ZSArIG9wdGlvbnMubGVnZW5kQ2VsbFBhZGRpbmcpO1xuICAgICAgfSk7XG4gIH1cblxuICBsZWdlbmRJdGVtLnNlbGVjdCgndGl0bGUnKS50ZXh0KGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldHVybiBjYWxlbmRhci5mb3JtYXRTdHJpbmdXaXRoT2JqZWN0KG9wdGlvbnMubGVnZW5kVGl0bGVGb3JtYXQubG93ZXIsIHtcbiAgICAgICAgbWluOiBvcHRpb25zLmxlZ2VuZFtpXSxcbiAgICAgICAgbmFtZTogb3B0aW9ucy5pdGVtTmFtZVsxXSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gX2xlZ2VuZC5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gY2FsZW5kYXIuZm9ybWF0U3RyaW5nV2l0aE9iamVjdChvcHRpb25zLmxlZ2VuZFRpdGxlRm9ybWF0LnVwcGVyLCB7XG4gICAgICAgIG1heDogb3B0aW9ucy5sZWdlbmRbaSAtIDFdLFxuICAgICAgICBuYW1lOiBvcHRpb25zLml0ZW1OYW1lWzFdLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYWxlbmRhci5mb3JtYXRTdHJpbmdXaXRoT2JqZWN0KG9wdGlvbnMubGVnZW5kVGl0bGVGb3JtYXQuaW5uZXIsIHtcbiAgICAgICAgZG93bjogb3B0aW9ucy5sZWdlbmRbaSAtIDFdLFxuICAgICAgICB1cDogb3B0aW9ucy5sZWdlbmRbaV0sXG4gICAgICAgIG5hbWU6IG9wdGlvbnMuaXRlbU5hbWVbMV0sXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBsZWdlbmRJdGVtXG4gICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgY2FsZW5kYXIubGVnZW5kVGlwLnNob3coZCwgdGhpcyk7XG4gICAgfSlcbiAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsZW5kYXIubGVnZW5kVGlwLmhpZGUoKTtcbiAgICB9KTtcblxuICBsZWdlbmRcbiAgICAudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXG4gICAgLmF0dHIoJ3gnLCBnZXRMZWdlbmRYUG9zaXRpb24oKSlcbiAgICAuYXR0cigneScsIGdldExlZ2VuZFlQb3NpdGlvbigpKVxuICAgIC5hdHRyKCd3aWR0aCcsIHBhcmVudC5nZXREaW0oJ3dpZHRoJykpXG4gICAgLmF0dHIoJ2hlaWdodCcsIHBhcmVudC5nZXREaW0oJ2hlaWdodCcpKTtcblxuICBsZWdlbmRcbiAgICAuc2VsZWN0KCdnJylcbiAgICAudHJhbnNpdGlvbigpXG4gICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvcHRpb25zLmxlZ2VuZE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgJ3JvdGF0ZSg5MCAnICtcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZENlbGxTaXplIC8gMiArXG4gICAgICAgICAgJyAnICtcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZENlbGxTaXplIC8gMiArXG4gICAgICAgICAgJyknXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0TGVnZW5kWFBvc2l0aW9uKCkge1xuICAgIHN3aXRjaCAob3B0aW9ucy5sZWdlbmRIb3Jpem9udGFsUG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHxcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdtaWRkbGUnXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB3aWR0aCArIG9wdGlvbnMubGVnZW5kTWFyZ2luWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aCAtIHBhcmVudC5nZXREaW0oJ3dpZHRoJykgLSBvcHRpb25zLmxlZ2VuZE1hcmdpblsxXTtcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh3aWR0aCAvIDIgLSBwYXJlbnQuZ2V0RGltKCd3aWR0aCcpIC8gMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gb3B0aW9ucy5sZWdlbmRNYXJnaW5bM107XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGVnZW5kWVBvc2l0aW9uKCkge1xuICAgIGlmIChvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjYWxlbmRhci5ncmFwaERpbS5oZWlnaHQgK1xuICAgICAgICBvcHRpb25zLmxlZ2VuZE1hcmdpblswXSAtXG4gICAgICAgIG9wdGlvbnMuZG9tYWluR3V0dGVyIC1cbiAgICAgICAgb3B0aW9ucy5jZWxsUGFkZGluZ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMubGVnZW5kTWFyZ2luWzBdO1xuICB9XG5cbiAgY2FsZW5kYXIucmVzaXplKCk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZGltZW5zaW9uIG9mIHRoZSBsZWdlbmRcbiAqXG4gKiBUYWtlcyBpbnRvIGFjY291bnQgcm90YXRpb25cbiAqXG4gKiBAcGFyYW0gIHN0cmluZyBheGlzIFdpZHRoIG9yIGhlaWdodFxuICogQHJldHVybiBpbnQgaGVpZ2h0IG9yIHdpZHRoIGluIHBpeGVsc1xuICovXG5MZWdlbmQucHJvdG90eXBlLmdldERpbSA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5jYWxlbmRhci5vcHRpb25zLmxlZ2VuZE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCc7XG5cbiAgc3dpdGNoIChheGlzKSB7XG4gICAgY2FzZSAnd2lkdGgnOlxuICAgICAgcmV0dXJuIHRoaXMuZGltW2lzSG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J107XG4gICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgIHJldHVybiB0aGlzLmRpbVtpc0hvcml6b250YWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCddO1xuICB9XG59O1xuXG5MZWdlbmQucHJvdG90eXBlLmJ1aWxkQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLmNhbGVuZGFyLm9wdGlvbnM7IC8vIFNob3J0ZXIgYWNjZXNzb3IgZm9yIHZhcmlhYmxlIG5hbWUgbWFuZ2xpbmcgd2hlbiBtaW5pZnlpbmdcblxuICBpZiAob3B0aW9ucy5sZWdlbmRDb2xvcnMgPT09IG51bGwpIHtcbiAgICB0aGlzLmNhbGVuZGFyLmxlZ2VuZFNjYWxlID0gbnVsbDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2NvbG9yUmFuZ2UgPSBbXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmxlZ2VuZENvbG9ycykpIHtcbiAgICBfY29sb3JSYW5nZSA9IG9wdGlvbnMubGVnZW5kQ29sb3JzO1xuICB9IGVsc2UgaWYgKFxuICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdtaW4nKSAmJlxuICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdtYXgnKVxuICApIHtcbiAgICBfY29sb3JSYW5nZSA9IFtvcHRpb25zLmxlZ2VuZENvbG9ycy5taW4sIG9wdGlvbnMubGVnZW5kQ29sb3JzLm1heF07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5sZWdlbmRDb2xvcnMgPSBudWxsO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBfbGVnZW5kID0gb3B0aW9ucy5sZWdlbmQuc2xpY2UoMCk7XG5cbiAgaWYgKF9sZWdlbmRbMF0gPiAwKSB7XG4gICAgX2xlZ2VuZC51bnNoaWZ0KDApO1xuICB9IGVsc2UgaWYgKF9sZWdlbmRbMF0gPD0gMCkge1xuICAgIC8vIExldCdzIGd1ZXNzIHRoZSBsZWZ0bW9zdCB2YWx1ZSwgaXQgd2UgaGF2ZSB0byBhZGQgb25lXG4gICAgX2xlZ2VuZC51bnNoaWZ0KFxuICAgICAgX2xlZ2VuZFswXSAtIChfbGVnZW5kW19sZWdlbmQubGVuZ3RoIC0gMV0gLSBfbGVnZW5kWzBdKSAvIF9sZWdlbmQubGVuZ3RoLFxuICAgICk7XG4gIH1cbiAgdmFyIGNvbG9yU2NhbGU7XG4gIGlmIChvcHRpb25zLmxlZ2VuZENvbG9ycy5oYXNPd25Qcm9wZXJ0eSgnY29sb3JTY2FsZScpKSB7XG4gICAgY29sb3JTY2FsZSA9IG9wdGlvbnMubGVnZW5kQ29sb3JzLmNvbG9yU2NhbGU7XG4gIH0gZWxzZSB7XG4gICAgY29sb3JTY2FsZSA9IGQzLnNjYWxlXG4gICAgICAubGluZWFyKClcbiAgICAgIC5yYW5nZShfY29sb3JSYW5nZSlcbiAgICAgIC5pbnRlcnBvbGF0ZShkMy5pbnRlcnBvbGF0ZUhjbClcbiAgICAgIC5kb21haW4oW2QzLm1pbihfbGVnZW5kKSwgZDMubWF4KF9sZWdlbmQpXSk7XG4gIH1cblxuICB2YXIgbGVnZW5kQ29sb3JzID0gX2xlZ2VuZC5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gY29sb3JTY2FsZShlbGVtZW50KTtcbiAgfSk7XG4gIHRoaXMuY2FsZW5kYXIubGVnZW5kU2NhbGUgPSBkMy5zY2FsZVxuICAgIC50aHJlc2hvbGQoKVxuICAgIC5kb21haW4ob3B0aW9ucy5sZWdlbmQpXG4gICAgLnJhbmdlKGxlZ2VuZENvbG9ycyk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgY2xhc3NuYW1lIG9uIHRoZSBsZWdlbmQgZm9yIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAqXG4gKiBAcGFyYW0gaW50ZWdlciBuIFZhbHVlIGFzc29jaWF0ZWQgdG8gYSBkYXRlXG4gKiBAcGFyYW0gYm9vbCB3aXRoQ3NzQ2xhc3MgV2hldGhlciB0byBkaXNwbGF5IHRoZSBjc3MgY2xhc3MgdXNlZCB0byBzdHlsZSB0aGUgY2VsbC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBEaXNhYmxpbmcgd2lsbCBhbGxvdyBzdHlsaW5nIGRpcmVjdGx5IHZpYSBodG1sIGZpbGwgYXR0cmlidXRlXG4gKlxuICogQHJldHVybiBzdHJpbmcgQ2xhc3NuYW1lIGFjY29yZGluZyB0byB0aGUgbGVnZW5kXG4gKi9cbkxlZ2VuZC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAobiwgd2l0aENzc0NsYXNzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpbmRleCA9IFt0aGlzLmNhbGVuZGFyLm9wdGlvbnMubGVnZW5kLmxlbmd0aCArIDFdO1xuXG4gIGZvciAoXG4gICAgdmFyIGkgPSAwLCB0b3RhbCA9IHRoaXMuY2FsZW5kYXIub3B0aW9ucy5sZWdlbmQubGVuZ3RoIC0gMTtcbiAgICBpIDw9IHRvdGFsO1xuICAgIGkgKz0gMVxuICApIHtcbiAgICBpZiAodGhpcy5jYWxlbmRhci5vcHRpb25zLmxlZ2VuZFswXSA+IDAgJiYgbiA8IDApIHtcbiAgICAgIGluZGV4ID0gWycxJywgJ2knXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChuIDw9IHRoaXMuY2FsZW5kYXIub3B0aW9ucy5sZWdlbmRbaV0pIHtcbiAgICAgIGluZGV4ID0gW2kgKyAxXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChuID09PSAwKSB7XG4gICAgaW5kZXgucHVzaCgwKTtcbiAgfVxuXG4gIGluZGV4LnVuc2hpZnQoJycpO1xuICByZXR1cm4gKGluZGV4LmpvaW4oJyByJykgKyAod2l0aENzc0NsYXNzID8gaW5kZXguam9pbignIHEnKSA6ICcnKSkudHJpbSgpO1xufTtcblxuLyoqXG4gKiAjc291cmNlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4MzI0NS84MDU2NDlcbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWN1cnNpdmUob2JqMSwgb2JqMikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLypqc2hpbnQgZm9yaW46ZmFsc2UgKi9cbiAgZm9yICh2YXIgcCBpbiBvYmoyKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFByb3BlcnR5IGluIGRlc3RpbmF0aW9uIG9iamVjdCBzZXQ7IHVwZGF0ZSBpdHMgdmFsdWUuXG4gICAgICBpZiAob2JqMltwXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIG9iajFbcF0gPSBtZXJnZVJlY3Vyc2l2ZShvYmoxW3BdLCBvYmoyW3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iajFbcF0gPSBvYmoyW3BdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFByb3BlcnR5IGluIGRlc3RpbmF0aW9uIG9iamVjdCBub3Qgc2V0OyBjcmVhdGUgaXQgYW5kIHNldCBpdHMgdmFsdWUuXG4gICAgICBvYmoxW3BdID0gb2JqMltwXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqMTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiAyIGFycmF5cyBhcmUgZXF1YWxzXG4gKlxuICogQGxpbmsgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQ4NTM5NzQvODA1NjQ5XG4gKiBAcGFyYW0gIGFycmF5IGFycmF5IHRoZSBhcnJheSB0byBjb21wYXJlIHRvXG4gKiBAcmV0dXJuIGJvb2wgdHJ1ZSBvZiB0aGUgMiBhcnJheXMgYXJlIGVxdWFsc1xuICovXG5mdW5jdGlvbiBhcnJheUVxdWFscyhhcnJheUEsIGFycmF5Qikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gaWYgdGhlIG90aGVyIGFycmF5IGlzIGEgZmFsc3kgdmFsdWUsIHJldHVyblxuICBpZiAoIWFycmF5QiB8fCAhYXJyYXlBKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY29tcGFyZSBsZW5ndGhzIC0gY2FuIHNhdmUgYSBsb3Qgb2YgdGltZVxuICBpZiAoYXJyYXlBLmxlbmd0aCAhPT0gYXJyYXlCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlBLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBuZXN0ZWQgYXJyYXlzXG4gICAgaWYgKGFycmF5QVtpXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFycmF5QltpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvLyByZWN1cnNlIGludG8gdGhlIG5lc3RlZCBhcnJheXNcbiAgICAgIGlmICghYXJyYXlFcXVhbHMoYXJyYXlBW2ldLCBhcnJheUJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFycmF5QVtpXSAhPT0gYXJyYXlCW2ldKSB7XG4gICAgICAvLyBXYXJuaW5nIC0gdHdvIGRpZmZlcmVudCBvYmplY3QgaW5zdGFuY2VzIHdpbGwgbmV2ZXIgYmUgZXF1YWw6IHt4OjIwfSAhPSB7eDoyMH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbEhlYXRNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\n");

/***/ }),

/***/ "./packages/superset-ui-core/src/chart/components/reactify.tsx":
/*!*********************************************************************!*\
  !*** ./packages/superset-ui-core/src/chart/components/reactify.tsx ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reactify)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction reactify(renderFn, callbacks) {\n  class ReactifiedComponent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n\n    constructor(props) {\n      super(props);this.container = void 0;\n      this.setContainerRef = this.setContainerRef.bind(this);\n    }\n    componentDidMount() {\n      this.execute();\n    }\n    componentDidUpdate() {\n      this.execute();\n    }\n    componentWillUnmount() {\n      this.container = undefined;\n      if (callbacks != null && callbacks.componentWillUnmount) {\n        callbacks.componentWillUnmount.bind(this)();\n      }\n    }\n    setContainerRef(ref) {\n      this.container = ref;\n    }\n    execute() {\n      if (this.container) {\n        renderFn(this.container, this.props);\n      }\n    }\n    render() {\n      const { id, className } = this.props;\n      return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: this.setContainerRef, id: id, className: className });\n    } // @ts-ignore\n    __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n      this[key] = eval(code);}}const ReactifiedClass = ReactifiedComponent;\n  if (renderFn.displayName) {\n    ReactifiedClass.displayName = renderFn.displayName;\n  }\n  // eslint-disable-next-line react/forbid-foreign-prop-types\n  if (renderFn.propTypes) {\n    ReactifiedClass.propTypes = {\n      ...ReactifiedClass.propTypes,\n      ...renderFn.propTypes\n    };\n  }\n  if (renderFn.defaultProps) {\n    ReactifiedClass.defaultProps = renderFn.defaultProps;\n  }\n  return ReactifiedComponent;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(reactify, \"reactify\", \"/app/superset-frontend/packages/superset-ui-core/src/chart/components/reactify.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlcy9zdXBlcnNldC11aS1jb3JlL3NyYy9jaGFydC9jb21wb25lbnRzL3JlYWN0aWZ5LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBK0JBO0FBSUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGFja2FnZXMvc3VwZXJzZXQtdWktY29yZS9zcmMvY2hhcnQvY29tcG9uZW50cy9yZWFjdGlmeS50c3g/ZWNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVE9ETzogTm90ZSB0aGF0IGlkIGFuZCBjbGFzc05hbWUgY2FuIGNvbGxpZGUgYmV0d2VlbiBQcm9wcyBhbmQgUmVhY3RpZnlQcm9wc1xuLy8gbGVhZGluZyB0byAobGlrZWx5KSB1bmV4cGVjdGVkIGJlaGF2aW9ycy4gV2Ugc2hvdWxkIGVpdGhlciByZXF1aXJlIFByb3BzIHRvIG5vdFxuLy8gY29udGFpbiBhbiBpZC9jbGFzc05hbWUsIG9yIG5vdCBjb21iaW5lIHRoZW0gKHZpYSBpbnRlcnNlY3Rpb24pLCBpbnN0ZWFkIHByZWZlcnJpbmdcbi8vIHdyYXBwaW5nIChjb21wb3NpdGlvbikuIEFzIGFuIGV4YW1wbGU6XG4vLyBpbnRlcmZhY2UgTXlQcm9wcyB7XG4vLyAgIGlkOiBudW1iZXI7XG4vLyB9XG4vLyBmdW5jdGlvbiBteVJlbmRlcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8TXlQcm9wcz4pOiB2b2lkIHtcbi8vICAgcHJvcHMuaWQgLy8gdW51c2FibGU6IGlkIGlzIHN0cmluZyAmIG51bWJlclxuLy8gfVxuLy8gbmV3IChyZWFjdGlmeShteVJlbmRlcikpKHsgaWQ6IDUgfSk7IC8vIGVycm9yOiBpZCBoYXMgdG8gYmUgc3RyaW5nICYgbnVtYmVyXG5cbmV4cG9ydCB0eXBlIFJlYWN0aWZ5UHJvcHMgPSB7XG4gIGlkPzogc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59O1xuXG4vLyBUT0RPOiBhZGQgbW9yZSBSZWFjdCBsaWZlY3ljbGUgY2FsbGJhY2tzIGFzIG5lZWRlZFxuZXhwb3J0IHR5cGUgTGlmZUN5Y2xlQ2FsbGJhY2tzID0ge1xuICBjb21wb25lbnRXaWxsVW5tb3VudD86ICgpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckZ1bmNUeXBlPFByb3BzPiB7XG4gIChjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8UHJvcHMgJiBSZWFjdGlmeVByb3BzPik6IHZvaWQ7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBkZWZhdWx0UHJvcHM/OiBQYXJ0aWFsPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XG4gIHByb3BUeXBlcz86IFJlYWN0LldlYWtWYWxpZGF0aW9uTWFwPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWN0aWZ5PFByb3BzIGV4dGVuZHMgb2JqZWN0PihcbiAgcmVuZGVyRm46IFJlbmRlckZ1bmNUeXBlPFByb3BzPixcbiAgY2FsbGJhY2tzPzogTGlmZUN5Y2xlQ2FsbGJhY2tzLFxuKTogUmVhY3QuQ29tcG9uZW50Q2xhc3M8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiB7XG4gIGNsYXNzIFJlYWN0aWZpZWRDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiB7XG4gICAgY29udGFpbmVyPzogSFRNTERpdkVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMgJiBSZWFjdGlmeVByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnNldENvbnRhaW5lclJlZiA9IHRoaXMuc2V0Q29udGFpbmVyUmVmLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGNhbGxiYWNrcz8uY29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgICAgY2FsbGJhY2tzLmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQodGhpcykoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDb250YWluZXJSZWYocmVmOiBIVE1MRGl2RWxlbWVudCkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSByZWY7XG4gICAgfVxuXG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICByZW5kZXJGbih0aGlzLmNvbnRhaW5lciwgdGhpcy5wcm9wcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyBpZCwgY2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICByZXR1cm4gPGRpdiByZWY9e3RoaXMuc2V0Q29udGFpbmVyUmVmfSBpZD17aWR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSAvPjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBSZWFjdGlmaWVkQ2xhc3M6IFJlYWN0LkNvbXBvbmVudENsYXNzPFByb3BzICYgUmVhY3RpZnlQcm9wcz4gPVxuICAgIFJlYWN0aWZpZWRDb21wb25lbnQ7XG5cbiAgaWYgKHJlbmRlckZuLmRpc3BsYXlOYW1lKSB7XG4gICAgUmVhY3RpZmllZENsYXNzLmRpc3BsYXlOYW1lID0gcmVuZGVyRm4uZGlzcGxheU5hbWU7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2ZvcmJpZC1mb3JlaWduLXByb3AtdHlwZXNcbiAgaWYgKHJlbmRlckZuLnByb3BUeXBlcykge1xuICAgIFJlYWN0aWZpZWRDbGFzcy5wcm9wVHlwZXMgPSB7XG4gICAgICAuLi5SZWFjdGlmaWVkQ2xhc3MucHJvcFR5cGVzLFxuICAgICAgLi4ucmVuZGVyRm4ucHJvcFR5cGVzLFxuICAgIH07XG4gIH1cbiAgaWYgKHJlbmRlckZuLmRlZmF1bHRQcm9wcykge1xuICAgIFJlYWN0aWZpZWRDbGFzcy5kZWZhdWx0UHJvcHMgPSByZW5kZXJGbi5kZWZhdWx0UHJvcHM7XG4gIH1cblxuICByZXR1cm4gUmVhY3RpZmllZENvbXBvbmVudDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./packages/superset-ui-core/src/chart/components/reactify.tsx\n");

/***/ })

}]);