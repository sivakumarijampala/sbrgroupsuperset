"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["plugins_legacy-plugin-chart-parallel-coordinates_src_ReactParallelCoordinates_jsx"],{

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js":
/*!*************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");\n/* harmony import */ var _vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/parcoords/divgrid */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/sort-prop-types */\n\n\n\n\n\n\n\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)),\n  width: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  colorMetric: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  includeSeries: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  linearColorScheme: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  metrics: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  series: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  showDatatable: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool)\n};\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable\n  } = props;\n\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach((v) => {\n    ttypes[v] = 'number';\n  });\n\n  const colorScale = colorMetric ?\n  (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().\n  get(linearColorScheme).\n  createLinearScale(d3__WEBPACK_IMPORTED_MODULE_0___default().extent(data, (d) => d[colorMetric])) :\n  () => 'grey';\n  const color = (d) => colorScale(d[colorMetric]);\n  const container = d3__WEBPACK_IMPORTED_MODULE_0___default().select(element).\n  classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n\n  const div = container.\n  append('div').\n  style('height', `${effHeight}px`).\n  classed('parcoords', true);\n\n  const chart = (0,_vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()(div.node()).\n  width(width).\n  color(color).\n  alpha(0.5).\n  composite('darken').\n  height(effHeight).\n  data(data).\n  dimensions(cols).\n  types(ttypes).\n  render().\n  createAxes().\n  shadows().\n  reorderable().\n  brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = (0,_vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    container.\n    append('div').\n    style('height', `${effHeight}px`).\n    datum(data).\n    call(grid).\n    classed('parcoords grid', true).\n    selectAll('.row').\n    on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n      mouseout: chart.unhighlight\n    });\n    // update data table on brush event\n    chart.on('brush', (d) => {\n      d3__WEBPACK_IMPORTED_MODULE_0___default().select('.grid').\n      datum(d).\n      call(grid).\n      selectAll('.row').\n      on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n        mouseout: chart.unhighlight\n      });\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;const _default =\n\nParallelCoordinates;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");reactHotLoader.register(ParallelCoordinates, \"ParallelCoordinates\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvUGFyYWxsZWxDb29yZGluYXRlcy5qcz9mYTA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3NvcnQtcHJvcC10eXBlcyAqL1xuaW1wb3J0IGQzIGZyb20gJ2QzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBnZXRTZXF1ZW50aWFsU2NoZW1lUmVnaXN0cnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5cbmltcG9ydCBwYXJjb29yZHMgZnJvbSAnLi92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcyc7XG5pbXBvcnQgZGl2Z3JpZCBmcm9tICcuL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZCc7XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgLy8gU3RhbmRhcmQgdGFidWxhciBkYXRhIFt7IGZpZWxkTmFtZTE6IHZhbHVlMSwgZmllbGROYW1lMjogdmFsdWUyIH1dXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBjb2xvck1ldHJpYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW5jbHVkZVNlcmllczogUHJvcFR5cGVzLmJvb2wsXG4gIGxpbmVhckNvbG9yU2NoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtZXRyaWNzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgc2VyaWVzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzaG93RGF0YXRhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbn07XG5cbmZ1bmN0aW9uIFBhcmFsbGVsQ29vcmRpbmF0ZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGNvbG9yTWV0cmljLFxuICAgIGluY2x1ZGVTZXJpZXMsXG4gICAgbGluZWFyQ29sb3JTY2hlbWUsXG4gICAgbWV0cmljcyxcbiAgICBzZXJpZXMsXG4gICAgc2hvd0RhdGF0YWJsZSxcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGNvbHMgPSBpbmNsdWRlU2VyaWVzID8gW3Nlcmllc10uY29uY2F0KG1ldHJpY3MpIDogbWV0cmljcztcblxuICBjb25zdCB0dHlwZXMgPSB7fTtcbiAgdHR5cGVzW3Nlcmllc10gPSAnc3RyaW5nJztcbiAgbWV0cmljcy5mb3JFYWNoKHYgPT4ge1xuICAgIHR0eXBlc1t2XSA9ICdudW1iZXInO1xuICB9KTtcblxuICBjb25zdCBjb2xvclNjYWxlID0gY29sb3JNZXRyaWNcbiAgICA/IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSgpXG4gICAgICAgIC5nZXQobGluZWFyQ29sb3JTY2hlbWUpXG4gICAgICAgIC5jcmVhdGVMaW5lYXJTY2FsZShkMy5leHRlbnQoZGF0YSwgZCA9PiBkW2NvbG9yTWV0cmljXSkpXG4gICAgOiAoKSA9PiAnZ3JleSc7XG4gIGNvbnN0IGNvbG9yID0gZCA9PiBjb2xvclNjYWxlKGRbY29sb3JNZXRyaWNdKTtcbiAgY29uc3QgY29udGFpbmVyID0gZDNcbiAgICAuc2VsZWN0KGVsZW1lbnQpXG4gICAgLmNsYXNzZWQoJ3N1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcycsIHRydWUpO1xuICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gIGNvbnN0IGVmZkhlaWdodCA9IHNob3dEYXRhdGFibGUgPyBoZWlnaHQgLyAyIDogaGVpZ2h0O1xuXG4gIGNvbnN0IGRpdiA9IGNvbnRhaW5lclxuICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgLnN0eWxlKCdoZWlnaHQnLCBgJHtlZmZIZWlnaHR9cHhgKVxuICAgIC5jbGFzc2VkKCdwYXJjb29yZHMnLCB0cnVlKTtcblxuICBjb25zdCBjaGFydCA9IHBhcmNvb3JkcygpKGRpdi5ub2RlKCkpXG4gICAgLndpZHRoKHdpZHRoKVxuICAgIC5jb2xvcihjb2xvcilcbiAgICAuYWxwaGEoMC41KVxuICAgIC5jb21wb3NpdGUoJ2RhcmtlbicpXG4gICAgLmhlaWdodChlZmZIZWlnaHQpXG4gICAgLmRhdGEoZGF0YSlcbiAgICAuZGltZW5zaW9ucyhjb2xzKVxuICAgIC50eXBlcyh0dHlwZXMpXG4gICAgLnJlbmRlcigpXG4gICAgLmNyZWF0ZUF4ZXMoKVxuICAgIC5zaGFkb3dzKClcbiAgICAucmVvcmRlcmFibGUoKVxuICAgIC5icnVzaE1vZGUoJzFELWF4ZXMnKTtcblxuICBpZiAoc2hvd0RhdGF0YWJsZSkge1xuICAgIC8vIGNyZWF0ZSBkYXRhIHRhYmxlLCByb3cgaG92ZXIgaGlnaGxpZ2h0aW5nXG4gICAgY29uc3QgZ3JpZCA9IGRpdmdyaWQoKTtcbiAgICBjb250YWluZXJcbiAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAuc3R5bGUoJ2hlaWdodCcsIGAke2VmZkhlaWdodH1weGApXG4gICAgICAuZGF0dW0oZGF0YSlcbiAgICAgIC5jYWxsKGdyaWQpXG4gICAgICAuY2xhc3NlZCgncGFyY29vcmRzIGdyaWQnLCB0cnVlKVxuICAgICAgLnNlbGVjdEFsbCgnLnJvdycpXG4gICAgICAub24oe1xuICAgICAgICBtb3VzZW92ZXIoZCkge1xuICAgICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZF0pO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogY2hhcnQudW5oaWdobGlnaHQsXG4gICAgICB9KTtcbiAgICAvLyB1cGRhdGUgZGF0YSB0YWJsZSBvbiBicnVzaCBldmVudFxuICAgIGNoYXJ0Lm9uKCdicnVzaCcsIGQgPT4ge1xuICAgICAgZDMuc2VsZWN0KCcuZ3JpZCcpXG4gICAgICAgIC5kYXR1bShkKVxuICAgICAgICAuY2FsbChncmlkKVxuICAgICAgICAuc2VsZWN0QWxsKCcucm93JylcbiAgICAgICAgLm9uKHtcbiAgICAgICAgICBtb3VzZW92ZXIoZGQpIHtcbiAgICAgICAgICAgIGNoYXJ0LmhpZ2hsaWdodChbZGRdKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vdXNlb3V0OiBjaGFydC51bmhpZ2hsaWdodCxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuUGFyYWxsZWxDb29yZGluYXRlcy5kaXNwbGF5TmFtZSA9ICdQYXJhbGxlbENvb3JkaW5hdGVzJztcblBhcmFsbGVsQ29vcmRpbmF0ZXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbENvb3JkaW5hdGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx":
/*!*******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx ***!
  \*******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/chart/components/reactify.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/utils.ts\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ParallelCoordinates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ParallelCoordinates */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\nconst ReactComponent = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_ParallelCoordinates__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\nconst ParallelCoordinates = (_ref) => {let { className, ...otherProps } = _ref;return (\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", { className: className },\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_3__.jsx)(ReactComponent, otherProps)\n    ));};\n\n\nParallelCoordinates.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string).isRequired\n};const _default =\n\n(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(ParallelCoordinates)`\n  ${(_ref2) => {let { theme } = _ref2;return `\n    .superset-legacy-chart-parallel-coordinates {\n      div.grid {\n        overflow: auto;\n        div.row {\n          &:hover {\n            background-color: ${theme.colors.grayscale.light2};\n          }\n        }\n      }\n    }\n    .parcoords svg,\n    .parcoords canvas {\n      font-size: ${theme.typography.sizes.s}px;\n      position: absolute;\n    }\n    .parcoords > canvas {\n      pointer-events: none;\n    }\n\n    .parcoords text.label {\n      font: 100%;\n      font-size: ${theme.typography.sizes.s}px;\n      cursor: drag;\n    }\n    .parcoords rect.background {\n      fill: transparent;\n    }\n    .parcoords rect.background:hover {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.base, 0.2)};\n    }\n    .parcoords .resize rect {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.1)};\n    }\n    .parcoords rect.extent {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.light5, 0.25)};\n      stroke: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.6)};\n    }\n    .parcoords .axis line,\n    .parcoords .axis path {\n      fill: none;\n      stroke: ${theme.colors.grayscale.dark1};\n      shape-rendering: crispEdges;\n    }\n    .parcoords canvas {\n      opacity: 1;\n      -moz-transition: opacity 0.3s;\n      -webkit-transition: opacity 0.3s;\n      -o-transition: opacity 0.3s;\n    }\n    .parcoords canvas.faded {\n      opacity: ${theme.opacity.mediumLight};\n    }\n    .parcoords {\n      -webkit-touch-callout: none;\n      -webkit-user-select: none;\n      -khtml-user-select: none;\n      -moz-user-select: none;\n      -ms-user-select: none;\n      user-select: none;\n      background-color: ${theme.colors.grayscale.light5};\n    }\n\n    /* data table styles */\n    .parcoords .row,\n    .parcoords .header {\n      clear: left;\n      font-size: ${theme.typography.sizes.s}px;\n      line-height: 18px;\n      height: 18px;\n      margin: 0px;\n    }\n    .parcoords .row:nth-of-type(odd) {\n      background: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.05)};\n    }\n    .parcoords .header {\n      font-weight: ${theme.typography.weights.bold};\n    }\n    .parcoords .cell {\n      float: left;\n      overflow: hidden;\n      white-space: nowrap;\n      width: 100px;\n      height: 18px;\n    }\n    .parcoords .col-0 {\n      width: 180px;\n    }\n  `;}}\n`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ReactComponent, \"ReactComponent\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");reactHotLoader.register(ParallelCoordinates, \"ParallelCoordinates\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvUmVhY3RQYXJhbGxlbENvb3JkaW5hdGVzLmpzeD8yNjYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdHlsZWQsIHJlYWN0aWZ5LCBhZGRBbHBoYSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vUGFyYWxsZWxDb29yZGluYXRlcyc7XG5cbmNvbnN0IFJlYWN0Q29tcG9uZW50ID0gcmVhY3RpZnkoQ29tcG9uZW50KTtcblxuY29uc3QgUGFyYWxsZWxDb29yZGluYXRlcyA9ICh7IGNsYXNzTmFtZSwgLi4ub3RoZXJQcm9wcyB9KSA9PiAoXG4gIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuICAgIDxSZWFjdENvbXBvbmVudCB7Li4ub3RoZXJQcm9wc30gLz5cbiAgPC9kaXY+XG4pO1xuXG5QYXJhbGxlbENvb3JkaW5hdGVzLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQoUGFyYWxsZWxDb29yZGluYXRlcylgXG4gICR7KHsgdGhlbWUgfSkgPT4gYFxuICAgIC5zdXBlcnNldC1sZWdhY3ktY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMge1xuICAgICAgZGl2LmdyaWQge1xuICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgZGl2LnJvdyB7XG4gICAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQyfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLnBhcmNvb3JkcyBzdmcsXG4gICAgLnBhcmNvb3JkcyBjYW52YXMge1xuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyA+IGNhbnZhcyB7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAucGFyY29vcmRzIHRleHQubGFiZWwge1xuICAgICAgZm9udDogMTAwJTtcbiAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XG4gICAgICBjdXJzb3I6IGRyYWc7XG4gICAgfVxuICAgIC5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kIHtcbiAgICAgIGZpbGw6IHRyYW5zcGFyZW50O1xuICAgIH1cbiAgICAucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZDpob3ZlciB7XG4gICAgICBmaWxsOiAke2FkZEFscGhhKHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUuYmFzZSwgMC4yKX07XG4gICAgfVxuICAgIC5wYXJjb29yZHMgLnJlc2l6ZSByZWN0IHtcbiAgICAgIGZpbGw6ICR7YWRkQWxwaGEodGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMiwgMC4xKX07XG4gICAgfVxuICAgIC5wYXJjb29yZHMgcmVjdC5leHRlbnQge1xuICAgICAgZmlsbDogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0NSwgMC4yNSl9O1xuICAgICAgc3Ryb2tlOiAke2FkZEFscGhhKHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazIsIDAuNil9O1xuICAgIH1cbiAgICAucGFyY29vcmRzIC5heGlzIGxpbmUsXG4gICAgLnBhcmNvb3JkcyAuYXhpcyBwYXRoIHtcbiAgICAgIGZpbGw6IG5vbmU7XG4gICAgICBzdHJva2U6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMX07XG4gICAgICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7XG4gICAgfVxuICAgIC5wYXJjb29yZHMgY2FudmFzIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcbiAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xuICAgICAgLW8tdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xuICAgIH1cbiAgICAucGFyY29vcmRzIGNhbnZhcy5mYWRlZCB7XG4gICAgICBvcGFjaXR5OiAke3RoZW1lLm9wYWNpdHkubWVkaXVtTGlnaHR9O1xuICAgIH1cbiAgICAucGFyY29vcmRzIHtcbiAgICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcbiAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1fTtcbiAgICB9XG5cbiAgICAvKiBkYXRhIHRhYmxlIHN0eWxlcyAqL1xuICAgIC5wYXJjb29yZHMgLnJvdyxcbiAgICAucGFyY29vcmRzIC5oZWFkZXIge1xuICAgICAgY2xlYXI6IGxlZnQ7XG4gICAgICBmb250LXNpemU6ICR7dGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xuICAgICAgbGluZS1oZWlnaHQ6IDE4cHg7XG4gICAgICBoZWlnaHQ6IDE4cHg7XG4gICAgICBtYXJnaW46IDBweDtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyAucm93Om50aC1vZi10eXBlKG9kZCkge1xuICAgICAgYmFja2dyb3VuZDogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyLCAwLjA1KX07XG4gICAgfVxuICAgIC5wYXJjb29yZHMgLmhlYWRlciB7XG4gICAgICBmb250LXdlaWdodDogJHt0aGVtZS50eXBvZ3JhcGh5LndlaWdodHMuYm9sZH07XG4gICAgfVxuICAgIC5wYXJjb29yZHMgLmNlbGwge1xuICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgIHdpZHRoOiAxMDBweDtcbiAgICAgIGhlaWdodDogMThweDtcbiAgICB9XG4gICAgLnBhcmNvb3JkcyAuY29sLTAge1xuICAgICAgd2lkdGg6IDE4MHB4O1xuICAgIH1cbiAgYH1cbmA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js":
/*!***********************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js ***!
  \***********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\nfunction (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: []\n  };\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.\n    append('svg').\n    attr('width', __.width).\n    attr('height', __.height).\n    append('svg:g').\n    attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')'\n    );\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n      this,\n      [\n      'render',\n      'resize',\n      'highlight',\n      'brush',\n      'brushend',\n      'axesreorder'].\n      concat(d3.keys(__))\n    ),\n    w = function () {\n      return __.width - __.margin.right - __.margin.left;\n    },\n    h = function () {\n      return __.height - __.margin.top - __.margin.bottom;\n    },\n    flags = {\n      brushable: false,\n      reorderable: false,\n      axes: false,\n      interactive: false,\n      debug: false\n    },\n    xscale = d3.scale.ordinal(),\n    yscale = {},\n    dragging = {},\n    line = d3.svg.line(),\n    axis = d3.svg.axis().orient('left').ticks(5),\n    g, // groups for axes, brushes\n    ctx = {},\n    canvas = {},\n    clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch.\n  apply(this, d3.keys(__)).\n  on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).\n  on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).\n  on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).\n  on('width', function (d) {\n    pc.resize();\n  }).\n  on('height', function (d) {\n    pc.resize();\n  }).\n  on('margin', function (d) {\n    pc.resize();\n  }).\n  on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).\n  on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).\n  on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).\n  on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n      h() +\n      1 -\n      __.nullValueSeparatorPadding.bottom -\n      __.nullValueSeparatorPadding.top,\n      1];\n\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n      h() + 1,\n      1 +\n      __.nullValueSeparatorPadding.bottom +\n      __.nullValueSeparatorPadding.top];\n\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n          domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      }\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection.\n    selectAll('canvas').\n    style('margin-top', __.margin.top + 'px').\n    style('margin-left', __.margin.left + 'px').\n    attr('width', w() + 2).\n    attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n        scales.\n        map(function (p, i) {\n          return yscale[p].domain();\n        }).\n        reduce(function (a, b) {\n          return a.concat(b);\n        })\n      );\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n          d3.extent(__.data, function (d) {\n            return +d[k];\n          })\n        );\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString.\n    call(v).\n    match(/\\s([a-zA-Z]+)/)[1].\n    toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.\n  renderQueue(path_foreground).\n  rate(50).\n  clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.\n  renderQueue(path_brushed).\n  rate(50).\n  clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i]);\n          var rightCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n      $V([\n      centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n      centroids[0].e(2)]\n      )\n    );\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n      $V([\n      centroids[cols - 1].e(1) +\n      a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n      centroids[cols - 1].e(2)]\n      )\n    );\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n        cps[i].e(1),\n        cps[i].e(2),\n        cps[i + 1].e(1),\n        cps[i + 1].e(2),\n        cps[i + 2].e(1),\n        cps[i + 2].e(2)\n      );\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n    __.bundleDimension !== null && __.bundlingStrength > 0 ||\n    __.smoothness > 0)\n    {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n      __.bundleDimension !== null && __.bundlingStrength > 0 ||\n      __.smoothness > 0)\n      {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n        \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\"\n      );\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p])\n        );\n      } else {\n        ctx.lineTo(\n          position(p),\n          typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p])\n        );\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n    pc,\n    axis,\n    'ticks',\n    'orient',\n    'tickValues',\n    'tickSubdivide',\n    'tickSize',\n    'tickPadding',\n    'tickFormat'\n  );\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement).\n    transition().\n    duration(1100).\n    call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg.\n    selectAll('text.label').\n    attr(\n      'transform',\n      'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'\n    );\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg.\n    selectAll('.dimension').\n    data(__.dimensions, function (d) {\n      return d;\n    }).\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n\n    // Add an axis and title.\n    g.append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', 1 + __.nullValueSeparatorPadding.top).\n      attr('x2', w()).\n      attr('y2', 1 + __.nullValueSeparatorPadding.top).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('x2', w()).\n      attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data.\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 0).\n    append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.\n    select('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.\n    select('.label').\n    transition().\n    duration(1100).\n    text(dimensionLabels).\n    attr(\n      'transform',\n      'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'\n    );\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition().\n    duration(1100).\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 1);\n\n    pc.svg.\n    selectAll('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n      d3.behavior.\n      drag().\n      on('dragstart', function (d) {\n        dragging[d] = this.__origin__ = xscale(d);\n      }).\n      on('drag', function (d) {\n        dragging[d] = Math.min(\n          w(),\n          Math.max(0, this.__origin__ += d3.event.dx)\n        );\n        __.dimensions.sort(function (a, b) {\n          return position(a) - position(b);\n        });\n        xscale.domain(__.dimensions);\n        pc.render();\n        g.attr('transform', function (d) {\n          return 'translate(' + position(d) + ')';\n        });\n      }).\n      on('dragend', function (d) {\n        // Let's see if the order has changed and send out an event if so.\n        var i = 0,\n          j = __.dimensions.indexOf(d),\n          elem = this,\n          parent = this.parentElement;\n\n        while ((elem = elem.previousElementSibling) != null) ++i;\n        if (i !== j) {\n          events.axesreorder.call(pc, __.dimensions);\n          // We now also want to reorder the actual dom elements that represent\n          // the axes. That is, the g.dimension elements. If we don't do this,\n          // we get a weird and confusing transition when updateAxes is called.\n          // This is due to the fact that, initially the nth g.dimension element\n          // represents the nth axis. However, after a manual reordering,\n          // without reordering the dom elements, the nth dom elements no longer\n          // necessarily represents the nth axis.\n          //\n          // i is the original index of the dom element\n          // j is the new index of the dom element\n          if (i > j) {\n            // Element moved left\n            parent.insertBefore(this, parent.children[j - 1]);\n          } else {\n            // Element moved right\n            if (j + 1 < parent.children.length) {\n              parent.insertBefore(this, parent.children[j + 1]);\n            } else {\n              parent.appendChild(this);\n            }\n          }\n        }\n\n        delete this.__origin__;\n        delete dragging[d];\n        d3.select(this).\n        transition().\n        attr('transform', 'translate(' + xscale(d) + ')');\n        pc.render();\n      })\n    );\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition().\n      duration(1500).\n      attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    }\n  };\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]);\n\n        }\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n      strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n        id = strum.dims.i,\n        points = [strum.p1, strum.p2],\n        line = svg.selectAll('line#strum-' + id).data([strum]),\n        circles = svg.selectAll('circle#strum-' + id).data(points),\n        drag = d3.behavior.drag();\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(\n          Math.max(strum.minX + 1, ev.x),\n          strum.maxX\n        );\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h()\n        };\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n          Math.max(strum.minX + 1, ev.x - __.margin.left),\n          strum.maxX\n        );\n        strum.p2[1] = Math.min(\n          Math.max(strum.minY, ev.y - __.margin.top),\n          strum.maxY\n        );\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n        p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n        m1 = 1 - width / p1[0],\n        b1 = p1[1] * (1 - m1),\n        m2 = 1 - width / p2[0],\n        b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n          y = p[1],\n          y1 = m1 * x + b1,\n          y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n        brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n          test = containmentTest(strum, strums.width(id)),\n          d1 = strum.dims.left,\n          d2 = strum.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n        svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n        strum &&\n        strum.p1[0] === strum.p2[0] &&\n        strum.p1[1] === strum.p2[1])\n        {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'strums').\n      attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')'\n      );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag.\n      on('dragstart', onDragStart(strums)).\n      on('drag', onDrag(strums)).\n      on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#strums').\n      attr('id', 'strum-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      }\n    };\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n        extents = actives.map(function (p) {\n          return brushes[p].extent();\n        });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        }\n      };\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).\n      extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).\n      resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n      strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n        id = arc.dims.i,\n        points = [arc.p2, arc.p3],\n        line = svg.selectAll('line#arc-' + id).data([\n        { p1: arc.p1, p2: arc.p2 },\n        { p1: arc.p1, p2: arc.p3 }]\n        ),\n        circles = svg.selectAll('circle#arc-' + id).data(points),\n        drag = d3.behavior.drag(),\n        path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path.\n      enter().\n      append('path').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc').\n      style('fill', 'orange').\n      style('opacity', 0.5);\n\n      path.\n      attr('d', arc.arc).\n      attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event,\n          angle = 0;\n\n        i = i + 2;\n\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (\n        arc.startAngle < Math.PI &&\n        arc.endAngle < Math.PI &&\n        angle < Math.PI ||\n        arc.startAngle >= Math.PI &&\n        arc.endAngle >= Math.PI &&\n        angle >= Math.PI)\n        {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n          dims,\n          arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0)\n        };\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n          arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n          Math.max(arc.minX + 1, ev.x - __.margin.left),\n          arc.maxX\n        );\n        arc.p2[1] = Math.min(\n          Math.max(arc.minY, ev.y - __.margin.top),\n          arc.maxY\n        );\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n        brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n          test = containmentTest(arc),\n          d1 = arc.dims.left,\n          d2 = arc.dims.right,\n          y1 = yscale[d1],\n          y2 = yscale[d2],\n          a = arcs.width(id),\n          b = y1(d[d1]) - y2(d[d2]),\n          c = hypothenuse(a, b),\n          angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n        svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n          arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.\n          outerRadius(arcs.length(arcs.active)).\n          startAngle(angle).\n          endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n          b = p1[1] - p2[1],\n          c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n          uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n          b = arc.p1[1] - arc.p2[1],\n          c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'arcs').\n      attr(\n        'transform',\n        'translate(' + __.margin.left + ',' + __.margin.top + ')'\n      );\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag.\n      on('dragstart', onDragStart(arcs)).\n      on('drag', onDrag(arcs)).\n      on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#arcs').\n      attr('id', 'arc-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      }\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection.\n    select('svg').\n    attr('width', __.width).\n    attr('height', __.height);\n    pc.svg.attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')'\n    );\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin\n    });\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n      ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n      (a.x - b.x) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n      ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n      (a.y - b.y) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows');\n\n  };\n\n  return pc;\n}; /* [LICENSE TBD] */ /* eslint-disable *//* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n    _rate = 10, // number of calls per frame\n    _clear = function () {}, // clearing function\n    _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL3NyYy92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5qcz9iNjRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBfXyA9IHtcbiAgICBkYXRhOiBbXSxcbiAgICBoaWdobGlnaHRlZDogW10sXG4gICAgZGltZW5zaW9uczogW10sXG4gICAgZGltZW5zaW9uVGl0bGVzOiB7fSxcbiAgICBkaW1lbnNpb25UaXRsZVJvdGF0aW9uOiAwLFxuICAgIHR5cGVzOiB7fSxcbiAgICBicnVzaGVkOiBmYWxzZSxcbiAgICBicnVzaGVkQ29sb3I6IG51bGwsXG4gICAgYWxwaGFPbkJydXNoZWQ6IDAuMCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgcmF0ZTogMjAsXG4gICAgd2lkdGg6IDYwMCxcbiAgICBoZWlnaHQ6IDMwMCxcbiAgICBtYXJnaW46IHsgdG9wOiAyNCwgcmlnaHQ6IDAsIGJvdHRvbTogMTIsIGxlZnQ6IDAgfSxcbiAgICBudWxsVmFsdWVTZXBhcmF0b3I6ICd1bmRlZmluZWQnLCAvLyBzZXQgdG8gXCJ0b3BcIiBvciBcImJvdHRvbVwiXG4gICAgbnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZzogeyB0b3A6IDgsIHJpZ2h0OiAwLCBib3R0b206IDgsIGxlZnQ6IDAgfSxcbiAgICBjb2xvcjogJyMwNjknLFxuICAgIGNvbXBvc2l0ZTogJ3NvdXJjZS1vdmVyJyxcbiAgICBhbHBoYTogMC43LFxuICAgIGJ1bmRsaW5nU3RyZW5ndGg6IDAuNSxcbiAgICBidW5kbGVEaW1lbnNpb246IG51bGwsXG4gICAgc21vb3RobmVzczogMC4wLFxuICAgIHNob3dDb250cm9sUG9pbnRzOiBmYWxzZSxcbiAgICBoaWRlQXhpczogW10sXG4gIH07XG5cbiAgZXh0ZW5kKF9fLCBjb25maWcpO1xuXG4gIHZhciBwYyA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb24gPSBwYy5zZWxlY3Rpb24gPSBkMy5zZWxlY3Qoc2VsZWN0aW9uKTtcblxuICAgIF9fLndpZHRoID0gc2VsZWN0aW9uWzBdWzBdLmNsaWVudFdpZHRoO1xuICAgIF9fLmhlaWdodCA9IHNlbGVjdGlvblswXVswXS5jbGllbnRIZWlnaHQ7XG5cbiAgICAvLyBjYW52YXMgZGF0YSBsYXllcnNcbiAgICBbJ21hcmtzJywgJ2ZvcmVncm91bmQnLCAnYnJ1c2hlZCcsICdoaWdobGlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgY2FudmFzW2xheWVyXSA9IHNlbGVjdGlvbi5hcHBlbmQoJ2NhbnZhcycpLmF0dHIoJ2NsYXNzJywgbGF5ZXIpWzBdWzBdO1xuICAgICAgY3R4W2xheWVyXSA9IGNhbnZhc1tsYXllcl0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9KTtcblxuICAgIC8vIHN2ZyB0aWNrIGFuZCBicnVzaCBsYXllcnNcbiAgICBwYy5zdmcgPSBzZWxlY3Rpb25cbiAgICAgIC5hcHBlbmQoJ3N2ZycpXG4gICAgICAuYXR0cignd2lkdGgnLCBfXy53aWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBfXy5oZWlnaHQpXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAuYXR0cihcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyxcbiAgICAgICk7XG5cbiAgICByZXR1cm4gcGM7XG4gIH07XG4gIHZhciBldmVudHMgPSBkMy5kaXNwYXRjaC5hcHBseShcbiAgICAgIHRoaXMsXG4gICAgICBbXG4gICAgICAgICdyZW5kZXInLFxuICAgICAgICAncmVzaXplJyxcbiAgICAgICAgJ2hpZ2hsaWdodCcsXG4gICAgICAgICdicnVzaCcsXG4gICAgICAgICdicnVzaGVuZCcsXG4gICAgICAgICdheGVzcmVvcmRlcicsXG4gICAgICBdLmNvbmNhdChkMy5rZXlzKF9fKSksXG4gICAgKSxcbiAgICB3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9fLndpZHRoIC0gX18ubWFyZ2luLnJpZ2h0IC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgfSxcbiAgICBoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9fLmhlaWdodCAtIF9fLm1hcmdpbi50b3AgLSBfXy5tYXJnaW4uYm90dG9tO1xuICAgIH0sXG4gICAgZmxhZ3MgPSB7XG4gICAgICBicnVzaGFibGU6IGZhbHNlLFxuICAgICAgcmVvcmRlcmFibGU6IGZhbHNlLFxuICAgICAgYXhlczogZmFsc2UsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgfSxcbiAgICB4c2NhbGUgPSBkMy5zY2FsZS5vcmRpbmFsKCksXG4gICAgeXNjYWxlID0ge30sXG4gICAgZHJhZ2dpbmcgPSB7fSxcbiAgICBsaW5lID0gZDMuc3ZnLmxpbmUoKSxcbiAgICBheGlzID0gZDMuc3ZnLmF4aXMoKS5vcmllbnQoJ2xlZnQnKS50aWNrcyg1KSxcbiAgICBnLCAvLyBncm91cHMgZm9yIGF4ZXMsIGJydXNoZXNcbiAgICBjdHggPSB7fSxcbiAgICBjYW52YXMgPSB7fSxcbiAgICBjbHVzdGVyQ2VudHJvaWRzID0gW107XG5cbiAgLy8gc2lkZSBlZmZlY3RzIGZvciBzZXR0ZXJzXG4gIHZhciBzaWRlX2VmZmVjdHMgPSBkMy5kaXNwYXRjaFxuICAgIC5hcHBseSh0aGlzLCBkMy5rZXlzKF9fKSlcbiAgICAub24oJ2NvbXBvc2l0ZScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZC52YWx1ZTtcbiAgICB9KVxuICAgIC5vbignYWxwaGEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQWxwaGEgPSBkLnZhbHVlO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSBkLnZhbHVlO1xuICAgIH0pXG4gICAgLm9uKCdicnVzaGVkQ29sb3InLCBmdW5jdGlvbiAoZCkge1xuICAgICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkLnZhbHVlO1xuICAgIH0pXG4gICAgLm9uKCd3aWR0aCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBwYy5yZXNpemUoKTtcbiAgICB9KVxuICAgIC5vbignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHBjLnJlc2l6ZSgpO1xuICAgIH0pXG4gICAgLm9uKCdtYXJnaW4nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcGMucmVzaXplKCk7XG4gICAgfSlcbiAgICAub24oJ3JhdGUnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgYnJ1c2hlZFF1ZXVlLnJhdGUoZC52YWx1ZSk7XG4gICAgICBmb3JlZ3JvdW5kUXVldWUucmF0ZShkLnZhbHVlKTtcbiAgICB9KVxuICAgIC5vbignZGltZW5zaW9ucycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xuICAgICAgaWYgKGZsYWdzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHBjLnJlbmRlcigpLnVwZGF0ZUF4ZXMoKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5vbignYnVuZGxlRGltZW5zaW9uJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XG4gICAgICBpZiAodHlwZW9mIGQudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkLnZhbHVlIDwgX18uZGltZW5zaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5kaW1lbnNpb25zW2QudmFsdWVdO1xuICAgICAgICB9IGVsc2UgaWYgKGQudmFsdWUgPCBfXy5oaWRlQXhpcy5sZW5ndGgpIHtcbiAgICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5oaWRlQXhpc1tkLnZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX18uYnVuZGxlRGltZW5zaW9uID0gZC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgX18uY2x1c3RlckNlbnRyb2lkcyA9IGNvbXB1dGVfY2x1c3Rlcl9jZW50cm9pZHMoX18uYnVuZGxlRGltZW5zaW9uKTtcbiAgICB9KVxuICAgIC5vbignaGlkZUF4aXMnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgICAgcGMuZGltZW5zaW9ucyh3aXRob3V0KF9fLmRpbWVuc2lvbnMsIGQudmFsdWUpKTtcbiAgICB9KTtcblxuICAvLyBleHBvc2UgdGhlIHN0YXRlIG9mIHRoZSBjaGFydFxuICBwYy5zdGF0ZSA9IF9fO1xuICBwYy5mbGFncyA9IGZsYWdzO1xuXG4gIC8vIGNyZWF0ZSBnZXR0ZXIvc2V0dGVyc1xuICBnZXRzZXQocGMsIF9fLCBldmVudHMpO1xuXG4gIC8vIGV4cG9zZSBldmVudHNcbiAgZDMucmViaW5kKHBjLCBldmVudHMsICdvbicpO1xuXG4gIC8vIGdldHRlci9zZXR0ZXIgd2l0aCBldmVudCBmaXJpbmdcbiAgZnVuY3Rpb24gZ2V0c2V0KG9iaiwgc3RhdGUsIGV2ZW50cykge1xuICAgIGQzLmtleXMoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkID0gc3RhdGVba2V5XTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHg7XG4gICAgICAgIHNpZGVfZWZmZWN0c1trZXldLmNhbGwocGMsIHsgdmFsdWU6IHgsIHByZXZpb3VzOiBvbGQgfSk7XG4gICAgICAgIGV2ZW50c1trZXldLmNhbGwocGMsIHsgdmFsdWU6IHgsIHByZXZpb3VzOiBvbGQgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhvdXQoYXJyLCBpdGVtKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmluZGV4T2YoZWxlbSkgPT09IC0xO1xuICAgIH0pO1xuICB9XG4gIC8qKiBhZGp1c3RzIGFuIGF4aXMnIGRlZmF1bHQgcmFuZ2UgW2goKSsxLCAxXSBpZiBhIE51bGxWYWx1ZVNlcGFyYXRvciBpcyBzZXQgKi9cbiAgZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgaCgpICtcbiAgICAgICAgICAxIC1cbiAgICAgICAgICBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSAtXG4gICAgICAgICAgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3AsXG4gICAgICAgIDEsXG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICd0b3AnKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBoKCkgKyAxLFxuICAgICAgICAxICtcbiAgICAgICAgICBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSArXG4gICAgICAgICAgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3AsXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW2goKSArIDEsIDFdO1xuICB9XG5cbiAgcGMuYXV0b3NjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHlzY2FsZVxuICAgIHZhciBkZWZhdWx0U2NhbGVzID0ge1xuICAgICAgZGF0ZTogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChfXy5kYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkW2tdID8gZFtrXS5nZXRUaW1lKCkgOiBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgaWYgc2luZ2xlIHZhbHVlXG4gICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKFtleHRlbnRbMF1dKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkMy50aW1lLnNjYWxlKCkuZG9tYWluKGV4dGVudCkucmFuZ2UoZ2V0UmFuZ2UoKSk7XG4gICAgICB9LFxuICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICtkW2tdO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgaWYgc2luZ2xlIHZhbHVlXG4gICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKFtleHRlbnRbMF1dKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oZXh0ZW50KS5yYW5nZShnZXRSYW5nZSgpKTtcbiAgICAgIH0sXG4gICAgICBzdHJpbmc6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBjb3VudHMgPSB7fSxcbiAgICAgICAgICBkb21haW4gPSBbXTtcblxuICAgICAgICAvLyBMZXQncyBnZXQgdGhlIGNvdW50IGZvciBlYWNoIHZhbHVlIHNvIHRoYXQgd2UgY2FuIHNvcnQgdGhlIGRvbWFpbiBiYXNlZFxuICAgICAgICAvLyBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGZvciBlYWNoIHZhbHVlLlxuICAgICAgICBfXy5kYXRhLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGlmIChwW2tdID09PSB1bmRlZmluZWQgJiYgX18ubnVsbFZhbHVlU2VwYXJhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBudWxsIHZhbHVlcyB3aWxsIGJlIGRyYXduIGJleW9uZCB0aGUgaG9yaXpvbnRhbCBudWxsIHZhbHVlIHNlcGFyYXRvciFcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvdW50c1twW2tdXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb3VudHNbcFtrXV0gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudHNbcFtrXV0gPSBjb3VudHNbcFtrXV0gKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY291bnRzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvdW50c1thXSAtIGNvdW50c1tiXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oZG9tYWluKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgeXNjYWxlW2tdID0gZGVmYXVsdFNjYWxlc1tfXy50eXBlc1trXV0oayk7XG4gICAgfSk7XG5cbiAgICBfXy5oaWRlQXhpcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcbiAgICB9KTtcblxuICAgIC8vIHhzY2FsZVxuICAgIHhzY2FsZS5yYW5nZVBvaW50cyhbMCwgdygpXSwgMSk7XG5cbiAgICAvLyBjYW52YXMgc2l6ZXNcbiAgICBwYy5zZWxlY3Rpb25cbiAgICAgIC5zZWxlY3RBbGwoJ2NhbnZhcycpXG4gICAgICAuc3R5bGUoJ21hcmdpbi10b3AnLCBfXy5tYXJnaW4udG9wICsgJ3B4JylcbiAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCBfXy5tYXJnaW4ubGVmdCArICdweCcpXG4gICAgICAuYXR0cignd2lkdGgnLCB3KCkgKyAyKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpO1xuXG4gICAgLy8gZGVmYXVsdCBzdHlsZXMsIG5lZWRzIHRvIGJlIHNldCB3aGVuIGNhbnZhcyB3aWR0aCBjaGFuZ2VzXG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBfXy5jb2xvcjtcbiAgICBjdHguZm9yZWdyb3VuZC5saW5lV2lkdGggPSAxLjQ7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gX18uY29tcG9zaXRlO1xuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBfXy5icnVzaGVkQ29sb3I7XG4gICAgY3R4LmJydXNoZWQubGluZVdpZHRoID0gMS40O1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IF9fLmNvbXBvc2l0ZTtcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIGN0eC5oaWdobGlnaHQubGluZVdpZHRoID0gMztcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnNjYWxlID0gZnVuY3Rpb24gKGQsIGRvbWFpbikge1xuICAgIHlzY2FsZVtkXS5kb21haW4oZG9tYWluKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLmZsaXAgPSBmdW5jdGlvbiAoZCkge1xuICAgIC8veXNjYWxlW2RdLmRvbWFpbigpLnJldmVyc2UoKTsgICAgICAgICAvLyBkb2VzIG5vdCB3b3JrXG4gICAgeXNjYWxlW2RdLmRvbWFpbih5c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpKTsgLy8gd29ya3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLmNvbW1vblNjYWxlID0gZnVuY3Rpb24gKGdsb2JhbCwgdHlwZSkge1xuICAgIHZhciB0ID0gdHlwZSB8fCAnbnVtYmVyJztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gc2NhbGVzIG9mIHRoZSBzYW1lIHR5cGVcbiAgICB2YXIgc2NhbGVzID0gX18uZGltZW5zaW9ucy5jb25jYXQoX18uaGlkZUF4aXMpLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIF9fLnR5cGVzW3BdID09IHQ7XG4gICAgfSk7XG5cbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KFxuICAgICAgICBzY2FsZXNcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geXNjYWxlW3BdLmRvbWFpbigpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgeXNjYWxlW2RdLmRvbWFpbihleHRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHlzY2FsZVtrXS5kb21haW4oXG4gICAgICAgICAgZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gK2Rba107XG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2VudHJvaWRzXG4gICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgcGMuYnVuZGxlRGltZW5zaW9uKF9fLmJ1bmRsZURpbWVuc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHBjLmRldGVjdERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMudHlwZXMocGMuZGV0ZWN0RGltZW5zaW9uVHlwZXMoX18uZGF0YSkpO1xuICAgIHBjLmRpbWVuc2lvbnMoZDMua2V5cyhwYy50eXBlcygpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gYSBiZXR0ZXIgXCJ0eXBlb2ZcIiBmcm9tIHRoaXMgcG9zdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzkwNDI2L2JldHRlci13YXktdG8tZ2V0LXR5cGUtb2YtYS1qYXZhc2NyaXB0LXZhcmlhYmxlXG4gIHBjLnRvVHlwZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nXG4gICAgICAuY2FsbCh2KVxuICAgICAgLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdXG4gICAgICAudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICAvLyB0cnkgdG8gY29lcmNlIHRvIG51bWJlciBiZWZvcmUgcmV0dXJuaW5nIHR5cGVcbiAgcGMudG9UeXBlQ29lcmNlTnVtYmVycyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHBhcnNlRmxvYXQodikgPT0gdiAmJiB2ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG4gICAgcmV0dXJuIHBjLnRvVHlwZSh2KTtcbiAgfTtcblxuICAvLyBhdHRlbXB0IHRvIGRldGVybWluZSB0eXBlcyBvZiBlYWNoIGRpbWVuc2lvbiBiYXNlZCBvbiBmaXJzdCByb3cgb2YgZGF0YVxuICBwYy5kZXRlY3REaW1lbnNpb25UeXBlcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHR5cGVzID0ge307XG4gICAgZDMua2V5cyhkYXRhWzBdKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgIHR5cGVzW2NvbF0gPSBwYy50b1R5cGVDb2VyY2VOdW1iZXJzKGRhdGFbMF1bY29sXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9O1xuICBwYy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdHJ5IHRvIGF1dG9kZXRlY3QgZGltZW5zaW9ucyBhbmQgY3JlYXRlIHNjYWxlc1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBpZiAoIShfXy5kaW1lbnNpb25zWzBdIGluIHlzY2FsZSkpIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgcGMucmVuZGVyW19fLm1vZGVdKCk7XG5cbiAgICBldmVudHMucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVuZGVyQnJ1c2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcblxuICAgIHBjLnJlbmRlckJydXNoZWRbX18ubW9kZV0oKTtcblxuICAgIGV2ZW50cy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0JydXNoZWQoKSB7XG4gICAgaWYgKF9fLmJydXNoZWQgJiYgX18uYnJ1c2hlZC5sZW5ndGggIT09IF9fLmRhdGEubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBvYmplY3QgPSBicnVzaC5jdXJyZW50TW9kZSgpLmJydXNoU3RhdGUoKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcGMucmVuZGVyLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG5cbiAgICBwYy5yZW5kZXJCcnVzaGVkLmRlZmF1bHQoKTtcblxuICAgIF9fLmRhdGEuZm9yRWFjaChwYXRoX2ZvcmVncm91bmQpO1xuICB9O1xuXG4gIHZhciBmb3JlZ3JvdW5kUXVldWUgPSBkM1xuICAgIC5yZW5kZXJRdWV1ZShwYXRoX2ZvcmVncm91bmQpXG4gICAgLnJhdGUoNTApXG4gICAgLmNsZWFyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBjLmNsZWFyKCdmb3JlZ3JvdW5kJyk7XG4gICAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgfSk7XG5cbiAgcGMucmVuZGVyLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHBjLnJlbmRlckJydXNoZWQucXVldWUoKTtcblxuICAgIGZvcmVncm91bmRRdWV1ZShfXy5kYXRhKTtcbiAgfTtcblxuICBwYy5yZW5kZXJCcnVzaGVkLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2JydXNoZWQnKTtcblxuICAgIGlmIChpc0JydXNoZWQoKSkge1xuICAgICAgX18uYnJ1c2hlZC5mb3JFYWNoKHBhdGhfYnJ1c2hlZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBicnVzaGVkUXVldWUgPSBkM1xuICAgIC5yZW5kZXJRdWV1ZShwYXRoX2JydXNoZWQpXG4gICAgLnJhdGUoNTApXG4gICAgLmNsZWFyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBjLmNsZWFyKCdicnVzaGVkJyk7XG4gICAgfSk7XG5cbiAgcGMucmVuZGVyQnJ1c2hlZC5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNCcnVzaGVkKCkpIHtcbiAgICAgIGJydXNoZWRRdWV1ZShfXy5icnVzaGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJ1c2hlZFF1ZXVlKFtdKTsgLy8gVGhpcyBpcyBuZWVkZWQgdG8gY2xlYXIgdGhlIGN1cnJlbnRseSBicnVzaGVkIGl0ZW1zXG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjb21wdXRlX2NsdXN0ZXJfY2VudHJvaWRzKGQpIHtcbiAgICB2YXIgY2x1c3RlckNlbnRyb2lkcyA9IGQzLm1hcCgpO1xuICAgIHZhciBjbHVzdGVyQ291bnRzID0gZDMubWFwKCk7XG4gICAgLy8gZGV0ZXJtaW5lIGNsdXN0ZXJDb3VudHNcbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgdmFyIHNjYWxlZCA9IHlzY2FsZVtkXShyb3dbZF0pO1xuICAgICAgaWYgKCFjbHVzdGVyQ291bnRzLmhhcyhzY2FsZWQpKSB7XG4gICAgICAgIGNsdXN0ZXJDb3VudHMuc2V0KHNjYWxlZCwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgY291bnQgPSBjbHVzdGVyQ291bnRzLmdldChzY2FsZWQpO1xuICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCBjb3VudCArIDEpO1xuICAgIH0pO1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIHZhciBzY2FsZWQgPSB5c2NhbGVbZF0ocm93W2RdKTtcbiAgICAgICAgaWYgKCFjbHVzdGVyQ2VudHJvaWRzLmhhcyhzY2FsZWQpKSB7XG4gICAgICAgICAgdmFyIG1hcCA9IGQzLm1hcCgpO1xuICAgICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuc2V0KHNjYWxlZCwgbWFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuaGFzKHApKSB7XG4gICAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5zZXQocCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5nZXQocCk7XG4gICAgICAgIHZhbHVlICs9IHlzY2FsZVtwXShyb3dbcF0pIC8gY2x1c3RlckNvdW50cy5nZXQoc2NhbGVkKTtcbiAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5zZXQocCwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2x1c3RlckNlbnRyb2lkcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVfY2VudHJvaWRzKHJvdykge1xuICAgIHZhciBjZW50cm9pZHMgPSBbXTtcblxuICAgIHZhciBwID0gX18uZGltZW5zaW9ucztcbiAgICB2YXIgY29scyA9IHAubGVuZ3RoO1xuICAgIHZhciBhID0gMC41OyAvLyBjZW50ZXIgYmV0d2VlbiBheGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzOyArK2kpIHtcbiAgICAgIC8vIGNlbnRyb2lkcyBvbiAncmVhbCcgYXhlc1xuICAgICAgdmFyIHggPSBwb3NpdGlvbihwW2ldKTtcbiAgICAgIHZhciB5ID0geXNjYWxlW3BbaV1dKHJvd1twW2ldXSk7XG4gICAgICBjZW50cm9pZHMucHVzaCgkVihbeCwgeV0pKTtcblxuICAgICAgLy8gY2VudHJvaWRzIG9uICd2aXJ0dWFsJyBheGVzXG4gICAgICBpZiAoaSA8IGNvbHMgLSAxKSB7XG4gICAgICAgIHZhciBjeCA9IHggKyBhICogKHBvc2l0aW9uKHBbaSArIDFdKSAtIHgpO1xuICAgICAgICB2YXIgY3kgPSB5ICsgYSAqICh5c2NhbGVbcFtpICsgMV1dKHJvd1twW2kgKyAxXV0pIC0geSk7XG4gICAgICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgbGVmdENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkc1xuICAgICAgICAgICAgLmdldCh5c2NhbGVbX18uYnVuZGxlRGltZW5zaW9uXShyb3dbX18uYnVuZGxlRGltZW5zaW9uXSkpXG4gICAgICAgICAgICAuZ2V0KHBbaV0pO1xuICAgICAgICAgIHZhciByaWdodENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkc1xuICAgICAgICAgICAgLmdldCh5c2NhbGVbX18uYnVuZGxlRGltZW5zaW9uXShyb3dbX18uYnVuZGxlRGltZW5zaW9uXSkpXG4gICAgICAgICAgICAuZ2V0KHBbaSArIDFdKTtcbiAgICAgICAgICB2YXIgY2VudHJvaWQgPSAwLjUgKiAobGVmdENlbnRyb2lkICsgcmlnaHRDZW50cm9pZCk7XG4gICAgICAgICAgY3kgPSBjZW50cm9pZCArICgxIC0gX18uYnVuZGxpbmdTdHJlbmd0aCkgKiAoY3kgLSBjZW50cm9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2VudHJvaWRzLnB1c2goJFYoW2N4LCBjeV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VudHJvaWRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jb250cm9sX3BvaW50cyhjZW50cm9pZHMpIHtcbiAgICB2YXIgY29scyA9IGNlbnRyb2lkcy5sZW5ndGg7XG4gICAgdmFyIGEgPSBfXy5zbW9vdGhuZXNzO1xuICAgIHZhciBjcHMgPSBbXTtcblxuICAgIGNwcy5wdXNoKGNlbnRyb2lkc1swXSk7XG4gICAgY3BzLnB1c2goXG4gICAgICAkVihbXG4gICAgICAgIGNlbnRyb2lkc1swXS5lKDEpICsgYSAqIDIgKiAoY2VudHJvaWRzWzFdLmUoMSkgLSBjZW50cm9pZHNbMF0uZSgxKSksXG4gICAgICAgIGNlbnRyb2lkc1swXS5lKDIpLFxuICAgICAgXSksXG4gICAgKTtcbiAgICBmb3IgKHZhciBjb2wgPSAxOyBjb2wgPCBjb2xzIC0gMTsgKytjb2wpIHtcbiAgICAgIHZhciBtaWQgPSBjZW50cm9pZHNbY29sXTtcbiAgICAgIHZhciBsZWZ0ID0gY2VudHJvaWRzW2NvbCAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gY2VudHJvaWRzW2NvbCArIDFdO1xuXG4gICAgICB2YXIgZGlmZiA9IGxlZnQuc3VidHJhY3QocmlnaHQpO1xuICAgICAgY3BzLnB1c2gobWlkLmFkZChkaWZmLngoYSkpKTtcbiAgICAgIGNwcy5wdXNoKG1pZCk7XG4gICAgICBjcHMucHVzaChtaWQuc3VidHJhY3QoZGlmZi54KGEpKSk7XG4gICAgfVxuICAgIGNwcy5wdXNoKFxuICAgICAgJFYoW1xuICAgICAgICBjZW50cm9pZHNbY29scyAtIDFdLmUoMSkgK1xuICAgICAgICAgIGEgKiAyICogKGNlbnRyb2lkc1tjb2xzIC0gMl0uZSgxKSAtIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSksXG4gICAgICAgIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgyKSxcbiAgICAgIF0pLFxuICAgICk7XG4gICAgY3BzLnB1c2goY2VudHJvaWRzW2NvbHMgLSAxXSk7XG5cbiAgICByZXR1cm4gY3BzO1xuICB9XG5cbiAgcGMuc2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmbGFncy5zaGFkb3dzID0gdHJ1ZTtcbiAgICBwYy5hbHBoYU9uQnJ1c2hlZCgwLjEpO1xuICAgIHBjLnJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGRyYXcgZG90cyB3aXRoIHJhZGl1cyByIG9uIHRoZSBheGlzIGxpbmUgd2hlcmUgZGF0YSBpbnRlcnNlY3RzXG4gIHBjLmF4aXNEb3RzID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2YXIgciA9IHIgfHwgMC4xO1xuICAgIHZhciBjdHggPSBwYy5jdHgubWFya3M7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSAwO1xuICAgIHZhciBlbmRBbmdsZSA9IDIgKiBNYXRoLlBJO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IGQzLm1pbihbMSAvIE1hdGgucG93KF9fLmRhdGEubGVuZ3RoLCAxIC8gMiksIDFdKTtcbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhwb3NpdGlvbihwKSwgeXNjYWxlW3BdKGRbcF0pLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGRyYXcgc2luZ2xlIGN1YmljIGJlemllciBjdXJ2ZVxuICBmdW5jdGlvbiBzaW5nbGVfY3VydmUoZCwgY3R4KSB7XG4gICAgdmFyIGNlbnRyb2lkcyA9IGNvbXB1dGVfY2VudHJvaWRzKGQpO1xuICAgIHZhciBjcHMgPSBjb21wdXRlX2NvbnRyb2xfcG9pbnRzKGNlbnRyb2lkcyk7XG5cbiAgICBjdHgubW92ZVRvKGNwc1swXS5lKDEpLCBjcHNbMF0uZSgyKSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGlmIChfXy5zaG93Q29udHJvbFBvaW50cykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGogKz0gMSkge1xuICAgICAgICAgIGN0eC5maWxsUmVjdChjcHNbaSArIGpdLmUoMSksIGNwc1tpICsgal0uZSgyKSwgMiwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICBjcHNbaV0uZSgxKSxcbiAgICAgICAgY3BzW2ldLmUoMiksXG4gICAgICAgIGNwc1tpICsgMV0uZSgxKSxcbiAgICAgICAgY3BzW2kgKyAxXS5lKDIpLFxuICAgICAgICBjcHNbaSArIDJdLmUoMSksXG4gICAgICAgIGNwc1tpICsgMl0uZSgyKSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gZHJhdyBzaW5nbGUgcG9seWxpbmVcbiAgZnVuY3Rpb24gY29sb3JfcGF0aChkLCBjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKFxuICAgICAgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCAmJiBfXy5idW5kbGluZ1N0cmVuZ3RoID4gMCkgfHxcbiAgICAgIF9fLnNtb290aG5lc3MgPiAwXG4gICAgKSB7XG4gICAgICBzaW5nbGVfY3VydmUoZCwgY3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2luZ2xlX3BhdGgoZCwgY3R4KTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG5cbiAgLy8gZHJhdyBtYW55IHBvbHlsaW5lcyBvZiB0aGUgc2FtZSBjb2xvclxuICBmdW5jdGlvbiBwYXRocyhkYXRhLCBjdHgpIHtcbiAgICBjdHguY2xlYXJSZWN0KC0xLCAtMSwgdygpICsgMiwgaCgpICsgMik7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKFxuICAgICAgICAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsICYmIF9fLmJ1bmRsaW5nU3RyZW5ndGggPiAwKSB8fFxuICAgICAgICBfXy5zbW9vdGhuZXNzID4gMFxuICAgICAgKSB7XG4gICAgICAgIHNpbmdsZV9jdXJ2ZShkLCBjdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2luZ2xlX3BhdGgoZCwgY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cblxuICAvLyByZXR1cm5zIHRoZSB5LXBvc2l0aW9uIGp1c3QgYmV5b25kIHRoZSBzZXBhcmF0aW5nIG51bGwgdmFsdWUgbGluZVxuICBmdW5jdGlvbiBnZXROdWxsUG9zaXRpb24oKSB7XG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIGgoKSArIDE7XG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJBIHZhbHVlIGlzIE5VTEwsIGJ1dCBudWxsVmFsdWVTZXBhcmF0b3IgaXMgbm90IHNldDsgc2V0IGl0IHRvICdib3R0b20nIG9yICd0b3AnLlwiLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGgoKSArIDE7XG4gIH1cblxuICBmdW5jdGlvbiBzaW5nbGVfcGF0aChkLCBjdHgpIHtcbiAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICBjdHgubW92ZVRvKFxuICAgICAgICAgIHBvc2l0aW9uKHApLFxuICAgICAgICAgIHR5cGVvZiBkW3BdID09ICd1bmRlZmluZWQnID8gZ2V0TnVsbFBvc2l0aW9uKCkgOiB5c2NhbGVbcF0oZFtwXSksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgIHBvc2l0aW9uKHApLFxuICAgICAgICAgIHR5cGVvZiBkW3BdID09ICd1bmRlZmluZWQnID8gZ2V0TnVsbFBvc2l0aW9uKCkgOiB5c2NhbGVbcF0oZFtwXSksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoX2JydXNoZWQoZCwgaSkge1xuICAgIGlmIChfXy5icnVzaGVkQ29sb3IgIT09IG51bGwpIHtcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5icnVzaGVkQ29sb3IpKGQsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3JfcGF0aChkLCBjdHguYnJ1c2hlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoX2ZvcmVncm91bmQoZCwgaSkge1xuICAgIGN0eC5mb3JlZ3JvdW5kLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmZvcmVncm91bmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0aF9oaWdobGlnaHQoZCwgaSkge1xuICAgIGN0eC5oaWdobGlnaHQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcbiAgICByZXR1cm4gY29sb3JfcGF0aChkLCBjdHguaGlnaGxpZ2h0KTtcbiAgfVxuICBwYy5jbGVhciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIGN0eFtsYXllcl0uY2xlYXJSZWN0KDAsIDAsIHcoKSArIDIsIGgoKSArIDIpO1xuXG4gICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSBmb3JlZ3JvdW5kIGl0ZW1zIGFyZSB0cmFuc3BhcmVudFxuICAgIC8vIHdpdGhvdXQgdGhlIG5lZWQgZm9yIGNoYW5naW5nIHRoZSBvcGFjaXR5IHN0eWxlIG9mIHRoZSBmb3JlZ3JvdW5kIGNhbnZhc1xuICAgIC8vIGFzIHRoaXMgd291bGQgc3RvcCB0aGUgY3NzIHN0eWxpbmcgZnJvbSB3b3JraW5nXG4gICAgaWYgKGxheWVyID09PSAnYnJ1c2hlZCcgJiYgaXNCcnVzaGVkKCkpIHtcbiAgICAgIGN0eC5icnVzaGVkLmZpbGxTdHlsZSA9IHBjLnNlbGVjdGlvbi5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSAxIC0gX18uYWxwaGFPbkJydXNoZWQ7XG4gICAgICBjdHguYnJ1c2hlZC5maWxsUmVjdCgwLCAwLCB3KCkgKyAyLCBoKCkgKyAyKTtcbiAgICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGQzLnJlYmluZChcbiAgICBwYyxcbiAgICBheGlzLFxuICAgICd0aWNrcycsXG4gICAgJ29yaWVudCcsXG4gICAgJ3RpY2tWYWx1ZXMnLFxuICAgICd0aWNrU3ViZGl2aWRlJyxcbiAgICAndGlja1NpemUnLFxuICAgICd0aWNrUGFkZGluZycsXG4gICAgJ3RpY2tGb3JtYXQnLFxuICApO1xuXG4gIGZ1bmN0aW9uIGZsaXBBeGlzQW5kVXBkYXRlUENQKGRpbWVuc2lvbikge1xuICAgIHZhciBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpO1xuXG4gICAgcGMuZmxpcChkaW1lbnNpb24pO1xuXG4gICAgZDMuc2VsZWN0KHRoaXMucGFyZW50RWxlbWVudClcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigxMTAwKVxuICAgICAgLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZGltZW5zaW9uXSkpO1xuXG4gICAgcGMucmVuZGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGVMYWJlbHMoKSB7XG4gICAgdmFyIGRlbHRhID0gZDMuZXZlbnQuZGVsdGFZO1xuICAgIGRlbHRhID0gZGVsdGEgPCAwID8gLTUgOiBkZWx0YTtcbiAgICBkZWx0YSA9IGRlbHRhID4gMCA/IDUgOiBkZWx0YTtcblxuICAgIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKz0gZGVsdGE7XG4gICAgcGMuc3ZnXG4gICAgICAuc2VsZWN0QWxsKCd0ZXh0LmxhYmVsJylcbiAgICAgIC5hdHRyKFxuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScsXG4gICAgICApO1xuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBkaW1lbnNpb25MYWJlbHMoZCkge1xuICAgIHJldHVybiBkIGluIF9fLmRpbWVuc2lvblRpdGxlcyA/IF9fLmRpbWVuc2lvblRpdGxlc1tkXSA6IGQ7IC8vIGRpbWVuc2lvbiBkaXNwbGF5IG5hbWVzXG4gIH1cblxuICBwYy5jcmVhdGVBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChnKSBwYy5yZW1vdmVBeGVzKCk7XG5cbiAgICAvLyBBZGQgYSBncm91cCBlbGVtZW50IGZvciBlYWNoIGRpbWVuc2lvbi5cbiAgICBnID0gcGMuc3ZnXG4gICAgICAuc2VsZWN0QWxsKCcuZGltZW5zaW9uJylcbiAgICAgIC5kYXRhKF9fLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSlcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnZGltZW5zaW9uJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknO1xuICAgICAgfSk7XG5cbiAgICAvLyBBZGQgYW4gYXhpcyBhbmQgdGl0bGUuXG4gICAgZy5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICAgIH0pXG4gICAgICAuYXBwZW5kKCdzdmc6dGV4dCcpXG4gICAgICAuYXR0cih7XG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxuICAgICAgICB4OiAwLFxuICAgICAgICBjbGFzczogJ2xhYmVsJyxcbiAgICAgIH0pXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXG4gICAgICAub24oJ2RibGNsaWNrJywgZmxpcEF4aXNBbmRVcGRhdGVQQ1ApXG4gICAgICAub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTtcblxuICAgIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHBjLnN2Z1xuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgICAgLmF0dHIoJ3kxJywgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wKVxuICAgICAgICAuYXR0cigneDInLCB3KCkpXG4gICAgICAgIC5hdHRyKCd5MicsIDEgKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcClcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnIzc3NycpXG4gICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcGMuc3ZnXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAuYXR0cigneTEnLCBoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20pXG4gICAgICAgIC5hdHRyKCd4MicsIHcoKSlcbiAgICAgICAgLmF0dHIoJ3kyJywgaCgpICsgMSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tKVxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjNzc3JylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIH1cblxuICAgIGZsYWdzLmF4ZXMgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnJlbW92ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZy5yZW1vdmUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwYy51cGRhdGVBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnX2RhdGEgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJykuZGF0YShfXy5kaW1lbnNpb25zKTtcblxuICAgIC8vIEVudGVyXG4gICAgZ19kYXRhXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKHApICsgJyknO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnYXhpcycpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJylcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgICB9KVxuICAgICAgLmFwcGVuZCgnc3ZnOnRleHQnKVxuICAgICAgLmF0dHIoe1xuICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcbiAgICAgICAgeDogMCxcbiAgICAgICAgY2xhc3M6ICdsYWJlbCcsXG4gICAgICB9KVxuICAgICAgLnRleHQoZGltZW5zaW9uTGFiZWxzKVxuICAgICAgLm9uKCdkYmxjbGljaycsIGZsaXBBeGlzQW5kVXBkYXRlUENQKVxuICAgICAgLm9uKCd3aGVlbCcsIHJvdGF0ZUxhYmVscyk7XG5cbiAgICAvLyBVcGRhdGVcbiAgICBnX2RhdGEuYXR0cignb3BhY2l0eScsIDApO1xuICAgIGdfZGF0YVxuICAgICAgLnNlbGVjdCgnLmF4aXMnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDExMDApXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xuICAgICAgfSk7XG4gICAgZ19kYXRhXG4gICAgICAuc2VsZWN0KCcubGFiZWwnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDExMDApXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXG4gICAgICAuYXR0cihcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxuICAgICAgKTtcblxuICAgIC8vIEV4aXRcbiAgICBnX2RhdGEuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKTtcbiAgICBnLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDExMDApXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKHApICsgJyknO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xuXG4gICAgcGMuc3ZnXG4gICAgICAuc2VsZWN0QWxsKCcuYXhpcycpXG4gICAgICAudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMTEwMClcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgICB9KTtcblxuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoYWJsZSgpO1xuICAgIGlmIChmbGFncy5yZW9yZGVyYWJsZSkgcGMucmVvcmRlcmFibGUoKTtcbiAgICBpZiAocGMuYnJ1c2hNb2RlKCkgIT09ICdOb25lJykge1xuICAgICAgdmFyIG1vZGUgPSBwYy5icnVzaE1vZGUoKTtcbiAgICAgIHBjLmJydXNoTW9kZSgnTm9uZScpO1xuICAgICAgcGMuYnJ1c2hNb2RlKG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBKYXNvbiBEYXZpZXMsIGh0dHA6Ly9ibC5vY2tzLm9yZy8xMzQxMjgxXG4gIHBjLnJlb3JkZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpO1xuXG4gICAgZy5zdHlsZSgnY3Vyc29yJywgJ21vdmUnKS5jYWxsKFxuICAgICAgZDMuYmVoYXZpb3JcbiAgICAgICAgLmRyYWcoKVxuICAgICAgICAub24oJ2RyYWdzdGFydCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZHJhZ2dpbmdbZF0gPSB0aGlzLl9fb3JpZ2luX18gPSB4c2NhbGUoZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZHJhZ2dpbmdbZF0gPSBNYXRoLm1pbihcbiAgICAgICAgICAgIHcoKSxcbiAgICAgICAgICAgIE1hdGgubWF4KDAsICh0aGlzLl9fb3JpZ2luX18gKz0gZDMuZXZlbnQuZHgpKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIF9fLmRpbWVuc2lvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKGEpIC0gcG9zaXRpb24oYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcbiAgICAgICAgICBwYy5yZW5kZXIoKTtcbiAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24oZCkgKyAnKSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgLy8gTGV0J3Mgc2VlIGlmIHRoZSBvcmRlciBoYXMgY2hhbmdlZCBhbmQgc2VuZCBvdXQgYW4gZXZlbnQgaWYgc28uXG4gICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaiA9IF9fLmRpbWVuc2lvbnMuaW5kZXhPZihkKSxcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLFxuICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgICAgd2hpbGUgKChlbGVtID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSAhPSBudWxsKSArK2k7XG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIGV2ZW50cy5heGVzcmVvcmRlci5jYWxsKHBjLCBfXy5kaW1lbnNpb25zKTtcbiAgICAgICAgICAgIC8vIFdlIG5vdyBhbHNvIHdhbnQgdG8gcmVvcmRlciB0aGUgYWN0dWFsIGRvbSBlbGVtZW50cyB0aGF0IHJlcHJlc2VudFxuICAgICAgICAgICAgLy8gdGhlIGF4ZXMuIFRoYXQgaXMsIHRoZSBnLmRpbWVuc2lvbiBlbGVtZW50cy4gSWYgd2UgZG9uJ3QgZG8gdGhpcyxcbiAgICAgICAgICAgIC8vIHdlIGdldCBhIHdlaXJkIGFuZCBjb25mdXNpbmcgdHJhbnNpdGlvbiB3aGVuIHVwZGF0ZUF4ZXMgaXMgY2FsbGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhhdCwgaW5pdGlhbGx5IHRoZSBudGggZy5kaW1lbnNpb24gZWxlbWVudFxuICAgICAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgbnRoIGF4aXMuIEhvd2V2ZXIsIGFmdGVyIGEgbWFudWFsIHJlb3JkZXJpbmcsXG4gICAgICAgICAgICAvLyB3aXRob3V0IHJlb3JkZXJpbmcgdGhlIGRvbSBlbGVtZW50cywgdGhlIG50aCBkb20gZWxlbWVudHMgbm8gbG9uZ2VyXG4gICAgICAgICAgICAvLyBuZWNlc3NhcmlseSByZXByZXNlbnRzIHRoZSBudGggYXhpcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpIGlzIHRoZSBvcmlnaW5hbCBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGogaXMgdGhlIG5ldyBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgICAgICAvLyBFbGVtZW50IG1vdmVkIGxlZnRcbiAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBwYXJlbnQuY2hpbGRyZW5baiAtIDFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEVsZW1lbnQgbW92ZWQgcmlnaHRcbiAgICAgICAgICAgICAgaWYgKGogKyAxIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogKyAxXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX19vcmlnaW5fXztcbiAgICAgICAgICBkZWxldGUgZHJhZ2dpbmdbZF07XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknKTtcbiAgICAgICAgICBwYy5yZW5kZXIoKTtcbiAgICAgICAgfSksXG4gICAgKTtcbiAgICBmbGFncy5yZW9yZGVyYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVvcmRlciBkaW1lbnNpb25zLCBzdWNoIHRoYXQgdGhlIGhpZ2hlc3QgdmFsdWUgKHZpc3VhbGx5KSBpcyBvbiB0aGUgbGVmdCBhbmRcbiAgLy8gdGhlIGxvd2VzdCBvbiB0aGUgcmlnaHQuIFZpc3VhbCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGRhdGEgdmFsdWVzIGluXG4gIC8vIHRoZSBnaXZlbiByb3cuXG4gIHBjLnJlb3JkZXIgPSBmdW5jdGlvbiAocm93ZGF0YSkge1xuICAgIHZhciBkaW1zID0gX18uZGltZW5zaW9ucy5zbGljZSgwKTtcbiAgICBfXy5kaW1lbnNpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBwaXhlbERpZmZlcmVuY2UgPSB5c2NhbGVbYV0ocm93ZGF0YVthXSkgLSB5c2NhbGVbYl0ocm93ZGF0YVtiXSk7XG5cbiAgICAgIC8vIEFycmF5LnNvcnQgaXMgbm90IG5lY2Vzc2FyaWx5IHN0YWJsZSwgdGhpcyBtZWFucyB0aGF0IGlmIHBpeGVsRGlmZmVyZW5jZSBpcyB6ZXJvXG4gICAgICAvLyB0aGUgb3JkZXJpbmcgb2YgZGltZW5zaW9ucyBtaWdodCBjaGFuZ2UgdW5leHBlY3RlZGx5LiBUaGlzIGlzIHNvbHZlZCBieSBzb3J0aW5nIG9uXG4gICAgICAvLyB2YXJpYWJsZSBuYW1lIGluIHRoYXQgY2FzZS5cbiAgICAgIGlmIChwaXhlbERpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgICAgIH0gLy8gZWxzZVxuICAgICAgcmV0dXJuIHBpeGVsRGlmZmVyZW5jZTtcbiAgICB9KTtcblxuICAgIC8vIE5PVEU6IHRoaXMgaXMgcmVsYXRpdmVseSBjaGVhcCBnaXZlbiB0aGF0OlxuICAgIC8vIG51bWJlciBvZiBkaW1lbnNpb25zIDwgbnVtYmVyIG9mIGRhdGEgaXRlbXNcbiAgICAvLyBUaHVzIHdlIGNoZWNrIGVxdWFsaXR5IG9mIG9yZGVyIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgd2hlbiB0aGlzIGlzIHRoZSBjYXNlLlxuICAgIHZhciByZW9yZGVyZWQgPSBmYWxzZTtcbiAgICBkaW1zLnNvbWUoZnVuY3Rpb24gKHZhbCwgaW5kZXgpIHtcbiAgICAgIHJlb3JkZXJlZCA9IHZhbCAhPT0gX18uZGltZW5zaW9uc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVvcmRlcmVkO1xuICAgIH0pO1xuXG4gICAgaWYgKHJlb3JkZXJlZCkge1xuICAgICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcbiAgICAgIHZhciBoaWdobGlnaHRlZCA9IF9fLmhpZ2hsaWdodGVkLnNsaWNlKDApO1xuICAgICAgcGMudW5oaWdobGlnaHQoKTtcblxuICAgICAgZy50cmFuc2l0aW9uKClcbiAgICAgICAgLmR1cmF0aW9uKDE1MDApXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKSc7XG4gICAgICAgIH0pO1xuICAgICAgcGMucmVuZGVyKCk7XG5cbiAgICAgIC8vIHBjLmhpZ2hsaWdodCgpIGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgaGlnaGxpZ2h0ZWQgaXMgbGVuZ3RoIHplcm8sIHNvIHdlIGRvIHRoYXQgaGVyZS5cbiAgICAgIGlmIChoaWdobGlnaHRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcGMuaGlnaGxpZ2h0KGhpZ2hsaWdodGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcGFpcnMgb2YgYWRqYWNlbnQgZGltZW5zaW9uc1xuICBwYy5hZGphY2VudF9wYWlycyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICByZXQucHVzaChbYXJyW2ldLCBhcnJbaSArIDFdXSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIGJydXNoID0ge1xuICAgIG1vZGVzOiB7XG4gICAgICBOb25lOiB7XG4gICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uIChwYykge30sIC8vIE5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAocGMpIHt9LCAvLyBOb3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LCAvLyBOb3RoaW5nIHRvIHJldHVyblxuICAgICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIG1vZGU6ICdOb25lJyxcbiAgICBwcmVkaWNhdGU6ICdBTkQnLFxuICAgIGN1cnJlbnRNb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2Rlc1t0aGlzLm1vZGVdO1xuICAgIH0sXG4gIH07XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBmb3IgJ2xpdmUnIHVwZGF0ZXMgb2YgYnJ1c2hlcy4gVGhhdCBpcywgZHVyaW5nIHRoZVxuICAvLyBzcGVjaWZpY2F0aW9uIG9mIGEgYnJ1c2gsIHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoZSB2aWV3LlxuICAvL1xuICAvLyBAcGFyYW0gbmV3U2VsZWN0aW9uIC0gVGhlIG5ldyBzZXQgb2YgZGF0YSBpdGVtcyB0aGF0IGlzIGN1cnJlbnRseSBjb250YWluZWRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGJ5IHRoZSBicnVzaGVzXG4gIGZ1bmN0aW9uIGJydXNoVXBkYXRlZChuZXdTZWxlY3Rpb24pIHtcbiAgICBfXy5icnVzaGVkID0gbmV3U2VsZWN0aW9uO1xuICAgIGV2ZW50cy5icnVzaC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBicnVzaFByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBicnVzaC5wcmVkaWNhdGU7XG4gICAgfVxuXG4gICAgcHJlZGljYXRlID0gU3RyaW5nKHByZWRpY2F0ZSkudG9VcHBlckNhc2UoKTtcbiAgICBpZiAocHJlZGljYXRlICE9PSAnQU5EJyAmJiBwcmVkaWNhdGUgIT09ICdPUicpIHtcbiAgICAgIHRocm93ICdJbnZhbGlkIHByZWRpY2F0ZSAnICsgcHJlZGljYXRlO1xuICAgIH1cblxuICAgIGJydXNoLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICBfXy5icnVzaGVkID0gYnJ1c2guY3VycmVudE1vZGUoKS5zZWxlY3RlZCgpO1xuICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICByZXR1cm4gcGM7XG4gIH1cblxuICBwYy5icnVzaE1vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhicnVzaC5tb2Rlcyk7XG4gIH07XG5cbiAgcGMuYnJ1c2hNb2RlID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJydXNoLm1vZGU7XG4gICAgfVxuXG4gICAgaWYgKHBjLmJydXNoTW9kZXMoKS5pbmRleE9mKG1vZGUpID09PSAtMSkge1xuICAgICAgdGhyb3cgJ3BjLmJydXNobW9kZTogVW5zdXBwb3J0ZWQgYnJ1c2ggbW9kZTogJyArIG1vZGU7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgdHJpZ2dlciB1bm5lY2Vzc2FyeSBldmVudHMgYnkgY2hlY2tpbmcgaWYgdGhlIG1vZGVcbiAgICAvLyBhY3R1YWxseSBjaGFuZ2VzLlxuICAgIGlmIChtb2RlICE9PSBicnVzaC5tb2RlKSB7XG4gICAgICAvLyBXaGVuIGNoYW5naW5nIGJydXNoIG1vZGVzLCB0aGUgZmlyc3QgdGhpbmcgd2UgbmVlZCB0byBkbyBpcyBjbGVhcmluZyBhbnlcbiAgICAgIC8vIGJydXNoZXMgZnJvbSB0aGUgY3VycmVudCBtb2RlLCBpZiBhbnkuXG4gICAgICBpZiAoYnJ1c2gubW9kZSAhPT0gJ05vbmUnKSB7XG4gICAgICAgIHBjLmJydXNoUmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTmV4dCwgd2UgbmVlZCB0byAndW5pbnN0YWxsJyB0aGUgY3VycmVudCBicnVzaE1vZGUuXG4gICAgICBicnVzaC5tb2Rlc1ticnVzaC5tb2RlXS51bmluc3RhbGwocGMpO1xuICAgICAgLy8gRmluYWxseSwgd2UgY2FuIGluc3RhbGwgdGhlIHJlcXVlc3RlZCBvbmUuXG4gICAgICBicnVzaC5tb2RlID0gbW9kZTtcbiAgICAgIGJydXNoLm1vZGVzW2JydXNoLm1vZGVdLmluc3RhbGwoKTtcbiAgICAgIGlmIChtb2RlID09PSAnTm9uZScpIHtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUHJlZGljYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGMuYnJ1c2hQcmVkaWNhdGUgPSBicnVzaFByZWRpY2F0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGM7XG4gIH07XG5cbiAgLy8gYnJ1c2ggbW9kZTogMUQtQXhlc1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJydXNoZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzX2JydXNoZWQocCkge1xuICAgICAgcmV0dXJuICFicnVzaGVzW3BdLmVtcHR5KCk7XG4gICAgfVxuXG4gICAgLy8gZGF0YSB3aXRoaW4gZXh0ZW50c1xuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGFjdGl2ZXMgPSBfXy5kaW1lbnNpb25zLmZpbHRlcihpc19icnVzaGVkKSxcbiAgICAgICAgZXh0ZW50cyA9IGFjdGl2ZXMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIGJydXNoZXNbcF0uZXh0ZW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiB0aGUgZnVsbCBkYXRhIHNldCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQuXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcbiAgICAgIC8vIHNlbGVjdGVkLiBTbywgbGV0J3MgYXZvaWQgdGhlIGZpbHRlcmluZyBhbmQganVzdCByZXR1cm4gZmFsc2UuXG4gICAgICAvL2lmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBSZXNvbHZlcyBicm9rZW4gZXhhbXBsZXMgZm9yIG5vdy4gVGhleSBleHBlY3QgdG8gZ2V0IHRoZSBmdWxsIGRhdGFzZXQgYmFjayBmcm9tIGVtcHR5IGJydXNoZXNcbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF9fLmRhdGE7XG5cbiAgICAgIC8vIHRlc3QgaWYgd2l0aGluIHJhbmdlXG4gICAgICB2YXIgd2l0aGluID0ge1xuICAgICAgICBkYXRlOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiZcbiAgICAgICAgICAgICAgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBudW1iZXI6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJlxuICAgICAgICAgICAgICB5c2NhbGVbcF0oZFtwXSkgPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmXG4gICAgICAgICAgICB5c2NhbGVbcF0oZFtwXSkgPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfXy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5ldmVyeShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3aXRoaW5bX18udHlwZXNbcF1dKGQsIHAsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5zb21lKGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaEV4dGVudHMoZXh0ZW50cykge1xuICAgICAgaWYgKHR5cGVvZiBleHRlbnRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXh0ZW50cyA9IHt9O1xuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB2YXIgYnJ1c2ggPSBicnVzaGVzW2RdO1xuICAgICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkICYmICFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgICBleHRlbnQuc29ydChkMy5hc2NlbmRpbmcpO1xuICAgICAgICAgICAgZXh0ZW50c1tkXSA9IGV4dGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXh0ZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZmlyc3QgZ2V0IGFsbCB0aGUgYnJ1c2ggc2VsZWN0aW9uc1xuICAgICAgICB2YXIgYnJ1c2hTZWxlY3Rpb25zID0ge307XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgYnJ1c2hTZWxlY3Rpb25zW2RdID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsb29wIG92ZXIgZWFjaCBkaW1lbnNpb24gYW5kIHVwZGF0ZSBhcHByb3ByaWF0ZWx5IChpZiBpdCB3YXMgcGFzc2VkIGluIHRocm91Z2ggZXh0ZW50cylcbiAgICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKGV4dGVudHNbZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XG4gICAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBleHRlbnRcbiAgICAgICAgICAgIGJydXNoLmV4dGVudChleHRlbnRzW2RdKTtcblxuICAgICAgICAgICAgLy9yZWRyYXcgdGhlIGJydXNoXG4gICAgICAgICAgICBicnVzaChicnVzaFNlbGVjdGlvbnNbZF0pO1xuXG4gICAgICAgICAgICAvL2ZpcmUgc29tZSBldmVudHNcbiAgICAgICAgICAgIGJydXNoLmV2ZW50KGJydXNoU2VsZWN0aW9uc1tkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvL3JlZHJhdyB0aGUgY2hhcnRcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBicnVzaEZvcihheGlzKSB7XG4gICAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKTtcblxuICAgICAgYnJ1c2hcbiAgICAgICAgLnkoeXNjYWxlW2F4aXNdKVxuICAgICAgICAub24oJ2JydXNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYnJ1c2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2JydXNoZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGJydXNoZXNbYXhpc10gPSBicnVzaDtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChkaW1lbnNpb24pIHtcbiAgICAgIF9fLmJydXNoZWQgPSBmYWxzZTtcbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hlc1tkXS5jbGVhcigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICBpZiAoIWcpIHBjLmNyZWF0ZUF4ZXMoKTtcblxuICAgICAgLy8gQWRkIGFuZCBzdG9yZSBhIGJydXNoIGZvciBlYWNoIGF4aXMuXG4gICAgICBnLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYnJ1c2gnKVxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoRm9yKGQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsIG51bGwpXG4gICAgICAgIC5hdHRyKCd4JywgLTE1KVxuICAgICAgICAuYXR0cignd2lkdGgnLCAzMCk7XG5cbiAgICAgIHBjLmJydXNoRXh0ZW50cyA9IGJydXNoRXh0ZW50cztcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0O1xuICAgICAgcmV0dXJuIHBjO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycxRC1heGVzJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5yZW1vdmUoKTtcbiAgICAgICAgYnJ1c2hlcyA9IHt9O1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hFeHRlbnRzO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBicnVzaFN0YXRlOiBicnVzaEV4dGVudHMsXG4gICAgfTtcbiAgfSkoKTtcbiAgLy8gYnJ1c2ggbW9kZTogMkQtc3RydW1zXG4gIC8vIGJsLm9ja3Mub3JnL3N5bnRhZ21hdGljLzU0NDEwMjJcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJ1bXMgPSB7fSxcbiAgICAgIHN0cnVtUmVjdDtcblxuICAgIGZ1bmN0aW9uIGRyYXdTdHJ1bShzdHJ1bSwgYWN0aXZlUG9pbnQpIHtcbiAgICAgIHZhciBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjc3RydW1zJyksXG4gICAgICAgIGlkID0gc3RydW0uZGltcy5pLFxuICAgICAgICBwb2ludHMgPSBbc3RydW0ucDEsIHN0cnVtLnAyXSxcbiAgICAgICAgbGluZSA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUjc3RydW0tJyArIGlkKS5kYXRhKFtzdHJ1bV0pLFxuICAgICAgICBjaXJjbGVzID0gc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI3N0cnVtLScgKyBpZCkuZGF0YShwb2ludHMpLFxuICAgICAgICBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xuXG4gICAgICBsaW5lXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RydW0tJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnc3RydW0nKTtcblxuICAgICAgbGluZVxuICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAxWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAxWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAyWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLnAyWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xuXG4gICAgICBkcmFnXG4gICAgICAgIC5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQ7XG4gICAgICAgICAgaSA9IGkgKyAxO1xuICAgICAgICAgIHN0cnVtWydwJyArIGldWzBdID0gTWF0aC5taW4oXG4gICAgICAgICAgICBNYXRoLm1heChzdHJ1bS5taW5YICsgMSwgZXYueCksXG4gICAgICAgICAgICBzdHJ1bS5tYXhYLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RydW1bJ3AnICsgaV1bMV0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5ZLCBldi55KSwgc3RydW0ubWF4WSk7XG4gICAgICAgICAgZHJhd1N0cnVtKHN0cnVtLCBpIC0gMSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZCgpKTtcblxuICAgICAgY2lyY2xlc1xuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RydW0tJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnc3RydW0nKTtcblxuICAgICAgY2lyY2xlc1xuICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkWzBdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cigncicsIDUpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZVBvaW50ICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gYWN0aXZlUG9pbnQgPyAwLjggOiAwO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDApO1xuICAgICAgICB9KVxuICAgICAgICAuY2FsbChkcmFnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaW1lbnNpb25zRm9yUG9pbnQocCkge1xuICAgICAgdmFyIGRpbXMgPSB7IGk6IC0xLCBsZWZ0OiB1bmRlZmluZWQsIHJpZ2h0OiB1bmRlZmluZWQgfTtcbiAgICAgIF9fLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAoZGltLCBpKSB7XG4gICAgICAgIGlmICh4c2NhbGUoZGltKSA8IHBbMF0pIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IF9fLmRpbWVuc2lvbnNbaSArIDFdO1xuICAgICAgICAgIGRpbXMuaSA9IGk7XG4gICAgICAgICAgZGltcy5sZWZ0ID0gZGltO1xuICAgICAgICAgIGRpbXMucmlnaHQgPSBuZXh0O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZGltcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZmlyc3QgYXhpcy5cbiAgICAgICAgZGltcy5pID0gMDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1swXTtcbiAgICAgICAgZGltcy5yaWdodCA9IF9fLmRpbWVuc2lvbnNbMV07XG4gICAgICB9IGVsc2UgaWYgKGRpbXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGFzdCBheGlzXG4gICAgICAgIGRpbXMuaSA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZGltcy5yaWdodCA9IGRpbXMubGVmdDtcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1tfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcbiAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGJldHdlZW4gd2hpY2ggdHdvIGF4ZXMgdGhlIHN0dXJtIHdhcyBzdGFydGVkLlxuICAgICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgZnJlZWRvbSBvZiBtb3ZlbWVudCwgYmVjYXVzZSBhIHN0cnVtIGNhblxuICAgICAgLy8gbG9naWNhbGx5IG9ubHkgaGFwcGVuIGJldHdlZW4gdHdvIGF4ZXMsIHNvIG5vIG1vdmVtZW50IG91dHNpZGUgdGhlc2UgYXhlc1xuICAgICAgLy8gc2hvdWxkIGJlIGFsbG93ZWQuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IGQzLm1vdXNlKHN0cnVtUmVjdFswXVswXSksXG4gICAgICAgICAgZGltcyxcbiAgICAgICAgICBzdHJ1bTtcblxuICAgICAgICBwWzBdID0gcFswXSAtIF9fLm1hcmdpbi5sZWZ0O1xuICAgICAgICBwWzFdID0gcFsxXSAtIF9fLm1hcmdpbi50b3A7XG5cbiAgICAgICAgKGRpbXMgPSBkaW1lbnNpb25zRm9yUG9pbnQocCkpLFxuICAgICAgICAgIChzdHJ1bSA9IHtcbiAgICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgICAgZGltczogZGltcyxcbiAgICAgICAgICAgIG1pblg6IHhzY2FsZShkaW1zLmxlZnQpLFxuICAgICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgICAgbWluWTogMCxcbiAgICAgICAgICAgIG1heFk6IGgoKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBzdHJ1bXNbZGltcy5pXSA9IHN0cnVtO1xuICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZGltcy5pO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBzdHJ1bS5wMVswXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblgsIHBbMF0pLCBzdHJ1bS5tYXhYKTtcbiAgICAgICAgc3RydW0ucDIgPSBzdHJ1bS5wMS5zbGljZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWcoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXYgPSBkMy5ldmVudCxcbiAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgc3RydW0ucDJbMF0gPSBNYXRoLm1pbihcbiAgICAgICAgICBNYXRoLm1heChzdHJ1bS5taW5YICsgMSwgZXYueCAtIF9fLm1hcmdpbi5sZWZ0KSxcbiAgICAgICAgICBzdHJ1bS5tYXhYLFxuICAgICAgICApO1xuICAgICAgICBzdHJ1bS5wMlsxXSA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KHN0cnVtLm1pblksIGV2LnkgLSBfXy5tYXJnaW4udG9wKSxcbiAgICAgICAgICBzdHJ1bS5tYXhZLFxuICAgICAgICApO1xuICAgICAgICBkcmF3U3RydW0oc3RydW0sIDEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWlubWVudFRlc3Qoc3RydW0sIHdpZHRoKSB7XG4gICAgICB2YXIgcDEgPSBbc3RydW0ucDFbMF0gLSBzdHJ1bS5taW5YLCBzdHJ1bS5wMVsxXSAtIHN0cnVtLm1pblhdLFxuICAgICAgICBwMiA9IFtzdHJ1bS5wMlswXSAtIHN0cnVtLm1pblgsIHN0cnVtLnAyWzFdIC0gc3RydW0ubWluWF0sXG4gICAgICAgIG0xID0gMSAtIHdpZHRoIC8gcDFbMF0sXG4gICAgICAgIGIxID0gcDFbMV0gKiAoMSAtIG0xKSxcbiAgICAgICAgbTIgPSAxIC0gd2lkdGggLyBwMlswXSxcbiAgICAgICAgYjIgPSBwMlsxXSAqICgxIC0gbTIpO1xuXG4gICAgICAvLyB0ZXN0IGlmIHBvaW50IGZhbGxzIGJldHdlZW4gbGluZXNcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgeCA9IHBbMF0sXG4gICAgICAgICAgeSA9IHBbMV0sXG4gICAgICAgICAgeTEgPSBtMSAqIHggKyBiMSxcbiAgICAgICAgICB5MiA9IG0yICogeCArIGIyO1xuXG4gICAgICAgIGlmICh5ID4gTWF0aC5taW4oeTEsIHkyKSAmJiB5IDwgTWF0aC5tYXgoeTEsIHkyKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdHJ1bXMpLFxuICAgICAgICBicnVzaGVkID0gX18uZGF0YTtcblxuICAgICAgLy8gR2V0IHRoZSBpZHMgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc3RydW1zLlxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyb3NzZXNTdHJ1bShkLCBpZCkge1xuICAgICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbaWRdLFxuICAgICAgICAgIHRlc3QgPSBjb250YWlubWVudFRlc3Qoc3RydW0sIHN0cnVtcy53aWR0aChpZCkpLFxuICAgICAgICAgIGQxID0gc3RydW0uZGltcy5sZWZ0LFxuICAgICAgICAgIGQyID0gc3RydW0uZGltcy5yaWdodCxcbiAgICAgICAgICB5MSA9IHlzY2FsZVtkMV0sXG4gICAgICAgICAgeTIgPSB5c2NhbGVbZDJdLFxuICAgICAgICAgIHBvaW50ID0gW3kxKGRbZDFdKSAtIHN0cnVtLm1pblgsIHkyKGRbZDJdKSAtIHN0cnVtLm1pblhdO1xuICAgICAgICByZXR1cm4gdGVzdChwb2ludCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBicnVzaGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJ1c2hlZC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cnVtKCkge1xuICAgICAgdmFyIHN0cnVtID0gc3RydW1zW3N0cnVtcy5hY3RpdmVdLFxuICAgICAgICBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjc3RydW1zJyk7XG5cbiAgICAgIGRlbGV0ZSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07XG4gICAgICBzdHJ1bXMuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgc3RydW0uZGltcy5pKS5yZW1vdmUoKTtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNzdHJ1bS0nICsgc3RydW0uZGltcy5pKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnJ1c2hlZCA9IF9fLmRhdGEsXG4gICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07XG5cbiAgICAgICAgLy8gT2theSwgc29tZXdoYXQgdW5leHBlY3RlZCwgYnV0IG5vdCB0b3RhbGx5IHVuc3VycHJpc2luZywgYSBtb3VzY2xpY2sgaXNcbiAgICAgICAgLy8gY29uc2lkZXJlZCBhIGRyYWcgd2l0aG91dCBtb3ZlLiBTbyB3ZSBoYXZlIHRvIGRlYWwgd2l0aCB0aGF0IGNhc2VcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0cnVtICYmXG4gICAgICAgICAgc3RydW0ucDFbMF0gPT09IHN0cnVtLnAyWzBdICYmXG4gICAgICAgICAgc3RydW0ucDFbMV0gPT09IHN0cnVtLnAyWzFdXG4gICAgICAgICkge1xuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoc3RydW1zKTtcbiAgICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX18uYnJ1c2hlZCA9IGJydXNoZWQ7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KHN0cnVtcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDtcbiAgICAgICAgICByZW1vdmVTdHJ1bShzdHJ1bXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25EcmFnRW5kKHN0cnVtcykoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIHZhciBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xuXG4gICAgICAvLyBNYXAgb2YgY3VycmVudCBzdHJ1bXMuIFN0cnVtcyBhcmUgc3RvcmVkIHBlciBzZWdtZW50IG9mIHRoZSBQQy4gQSBzZWdtZW50LFxuICAgICAgLy8gYmVpbmcgdGhlIGFyZWEgYmV0d2VlbiB0d28gYXhlcy4gVGhlIGxlZnQgbW9zdCBhcmVhIGlzIGluZGV4ZWQgYXQgMC5cbiAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgUEMgc2VnbWVudCB3aGVyZSBjdXJyZW50bHkgYSBzdHJ1bSBpcyBiZWluZ1xuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xuICAgICAgLy8gd2VsbC5cbiAgICAgIHN0cnVtcy53aWR0aCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbaWRdO1xuXG4gICAgICAgIGlmIChzdHJ1bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJ1bS5tYXhYIC0gc3RydW0ubWluWDtcbiAgICAgIH07XG5cbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5zdHJ1bXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdHJ1bXMpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnNlY3V0aXZlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gX18uZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIF9fLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQgPT09IGZpcnN0XG4gICAgICAgICAgICAgID8gaSArIGkgPCBsZW5ndGggJiYgX18uZGltZW5zaW9uc1tpICsgMV0gPT09IHNlY29uZFxuICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBzb21lIHN0cnVtcywgd2hpY2ggbWlnaHQgbmVlZCB0byBiZSByZW1vdmVkLlxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IHN0cnVtc1tkXS5kaW1zO1xuICAgICAgICAgICAgc3RydW1zLmFjdGl2ZSA9IGQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHdvIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgc3RydW0gYXJlIG5vdCBuZXh0IHRvIGVhY2ggb3RoZXJcbiAgICAgICAgICAgIC8vIGFueSBtb3JlLCB0aGFuIHdlJ2xsIG5lZWQgdG8gcmVtb3ZlIHRoZSBzdHJ1bS4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXG4gICAgICAgICAgICBpZiAoIWNvbnNlY3V0aXZlKGRpbXMubGVmdCwgZGltcy5yaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBzdHJ1bXMuXG4gICAgICBwYy5zZWxlY3Rpb25cbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcbiAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bXMnKVxuICAgICAgICAuYXR0cihcbiAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScsXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEluc3RhbGwgdGhlIHJlcXVpcmVkIGJydXNoUmVzZXQgZnVuY3Rpb25cbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0KHN0cnVtcyk7XG5cbiAgICAgIGRyYWdcbiAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydChzdHJ1bXMpKVxuICAgICAgICAub24oJ2RyYWcnLCBvbkRyYWcoc3RydW1zKSlcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKHN0cnVtcykpO1xuXG4gICAgICAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgIC8vICAgICAgIGZvciAxRCBicnVzaGluZywgdGhlIGNhbnZhcyBsYXllcnMgc2hvdWxkIG5vdCBsaXN0ZW4gdG9cbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxuICAgICAgc3RydW1SZWN0ID0gcGMuc2VsZWN0aW9uXG4gICAgICAgIC5zZWxlY3QoJ3N2ZycpXG4gICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAnZyNzdHJ1bXMnKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RydW0tZXZlbnRzJylcbiAgICAgICAgLmF0dHIoJ3gnLCBfXy5tYXJnaW4ubGVmdClcbiAgICAgICAgLmF0dHIoJ3knLCBfXy5tYXJnaW4udG9wKVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3KCkpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoKCkgKyAyKVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxuICAgICAgICAuY2FsbChkcmFnKTtcbiAgICB9XG5cbiAgICBicnVzaC5tb2Rlc1snMkQtc3RydW1zJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKS5yZW1vdmUoKTtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdyZWN0I3N0cnVtLWV2ZW50cycpLnJlbW92ZSgpO1xuICAgICAgICBwYy5vbignYXhlc3Jlb3JkZXIuc3RydW1zJywgdW5kZWZpbmVkKTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG5cbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN0cnVtcztcbiAgICAgIH0sXG4gICAgfTtcbiAgfSkoKTtcblxuICAvLyBicnVzaCBtb2RlOiAxRC1BeGVzIHdpdGggbXVsdGlwbGUgZXh0ZW50c1xuICAvLyByZXF1aXJlcyBkMy5zdmcubXVsdGlicnVzaFxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBkMy5zdmcubXVsdGlicnVzaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYnJ1c2hlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNfYnJ1c2hlZChwKSB7XG4gICAgICByZXR1cm4gIWJydXNoZXNbcF0uZW1wdHkoKTtcbiAgICB9XG5cbiAgICAvLyBkYXRhIHdpdGhpbiBleHRlbnRzXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgYWN0aXZlcyA9IF9fLmRpbWVuc2lvbnMuZmlsdGVyKGlzX2JydXNoZWQpLFxuICAgICAgICBleHRlbnRzID0gYWN0aXZlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICByZXR1cm4gYnJ1c2hlc1twXS5leHRlbnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIHRoZSBmdWxsIGRhdGEgc2V0IHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZC5cbiAgICAgIC8vIEFjdHVhbGx5LCB3aGVuIHRoZXJlIGFyZSBubyBheGVzIGJydXNoZWQsIGJ5IGRlZmluaXRpb24sIG5vIGl0ZW1zIGFyZVxuICAgICAgLy8gc2VsZWN0ZWQuIFNvLCBsZXQncyBhdm9pZCB0aGUgZmlsdGVyaW5nIGFuZCBqdXN0IHJldHVybiBmYWxzZS5cbiAgICAgIC8vaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIFJlc29sdmVzIGJyb2tlbiBleGFtcGxlcyBmb3Igbm93LiBUaGV5IGV4cGVjdCB0byBnZXQgdGhlIGZ1bGwgZGF0YXNldCBiYWNrIGZyb20gZW1wdHkgYnJ1c2hlc1xuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gX18uZGF0YTtcblxuICAgICAgLy8gdGVzdCBpZiB3aXRoaW4gcmFuZ2VcbiAgICAgIHZhciB3aXRoaW4gPSB7XG4gICAgICAgIGRhdGU6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBiWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSBkW3BdICYmIGRbcF0gPD0gYlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbiwgYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGJbMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBiWzFdO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF9fLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLmV2ZXJ5KGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXS5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uLCBiKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5zb21lKGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXS5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uLCBiKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hFeHRlbnRzKCkge1xuICAgICAgdmFyIGV4dGVudHMgPSB7fTtcbiAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgYnJ1c2ggPSBicnVzaGVzW2RdO1xuICAgICAgICBpZiAoYnJ1c2ggIT09IHVuZGVmaW5lZCAmJiAhYnJ1c2guZW1wdHkoKSkge1xuICAgICAgICAgIHZhciBleHRlbnQgPSBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgICBleHRlbnRzW2RdID0gZXh0ZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBleHRlbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRm9yKGF4aXMpIHtcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5tdWx0aWJydXNoKCk7XG5cbiAgICAgIGJydXNoXG4gICAgICAgIC55KHlzY2FsZVtheGlzXSlcbiAgICAgICAgLm9uKCdicnVzaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2JydXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdicnVzaGVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBkMy5zdmcubXVsdGlicnVzaCBjbGVhcnMgZXh0ZW50cyBqdXN0IGJlZm9yZSBjYWxsaW5nICdicnVzaGVuZCdcbiAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIHVwZGF0ZSBoZXJlIGFnYWluLlxuICAgICAgICAgIC8vIFRoaXMgZml4ZXMgaXNzdWUgIzEwMyBmb3Igbm93LCBidXQgc2hvdWxkIGJlIGNoYW5nZWQgaW4gZDMuc3ZnLm11bHRpYnJ1c2hcbiAgICAgICAgICAvLyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb21wdXRhdGlvbi5cbiAgICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XG4gICAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgICB9KVxuICAgICAgICAuZXh0ZW50QWRhcHRpb24oZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgIHNlbGVjdGlvbi5zdHlsZSgndmlzaWJpbGl0eScsIG51bGwpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xuICAgICAgICB9KVxuICAgICAgICAucmVzaXplQWRhcHRpb24oZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJ3JlY3QnKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGJydXNoZXNbYXhpc10gPSBicnVzaDtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGRpbWVuc2lvbikge1xuICAgICAgX18uYnJ1c2hlZCA9IGZhbHNlO1xuICAgICAgaWYgKGcpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaGVzW2RdLmNsZWFyKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpO1xuXG4gICAgICAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cbiAgICAgIGcuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdicnVzaCcpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hGb3IoZCkpO1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbClcbiAgICAgICAgLmF0dHIoJ3gnLCAtMTUpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIDMwKTtcblxuICAgICAgcGMuYnJ1c2hFeHRlbnRzID0gYnJ1c2hFeHRlbnRzO1xuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQ7XG4gICAgICByZXR1cm4gcGM7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJzFELWF4ZXMtbXVsdGknXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLnJlbW92ZSgpO1xuICAgICAgICBicnVzaGVzID0ge307XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaEV4dGVudHM7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGJydXNoRXh0ZW50cyxcbiAgICB9O1xuICB9KSgpO1xuICAvLyBicnVzaCBtb2RlOiBhbmd1bGFyXG4gIC8vIGNvZGUgYmFzZWQgb24gMkQuc3RydW1zLmpzXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJjcyA9IHt9LFxuICAgICAgc3RydW1SZWN0O1xuXG4gICAgZnVuY3Rpb24gZHJhd1N0cnVtKGFyYywgYWN0aXZlUG9pbnQpIHtcbiAgICAgIHZhciBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjYXJjcycpLFxuICAgICAgICBpZCA9IGFyYy5kaW1zLmksXG4gICAgICAgIHBvaW50cyA9IFthcmMucDIsIGFyYy5wM10sXG4gICAgICAgIGxpbmUgPSBzdmcuc2VsZWN0QWxsKCdsaW5lI2FyYy0nICsgaWQpLmRhdGEoW1xuICAgICAgICAgIHsgcDE6IGFyYy5wMSwgcDI6IGFyYy5wMiB9LFxuICAgICAgICAgIHsgcDE6IGFyYy5wMSwgcDI6IGFyYy5wMyB9LFxuICAgICAgICBdKSxcbiAgICAgICAgY2lyY2xlcyA9IHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNhcmMtJyArIGlkKS5kYXRhKHBvaW50cyksXG4gICAgICAgIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCksXG4gICAgICAgIHBhdGggPSBzdmcuc2VsZWN0QWxsKCdwYXRoI2FyYy0nICsgaWQpLmRhdGEoW2FyY10pO1xuXG4gICAgICBwYXRoXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLScgKyBpZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2FyYycpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdvcmFuZ2UnKVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjUpO1xuXG4gICAgICBwYXRoXG4gICAgICAgIC5hdHRyKCdkJywgYXJjLmFyYylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGFyYy5wMVswXSArICcsJyArIGFyYy5wMVsxXSArICcpJyk7XG5cbiAgICAgIGxpbmVcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmMtJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJyk7XG5cbiAgICAgIGxpbmVcbiAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMVswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMVsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMlswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMlsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcblxuICAgICAgZHJhZ1xuICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgYW5nbGUgPSAwO1xuXG4gICAgICAgICAgaSA9IGkgKyAyO1xuXG4gICAgICAgICAgYXJjWydwJyArIGldWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblggKyAxLCBldi54KSwgYXJjLm1heFgpO1xuICAgICAgICAgIGFyY1sncCcgKyBpXVsxXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5ZLCBldi55KSwgYXJjLm1heFkpO1xuXG4gICAgICAgICAgYW5nbGUgPSBpID09PSAzID8gYXJjcy5zdGFydEFuZ2xlKGlkKSA6IGFyY3MuZW5kQW5nbGUoaWQpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGFyYy5zdGFydEFuZ2xlIDwgTWF0aC5QSSAmJlxuICAgICAgICAgICAgICBhcmMuZW5kQW5nbGUgPCBNYXRoLlBJICYmXG4gICAgICAgICAgICAgIGFuZ2xlIDwgTWF0aC5QSSkgfHxcbiAgICAgICAgICAgIChhcmMuc3RhcnRBbmdsZSA+PSBNYXRoLlBJICYmXG4gICAgICAgICAgICAgIGFyYy5lbmRBbmdsZSA+PSBNYXRoLlBJICYmXG4gICAgICAgICAgICAgIGFuZ2xlID49IE1hdGguUEkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgYXJjLmFyYy5lbmRBbmdsZShhbmdsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDMpIHtcbiAgICAgICAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgYXJjLmFyYy5zdGFydEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkcmF3U3RydW0oYXJjLCBpIC0gMik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZCgpKTtcblxuICAgICAgY2lyY2xlc1xuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLScgKyBpZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2FyYycpO1xuXG4gICAgICBjaXJjbGVzXG4gICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdyJywgNSlcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDAuOCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnNGb3JQb2ludChwKSB7XG4gICAgICB2YXIgZGltcyA9IHsgaTogLTEsIGxlZnQ6IHVuZGVmaW5lZCwgcmlnaHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcbiAgICAgICAgaWYgKHhzY2FsZShkaW0pIDwgcFswXSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XG4gICAgICAgICAgZGltcy5pID0gaTtcbiAgICAgICAgICBkaW1zLmxlZnQgPSBkaW07XG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkaW1zLmxlZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBmaXJzdCBheGlzLlxuICAgICAgICBkaW1zLmkgPSAwO1xuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zWzBdO1xuICAgICAgICBkaW1zLnJpZ2h0ID0gX18uZGltZW5zaW9uc1sxXTtcbiAgICAgIH0gZWxzZSBpZiAoZGltcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBsYXN0IGF4aXNcbiAgICAgICAgZGltcy5pID0gX18uZGltZW5zaW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBkaW1zLnJpZ2h0ID0gZGltcy5sZWZ0O1xuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zW19fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge1xuICAgICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBkZXRlcm1pbmUgYmV0d2VlbiB3aGljaCB0d28gYXhlcyB0aGUgYXJjIHdhcyBzdGFydGVkLlxuICAgICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgZnJlZWRvbSBvZiBtb3ZlbWVudCwgYmVjYXVzZSBhIGFyYyBjYW5cbiAgICAgIC8vIGxvZ2ljYWxseSBvbmx5IGhhcHBlbiBiZXR3ZWVuIHR3byBheGVzLCBzbyBubyBtb3ZlbWVudCBvdXRzaWRlIHRoZXNlIGF4ZXNcbiAgICAgIC8vIHNob3VsZCBiZSBhbGxvd2VkLlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSBkMy5tb3VzZShzdHJ1bVJlY3RbMF1bMF0pLFxuICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgYXJjO1xuXG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgICAgIHBbMV0gPSBwWzFdIC0gX18ubWFyZ2luLnRvcDtcblxuICAgICAgICAoZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSksXG4gICAgICAgICAgKGFyYyA9IHtcbiAgICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgICAgZGltczogZGltcyxcbiAgICAgICAgICAgIG1pblg6IHhzY2FsZShkaW1zLmxlZnQpLFxuICAgICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgICAgbWluWTogMCxcbiAgICAgICAgICAgIG1heFk6IGgoKSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmM6IGQzLnN2Zy5hcmMoKS5pbm5lclJhZGl1cygwKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBhcmNzW2RpbXMuaV0gPSBhcmM7XG4gICAgICAgIGFyY3MuYWN0aXZlID0gZGltcy5pO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBhcmMucDFbMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCwgcFswXSksIGFyYy5tYXhYKTtcbiAgICAgICAgYXJjLnAyID0gYXJjLnAxLnNsaWNlKCk7XG4gICAgICAgIGFyYy5wMyA9IGFyYy5wMS5zbGljZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWcoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXYgPSBkMy5ldmVudCxcbiAgICAgICAgICBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgYXJjLnAyWzBdID0gTWF0aC5taW4oXG4gICAgICAgICAgTWF0aC5tYXgoYXJjLm1pblggKyAxLCBldi54IC0gX18ubWFyZ2luLmxlZnQpLFxuICAgICAgICAgIGFyYy5tYXhYLFxuICAgICAgICApO1xuICAgICAgICBhcmMucDJbMV0gPSBNYXRoLm1pbihcbiAgICAgICAgICBNYXRoLm1heChhcmMubWluWSwgZXYueSAtIF9fLm1hcmdpbi50b3ApLFxuICAgICAgICAgIGFyYy5tYXhZLFxuICAgICAgICApO1xuICAgICAgICBhcmMucDMgPSBhcmMucDIuc2xpY2UoKTtcbiAgICAgICAgZHJhd1N0cnVtKGFyYywgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNvbWUgaGVscGVyIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGh5cG90aGVudXNlKGEsIGIpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgfVxuXG4gICAgdmFyIHJhZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYyA9IE1hdGguUEkgLyAxODA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBhbmdsZSAqIGM7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICB2YXIgZGVnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjID0gMTgwIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlICogYztcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIC8vIFswLCAyKlBJXSAtPiBbLVBJLzIsIFBJLzJdXG4gICAgdmFyIHNpZ25lZEFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICB2YXIgcmV0ID0gYW5nbGU7XG4gICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMS41ICogTWF0aC5QSTtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAxLjUgKiBNYXRoLlBJO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAwLjUgKiBNYXRoLlBJO1xuICAgICAgICByZXQgPSBhbmdsZSAtIDAuNSAqIE1hdGguUEk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLXJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYW5nbGVzIGFyZSBzdG9yZWQgaW4gcmFkaWFucyBmcm9tIGluIFswLCAyKlBJXSwgd2hlcmUgMCBpbiAxMiBvJ2Nsb2NrLlxuICAgICAqIEhvd2V2ZXIsIG9uZSBjYW4gb25seSBzZWxlY3QgbGluZXMgZnJvbSAwIHRvIFBJLCBzbyB3ZSBjb21wdXRlIHRoZVxuICAgICAqICdzaWduZWQnIGFuZ2xlLCB3aGVyZSAwIGlzIHRoZSBob3Jpem9udGFsIGxpbmUgKDMgbydjbG9jayksIGFuZCArLy0gUEkvMlxuICAgICAqIGFyZSAxMiBhbmQgNiBvJ2Nsb2NrIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlubWVudFRlc3QoYXJjKSB7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHNpZ25lZEFuZ2xlKGFyYy5zdGFydEFuZ2xlKTtcbiAgICAgIHZhciBlbmRBbmdsZSA9IHNpZ25lZEFuZ2xlKGFyYy5lbmRBbmdsZSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3QgaWYgc2VnbWVudCBhbmdsZSBpcyBjb250YWluZWQgaW4gYW5nbGUgaW50ZXJ2YWxcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoYSA+PSBzdGFydEFuZ2xlICYmIGEgPD0gZW5kQW5nbGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcyksXG4gICAgICAgIGJydXNoZWQgPSBfXy5kYXRhO1xuXG4gICAgICAvLyBHZXQgdGhlIGlkcyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBhcmNzLlxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyb3NzZXNTdHJ1bShkLCBpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF0sXG4gICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChhcmMpLFxuICAgICAgICAgIGQxID0gYXJjLmRpbXMubGVmdCxcbiAgICAgICAgICBkMiA9IGFyYy5kaW1zLnJpZ2h0LFxuICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcbiAgICAgICAgICB5MiA9IHlzY2FsZVtkMl0sXG4gICAgICAgICAgYSA9IGFyY3Mud2lkdGgoaWQpLFxuICAgICAgICAgIGIgPSB5MShkW2QxXSkgLSB5MihkW2QyXSksXG4gICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpLFxuICAgICAgICAgIGFuZ2xlID0gTWF0aC5hc2luKGIgLyBjKTsgLy8gcmFkIGluIFstUEkvMiwgUEkvMl1cbiAgICAgICAgcmV0dXJuIHRlc3QoYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYnJ1c2hlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJydXNoZWQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSAnT1InOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcbiAgICAgIHZhciBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXSxcbiAgICAgICAgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKTtcblxuICAgICAgZGVsZXRlIGFyY3NbYXJjcy5hY3RpdmVdO1xuICAgICAgYXJjcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdsaW5lI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ3BhdGgjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnJ1c2hlZCA9IF9fLmRhdGEsXG4gICAgICAgICAgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV07XG5cbiAgICAgICAgLy8gT2theSwgc29tZXdoYXQgdW5leHBlY3RlZCwgYnV0IG5vdCB0b3RhbGx5IHVuc3VycHJpc2luZywgYSBtb3VzY2xpY2sgaXNcbiAgICAgICAgLy8gY29uc2lkZXJlZCBhIGRyYWcgd2l0aG91dCBtb3ZlLiBTbyB3ZSBoYXZlIHRvIGRlYWwgd2l0aCB0aGF0IGNhc2VcbiAgICAgICAgaWYgKGFyYyAmJiBhcmMucDFbMF0gPT09IGFyYy5wMlswXSAmJiBhcmMucDFbMV0gPT09IGFyYy5wMlsxXSkge1xuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyYykge1xuICAgICAgICAgIHZhciBhbmdsZSA9IGFyY3Muc3RhcnRBbmdsZShhcmNzLmFjdGl2ZSk7XG5cbiAgICAgICAgICBhcmMuc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGFyYy5lbmRBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgIGFyYy5hcmNcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhhcmNzLmxlbmd0aChhcmNzLmFjdGl2ZSkpXG4gICAgICAgICAgICAuc3RhcnRBbmdsZShhbmdsZSlcbiAgICAgICAgICAgIC5lbmRBbmdsZShhbmdsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoYXJjcyk7XG4gICAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICBfXy5icnVzaGVkID0gYnJ1c2hlZDtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoYXJjcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgYXJjcy5hY3RpdmUgPSBkO1xuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25EcmFnRW5kKGFyY3MpKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICB2YXIgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKTtcblxuICAgICAgLy8gTWFwIG9mIGN1cnJlbnQgYXJjcy4gYXJjcyBhcmUgc3RvcmVkIHBlciBzZWdtZW50IG9mIHRoZSBQQy4gQSBzZWdtZW50LFxuICAgICAgLy8gYmVpbmcgdGhlIGFyZWEgYmV0d2VlbiB0d28gYXhlcy4gVGhlIGxlZnQgbW9zdCBhcmVhIGlzIGluZGV4ZWQgYXQgMC5cbiAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgLy8gUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIFBDIHNlZ21lbnQgd2hlcmUgY3VycmVudGx5IGEgYXJjIGlzIGJlaW5nXG4gICAgICAvLyBwbGFjZWQuIE5PVEU6IGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGV2ZW5seSBzcGFjZWQgaW4gb3VyIGN1cnJlbnRcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXG4gICAgICAvLyB3ZWxsLlxuICAgICAgYXJjcy53aWR0aCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmMubWF4WCAtIGFyYy5taW5YO1xuICAgICAgfTtcblxuICAgICAgLy8gcmV0dXJucyBhbmdsZXMgaW4gWy1QSS8yLCBQSS8yXVxuICAgICAgYW5nbGUgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgIHZhciBhID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgICBiID0gcDFbMV0gLSBwMlsxXSxcbiAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYik7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYXNpbihiIC8gYyk7XG4gICAgICB9O1xuXG4gICAgICAvLyByZXR1cm5zIGFuZ2xlcyBpbiBbMCwgMiAqIFBJXVxuICAgICAgYXJjcy5lbmRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNBbmdsZSA9IGFuZ2xlKGFyYy5wMSwgYXJjLnAyKSxcbiAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wMlswXSkge1xuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcbiAgICAgIH07XG5cbiAgICAgIGFyY3Muc3RhcnRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc0FuZ2xlID0gYW5nbGUoYXJjLnAxLCBhcmMucDMpLFxuICAgICAgICAgIHVBbmdsZSA9IC1zQW5nbGUgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAoYXJjLnAxWzBdID4gYXJjLnAzWzBdKSB7XG4gICAgICAgICAgdUFuZ2xlID0gMiAqIE1hdGguUEkgLSB1QW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdUFuZ2xlO1xuICAgICAgfTtcblxuICAgICAgYXJjcy5sZW5ndGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xuXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYSA9IGFyYy5wMVswXSAtIGFyYy5wMlswXSxcbiAgICAgICAgICBiID0gYXJjLnAxWzFdIC0gYXJjLnAyWzFdLFxuICAgICAgICAgIGMgPSBoeXBvdGhlbnVzZShhLCBiKTtcblxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG5cbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBmaXJzdCBkaW1lbnNpb24gaXMgZGlyZWN0bHkgbGVmdCBvZiB0aGUgc2Vjb25kIGRpbWVuc2lvbi5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3RcbiAgICAgICAgICAgICAgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kXG4gICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgYXJjcywgd2hpY2ggbWlnaHQgbmVlZCB0byBiZSByZW1vdmVkLlxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IGFyY3NbZF0uZGltcztcbiAgICAgICAgICAgIGFyY3MuYWN0aXZlID0gZDtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0d28gZGltZW5zaW9ucyBvZiB0aGUgY3VycmVudCBhcmMgYXJlIG5vdCBuZXh0IHRvIGVhY2ggb3RoZXJcbiAgICAgICAgICAgIC8vIGFueSBtb3JlLCB0aGFuIHdlJ2xsIG5lZWQgdG8gcmVtb3ZlIHRoZSBhcmMuIE90aGVyd2lzZSB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgaWYgKCFjb25zZWN1dGl2ZShkaW1zLmxlZnQsIGRpbXMucmlnaHQpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uRHJhZ0VuZChhcmNzKSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBhcmNzLlxuICAgICAgcGMuc2VsZWN0aW9uXG4gICAgICAgIC5zZWxlY3QoJ3N2ZycpXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cignaWQnLCAnYXJjcycpXG4gICAgICAgIC5hdHRyKFxuICAgICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyxcbiAgICAgICAgKTtcblxuICAgICAgLy8gSW5zdGFsbCB0aGUgcmVxdWlyZWQgYnJ1c2hSZXNldCBmdW5jdGlvblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoYXJjcyk7XG5cbiAgICAgIGRyYWdcbiAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydChhcmNzKSlcbiAgICAgICAgLm9uKCdkcmFnJywgb25EcmFnKGFyY3MpKVxuICAgICAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoYXJjcykpO1xuXG4gICAgICAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgIC8vICAgICAgIGZvciAxRCBicnVzaGluZywgdGhlIGNhbnZhcyBsYXllcnMgc2hvdWxkIG5vdCBsaXN0ZW4gdG9cbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxuICAgICAgc3RydW1SZWN0ID0gcGMuc2VsZWN0aW9uXG4gICAgICAgIC5zZWxlY3QoJ3N2ZycpXG4gICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAnZyNhcmNzJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy1ldmVudHMnKVxuICAgICAgICAuYXR0cigneCcsIF9fLm1hcmdpbi5sZWZ0KVxuICAgICAgICAuYXR0cigneScsIF9fLm1hcmdpbi50b3ApXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAgIC5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWydhbmd1bGFyJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgncmVjdCNhcmMtZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgdW5kZWZpbmVkKTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG5cbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyY3M7XG4gICAgICB9LFxuICAgIH07XG4gIH0pKCk7XG5cbiAgcGMuaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZ3MuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGV4cG9zZSBhIGZldyBvYmplY3RzXG4gIHBjLnhzY2FsZSA9IHhzY2FsZTtcbiAgcGMueXNjYWxlID0geXNjYWxlO1xuICBwYy5jdHggPSBjdHg7XG4gIHBjLmNhbnZhcyA9IGNhbnZhcztcbiAgcGMuZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZztcbiAgfTtcblxuICAvLyByZXNjYWxlIGZvciBoZWlnaHQsIHdpZHRoIGFuZCBtYXJnaW5zXG4gIC8vIFRPRE8gY3VycmVudGx5IGFzc3VtZXMgY2hhcnQgaXMgYnJ1c2hhYmxlLCBhbmQgZGVzdHJveXMgb2xkIGJydXNoZXNcbiAgcGMucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNlbGVjdGlvbiBzaXplXG4gICAgcGMuc2VsZWN0aW9uXG4gICAgICAuc2VsZWN0KCdzdmcnKVxuICAgICAgLmF0dHIoJ3dpZHRoJywgX18ud2lkdGgpXG4gICAgICAuYXR0cignaGVpZ2h0JywgX18uaGVpZ2h0KTtcbiAgICBwYy5zdmcuYXR0cihcbiAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknLFxuICAgICk7XG5cbiAgICAvLyBGSVhNRTogdGhlIGN1cnJlbnQgYnJ1c2ggc3RhdGUgc2hvdWxkIHBhc3MgdGhyb3VnaFxuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoUmVzZXQoKTtcblxuICAgIC8vIHNjYWxlc1xuICAgIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgLy8gYXhlcywgZGVzdHJveXMgb2xkIGJydXNoZXMuXG4gICAgaWYgKGcpIHBjLmNyZWF0ZUF4ZXMoKTtcbiAgICBpZiAoZmxhZ3MuYnJ1c2hhYmxlKSBwYy5icnVzaGFibGUoKTtcbiAgICBpZiAoZmxhZ3MucmVvcmRlcmFibGUpIHBjLnJlb3JkZXJhYmxlKCk7XG5cbiAgICBldmVudHMucmVzaXplLmNhbGwodGhpcywge1xuICAgICAgd2lkdGg6IF9fLndpZHRoLFxuICAgICAgaGVpZ2h0OiBfXy5oZWlnaHQsXG4gICAgICBtYXJnaW46IF9fLm1hcmdpbixcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBoaWdobGlnaHQgYW4gYXJyYXkgb2YgZGF0YVxuICBwYy5oaWdobGlnaHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gX18uaGlnaGxpZ2h0ZWQ7XG4gICAgfVxuXG4gICAgX18uaGlnaGxpZ2h0ZWQgPSBkYXRhO1xuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcbiAgICBkMy5zZWxlY3RBbGwoW2NhbnZhcy5mb3JlZ3JvdW5kLCBjYW52YXMuYnJ1c2hlZF0pLmNsYXNzZWQoJ2ZhZGVkJywgdHJ1ZSk7XG4gICAgZGF0YS5mb3JFYWNoKHBhdGhfaGlnaGxpZ2h0KTtcbiAgICBldmVudHMuaGlnaGxpZ2h0LmNhbGwodGhpcywgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gY2xlYXIgaGlnaGxpZ2h0aW5nXG4gIHBjLnVuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIF9fLmhpZ2hsaWdodGVkID0gW107XG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xuICAgIGQzLnNlbGVjdEFsbChbY2FudmFzLmZvcmVncm91bmQsIGNhbnZhcy5icnVzaGVkXSkuY2xhc3NlZCgnZmFkZWQnLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gY2FsY3VsYXRlIDJkIGludGVyc2VjdGlvbiBvZiBsaW5lIGEtPmIgd2l0aCBsaW5lIGMtPmRcbiAgLy8gcG9pbnRzIGFyZSBvYmplY3RzIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXG4gIHBjLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6XG4gICAgICAgICgoYS54ICogYi55IC0gYS55ICogYi54KSAqIChjLnggLSBkLngpIC1cbiAgICAgICAgICAoYS54IC0gYi54KSAqIChjLnggKiBkLnkgLSBjLnkgKiBkLngpKSAvXG4gICAgICAgICgoYS54IC0gYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gZC54KSksXG4gICAgICB5OlxuICAgICAgICAoKGEueCAqIGIueSAtIGEueSAqIGIueCkgKiAoYy55IC0gZC55KSAtXG4gICAgICAgICAgKGEueSAtIGIueSkgKiAoYy54ICogZC55IC0gYy55ICogZC54KSkgL1xuICAgICAgICAoKGEueCAtIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAtIGQueCkpLFxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcG9zaXRpb24oZCkge1xuICAgIHZhciB2ID0gZHJhZ2dpbmdbZF07XG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/IHhzY2FsZShkKSA6IHY7XG4gIH1cbiAgcGMudmVyc2lvbiA9ICcwLjcuMCc7XG4gIC8vIHRoaXMgZGVzY3JpcHRpdmUgdGV4dCBzaG91bGQgbGl2ZSB3aXRoIG90aGVyIGludHJvc3BlY3RpdmUgbWV0aG9kc1xuICBwYy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgJ1BhcmFsbGVsIENvb3JkaW5hdGVzOiAnICtcbiAgICAgIF9fLmRpbWVuc2lvbnMubGVuZ3RoICtcbiAgICAgICcgZGltZW5zaW9ucyAoJyArXG4gICAgICBkMy5rZXlzKF9fLmRhdGFbMF0pLmxlbmd0aCArXG4gICAgICAnIHRvdGFsKSAsICcgK1xuICAgICAgX18uZGF0YS5sZW5ndGggK1xuICAgICAgJyByb3dzJ1xuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIHBjO1xufVxuXG5kMy5yZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHZhciBfcXVldWUgPSBbXSwgLy8gZGF0YSB0byBiZSByZW5kZXJlZFxuICAgIF9yYXRlID0gMTAsIC8vIG51bWJlciBvZiBjYWxscyBwZXIgZnJhbWVcbiAgICBfY2xlYXIgPSBmdW5jdGlvbiAoKSB7fSwgLy8gY2xlYXJpbmcgZnVuY3Rpb25cbiAgICBfaSA9IDA7IC8vIGN1cnJlbnQgaXRlcmF0aW9uXG5cbiAgdmFyIHJxID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkgcnEuZGF0YShkYXRhKTtcbiAgICBycS5pbnZhbGlkYXRlKCk7XG4gICAgX2NsZWFyKCk7XG4gICAgcnEucmVuZGVyKCk7XG4gIH07XG5cbiAgcnEucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF9pID0gMDtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgIHJxLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkb0ZyYW1lKCkge1xuICAgICAgaWYgKCF2YWxpZCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoX2kgPiBfcXVldWUubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gVHlwaWNhbCBkMyBiZWhhdmlvciBpcyB0byBwYXNzIGEgZGF0YSBpdGVtICphbmQqIGl0cyBpbmRleC4gQXMgdGhlXG4gICAgICAvLyByZW5kZXIgcXVldWUgc3BsaXRzIHRoZSBvcmlnaW5hbCBkYXRhIHNldCwgd2UnbGwgaGF2ZSB0byBiZSBzbGlnaHRseVxuICAgICAgLy8gbW9yZSBjYXJlZnVsbCBhYm91dCBwYXNzaW5nIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggdGhlIGRhdGEgaXRlbS5cbiAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihfaSArIF9yYXRlLCBfcXVldWUubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSBfaTsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICAgIGZ1bmMoX3F1ZXVlW2ldLCBpKTtcbiAgICAgIH1cbiAgICAgIF9pICs9IF9yYXRlO1xuICAgIH1cblxuICAgIGQzLnRpbWVyKGRvRnJhbWUpO1xuICB9O1xuXG4gIHJxLmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJxLmludmFsaWRhdGUoKTtcbiAgICBfcXVldWUgPSBkYXRhLnNsaWNlKDApO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5yYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gX3JhdGU7XG4gICAgX3JhdGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gcnE7XG4gIH07XG5cbiAgcnEucmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcXVldWUubGVuZ3RoIC0gX2k7XG4gIH07XG5cbiAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICBycS5jbGVhciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBfY2xlYXIoKTtcbiAgICAgIHJldHVybiBycTtcbiAgICB9XG4gICAgX2NsZWFyID0gZnVuYztcbiAgICByZXR1cm4gcnE7XG4gIH07XG5cbiAgcnEuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHJldHVybiBycTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js":
/*!******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\n\nfunction (config) {\n  var columns = [];\n\n  var dg = function (selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]);\n\n    // header\n    selection.\n    selectAll('.header').\n    data([true]).\n    enter().\n    append('div').\n    attr('class', 'header');\n\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n\n    header.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n\n    header.exit().remove();\n\n    // rows\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n\n    rows.enter().append('div').attr('class', 'row');\n\n    rows.exit().remove();\n\n    var cells = selection.\n    selectAll('.row').\n    selectAll('.cell').\n    data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    });\n\n    // cells\n    cells.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    cells.exit().remove();\n\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n}; /* [LICENSE TBD] */ /* eslint-disable */ // from http://bl.ocks.org/3687826\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBekVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcz80MDQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBmcm9tIGh0dHA6Ly9ibC5vY2tzLm9yZy8zNjg3ODI2XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBjb2x1bW5zID0gW107XG5cbiAgdmFyIGRnID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgIGlmIChjb2x1bW5zLmxlbmd0aCA9PSAwKSBjb2x1bW5zID0gZDMua2V5cyhzZWxlY3Rpb24uZGF0YSgpWzBdWzBdKTtcblxuICAgIC8vIGhlYWRlclxuICAgIHNlbGVjdGlvblxuICAgICAgLnNlbGVjdEFsbCgnLmhlYWRlcicpXG4gICAgICAuZGF0YShbdHJ1ZV0pXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgnZGl2JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdoZWFkZXInKTtcblxuICAgIHZhciBoZWFkZXIgPSBzZWxlY3Rpb24uc2VsZWN0KCcuaGVhZGVyJykuc2VsZWN0QWxsKCcuY2VsbCcpLmRhdGEoY29sdW1ucyk7XG5cbiAgICBoZWFkZXJcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgICB9KVxuICAgICAgLmNsYXNzZWQoJ2NlbGwnLCB0cnVlKTtcblxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5oZWFkZXIgLmNlbGwnKS50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcblxuICAgIGhlYWRlci5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAvLyByb3dzXG4gICAgdmFyIHJvd3MgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKCcucm93JykuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG5cbiAgICByb3dzLmVudGVyKCkuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdyb3cnKTtcblxuICAgIHJvd3MuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgdmFyIGNlbGxzID0gc2VsZWN0aW9uXG4gICAgICAuc2VsZWN0QWxsKCcucm93JylcbiAgICAgIC5zZWxlY3RBbGwoJy5jZWxsJylcbiAgICAgIC5kYXRhKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgcmV0dXJuIGRbY29sXTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIC8vIGNlbGxzXG4gICAgY2VsbHNcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgICB9KVxuICAgICAgLmNsYXNzZWQoJ2NlbGwnLCB0cnVlKTtcblxuICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5jZWxsJykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGc7XG4gIH07XG5cbiAgZGcuY29sdW1ucyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sdW1ucztcbiAgICBjb2x1bW5zID0gXztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gZGc7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\n");

/***/ }),

/***/ "./packages/superset-ui-core/src/chart/components/reactify.tsx":
/*!*********************************************************************!*\
  !*** ./packages/superset-ui-core/src/chart/components/reactify.tsx ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reactify)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction reactify(renderFn, callbacks) {\n  class ReactifiedComponent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n\n    constructor(props) {\n      super(props);this.container = void 0;\n      this.setContainerRef = this.setContainerRef.bind(this);\n    }\n    componentDidMount() {\n      this.execute();\n    }\n    componentDidUpdate() {\n      this.execute();\n    }\n    componentWillUnmount() {\n      this.container = undefined;\n      if (callbacks != null && callbacks.componentWillUnmount) {\n        callbacks.componentWillUnmount.bind(this)();\n      }\n    }\n    setContainerRef(ref) {\n      this.container = ref;\n    }\n    execute() {\n      if (this.container) {\n        renderFn(this.container, this.props);\n      }\n    }\n    render() {\n      const { id, className } = this.props;\n      return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: this.setContainerRef, id: id, className: className });\n    } // @ts-ignore\n    __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n      this[key] = eval(code);}}const ReactifiedClass = ReactifiedComponent;\n  if (renderFn.displayName) {\n    ReactifiedClass.displayName = renderFn.displayName;\n  }\n  // eslint-disable-next-line react/forbid-foreign-prop-types\n  if (renderFn.propTypes) {\n    ReactifiedClass.propTypes = {\n      ...ReactifiedClass.propTypes,\n      ...renderFn.propTypes\n    };\n  }\n  if (renderFn.defaultProps) {\n    ReactifiedClass.defaultProps = renderFn.defaultProps;\n  }\n  return ReactifiedComponent;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(reactify, \"reactify\", \"/app/superset-frontend/packages/superset-ui-core/src/chart/components/reactify.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlcy9zdXBlcnNldC11aS1jb3JlL3NyYy9jaGFydC9jb21wb25lbnRzL3JlYWN0aWZ5LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBK0JBO0FBSUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGFja2FnZXMvc3VwZXJzZXQtdWktY29yZS9zcmMvY2hhcnQvY29tcG9uZW50cy9yZWFjdGlmeS50c3g/ZWNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVE9ETzogTm90ZSB0aGF0IGlkIGFuZCBjbGFzc05hbWUgY2FuIGNvbGxpZGUgYmV0d2VlbiBQcm9wcyBhbmQgUmVhY3RpZnlQcm9wc1xuLy8gbGVhZGluZyB0byAobGlrZWx5KSB1bmV4cGVjdGVkIGJlaGF2aW9ycy4gV2Ugc2hvdWxkIGVpdGhlciByZXF1aXJlIFByb3BzIHRvIG5vdFxuLy8gY29udGFpbiBhbiBpZC9jbGFzc05hbWUsIG9yIG5vdCBjb21iaW5lIHRoZW0gKHZpYSBpbnRlcnNlY3Rpb24pLCBpbnN0ZWFkIHByZWZlcnJpbmdcbi8vIHdyYXBwaW5nIChjb21wb3NpdGlvbikuIEFzIGFuIGV4YW1wbGU6XG4vLyBpbnRlcmZhY2UgTXlQcm9wcyB7XG4vLyAgIGlkOiBudW1iZXI7XG4vLyB9XG4vLyBmdW5jdGlvbiBteVJlbmRlcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8TXlQcm9wcz4pOiB2b2lkIHtcbi8vICAgcHJvcHMuaWQgLy8gdW51c2FibGU6IGlkIGlzIHN0cmluZyAmIG51bWJlclxuLy8gfVxuLy8gbmV3IChyZWFjdGlmeShteVJlbmRlcikpKHsgaWQ6IDUgfSk7IC8vIGVycm9yOiBpZCBoYXMgdG8gYmUgc3RyaW5nICYgbnVtYmVyXG5cbmV4cG9ydCB0eXBlIFJlYWN0aWZ5UHJvcHMgPSB7XG4gIGlkPzogc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59O1xuXG4vLyBUT0RPOiBhZGQgbW9yZSBSZWFjdCBsaWZlY3ljbGUgY2FsbGJhY2tzIGFzIG5lZWRlZFxuZXhwb3J0IHR5cGUgTGlmZUN5Y2xlQ2FsbGJhY2tzID0ge1xuICBjb21wb25lbnRXaWxsVW5tb3VudD86ICgpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckZ1bmNUeXBlPFByb3BzPiB7XG4gIChjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8UHJvcHMgJiBSZWFjdGlmeVByb3BzPik6IHZvaWQ7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBkZWZhdWx0UHJvcHM/OiBQYXJ0aWFsPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XG4gIHByb3BUeXBlcz86IFJlYWN0LldlYWtWYWxpZGF0aW9uTWFwPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWN0aWZ5PFByb3BzIGV4dGVuZHMgb2JqZWN0PihcbiAgcmVuZGVyRm46IFJlbmRlckZ1bmNUeXBlPFByb3BzPixcbiAgY2FsbGJhY2tzPzogTGlmZUN5Y2xlQ2FsbGJhY2tzLFxuKTogUmVhY3QuQ29tcG9uZW50Q2xhc3M8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiB7XG4gIGNsYXNzIFJlYWN0aWZpZWRDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMgJiBSZWFjdGlmeVByb3BzPiB7XG4gICAgY29udGFpbmVyPzogSFRNTERpdkVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMgJiBSZWFjdGlmeVByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLnNldENvbnRhaW5lclJlZiA9IHRoaXMuc2V0Q29udGFpbmVyUmVmLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGNhbGxiYWNrcz8uY29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgICAgY2FsbGJhY2tzLmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQodGhpcykoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDb250YWluZXJSZWYocmVmOiBIVE1MRGl2RWxlbWVudCkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSByZWY7XG4gICAgfVxuXG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICByZW5kZXJGbih0aGlzLmNvbnRhaW5lciwgdGhpcy5wcm9wcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyBpZCwgY2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICByZXR1cm4gPGRpdiByZWY9e3RoaXMuc2V0Q29udGFpbmVyUmVmfSBpZD17aWR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSAvPjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBSZWFjdGlmaWVkQ2xhc3M6IFJlYWN0LkNvbXBvbmVudENsYXNzPFByb3BzICYgUmVhY3RpZnlQcm9wcz4gPVxuICAgIFJlYWN0aWZpZWRDb21wb25lbnQ7XG5cbiAgaWYgKHJlbmRlckZuLmRpc3BsYXlOYW1lKSB7XG4gICAgUmVhY3RpZmllZENsYXNzLmRpc3BsYXlOYW1lID0gcmVuZGVyRm4uZGlzcGxheU5hbWU7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2ZvcmJpZC1mb3JlaWduLXByb3AtdHlwZXNcbiAgaWYgKHJlbmRlckZuLnByb3BUeXBlcykge1xuICAgIFJlYWN0aWZpZWRDbGFzcy5wcm9wVHlwZXMgPSB7XG4gICAgICAuLi5SZWFjdGlmaWVkQ2xhc3MucHJvcFR5cGVzLFxuICAgICAgLi4ucmVuZGVyRm4ucHJvcFR5cGVzLFxuICAgIH07XG4gIH1cbiAgaWYgKHJlbmRlckZuLmRlZmF1bHRQcm9wcykge1xuICAgIFJlYWN0aWZpZWRDbGFzcy5kZWZhdWx0UHJvcHMgPSByZW5kZXJGbi5kZWZhdWx0UHJvcHM7XG4gIH1cblxuICByZXR1cm4gUmVhY3RpZmllZENvbXBvbmVudDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./packages/superset-ui-core/src/chart/components/reactify.tsx\n");

/***/ })

}]);